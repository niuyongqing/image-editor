This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.spec/active-context.md
.spec/feature-ruler-interaction.md
.spec/project-charter.md
.spec/prompt.md
.spec/system-patterns.md
index.html
jsconfig.json
package.json
public/vite.svg
README.md
src/api/ai.js
src/App.vue
src/assets/image/01.jpg
src/assets/vue.svg
src/components/common/CanvasContextMenu.vue
src/components/common/FloatingObjectMenu.vue
src/components/common/LoadingOverlay.vue
src/components/common/Modal.vue
src/components/common/ShortcutsPanel.vue
src/components/layout/EditorLayout.vue
src/components/layout/LeftSidebar.vue
src/components/layout/NavBar.vue
src/components/modules/adjust/AdjustColor.vue
src/components/modules/adjust/AdjustColorOverlay.vue
src/components/modules/adjust/AdjustCrop.vue
src/components/modules/adjust/AdjustFilters.vue
src/components/modules/adjust/AdjustInpaint.vue
src/components/modules/adjust/AdjustMosaic.vue
src/components/modules/adjust/AdjustRembg.vue
src/components/modules/adjust/AdjustResize.vue
src/components/modules/adjust/AdjustRuler.vue
src/components/modules/adjust/AdjustWhite.vue
src/components/modules/adjust/index.vue
src/components/modules/adjust/useCanvasColor.js
src/components/modules/adjust/useCanvasColorOverlay.js
src/components/modules/adjust/useCanvasCrop.js
src/components/modules/adjust/useCanvasFilters.js
src/components/modules/adjust/useCanvasInpaint.js
src/components/modules/adjust/useCanvasMosaic.js
src/components/modules/adjust/useCanvasResize.js
src/components/modules/adjust/useCanvasRuler.js
src/components/modules/adjust/useCanvasWhite.js
src/components/modules/ai/AiExpand.vue
src/components/modules/ai/AiGenerate.vue
src/components/modules/ai/index.vue
src/components/modules/border/index.vue
src/components/modules/draw/DrawBrush.vue
src/components/modules/draw/DrawShape.vue
src/components/modules/draw/index.vue
src/components/modules/material/index.vue
src/components/modules/puzzle/config.js
src/components/modules/puzzle/index.vue
src/components/modules/puzzle/useCanvasPuzzle.js
src/components/modules/text/index.vue
src/components/modules/text/TextAdd.vue
src/components/modules/text/TextStyle.vue
src/components/modules/watermark/index.vue
src/components/panels/ToolPanel.vue
src/components/Workspace.vue
src/composables/useCanvas.js
src/composables/useConstraint.js
src/composables/useEditorState.js
src/composables/useKeyboardShortcuts.js
src/composables/useObjectActions.js
src/composables/useOffscreenHelper.js
src/config/shortcuts.js
src/index.js
src/main.js
src/style.css
src/utils/toast.js
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".spec/feature-ruler-interaction.md">
# Feature Spec: High-Precision Ruler & Global Interaction System
# åŠŸèƒ½ç¡®è®¤ä¹¦ï¼šé«˜ç²¾æ ‡å°ºä¸é€šç”¨äº¤äº’ç³»ç»Ÿ

> **Version**: 1.0
> **Status**: Execution Phase 1 (Infrastructure)
> **Goal**: å»ºç«‹ä»¥â€œå¯¹è±¡â€ä¸ºä¸­å¿ƒçš„å…¨å±€å¯¼èˆªä½“éªŒï¼Œå¹¶å®ç°å·¥ç¨‹çº§æµ‹é‡æ ‡æ³¨ã€‚

## 1. æ ¸å¿ƒåŠŸèƒ½è§„æ ¼ (Core Specifications)

### 1.1 é«˜ç²¾æµ‹é‡æ ‡å°º (Measurement Ruler)
* **å®šä½**: å…¨å±€å¸¸é©»çš„æ ‡æ³¨å¯¹è±¡ï¼Œæ•°å€¼ä¸ç‰©ç†é•¿åº¦è§£è€¦ï¼ˆå®šæ ‡é€»è¾‘ï¼‰ã€‚
* **äº¤äº’**:
    * **åˆ›å»ºæ¨¡å¼**: å…¨å±é”å®šï¼Œæ‹¦æˆªç‚¹å‡»ç”¨äºç”»çº¿ã€‚
    * **ç¼–è¾‘æ¨¡å¼**: é€‰ä¸­åé¢æ¿æ˜¾ç¤ºå±æ€§ï¼Œæ”¯æŒç«¯ç‚¹/æ ·å¼ä¿®æ”¹ã€‚
* **æ ·å¼**: æä¾›â€œå®å¿ƒåœ†/ç®­å¤´â€é¢„è®¾ï¼Œæ”¯æŒé¢œè‰²ã€å­—å·ã€èƒŒæ™¯è‡ªå®šä¹‰ã€‚

### 1.2 ä¸Šä¸‹æ–‡æ„ŸçŸ¥å¯¼èˆª (Context-Aware Navigation)
* **æ™ºèƒ½è·¯ç”±**: ç‚¹å‡»ç”»å¸ƒå¯¹è±¡ï¼ˆæ ‡å°º/æ–‡å­—/è´´çº¸ï¼‰ -> ä¾§è¾¹æ è‡ªåŠ¨è·³è½¬å¯¹åº”æ¨¡å—ã€‚
* **é˜²è¯¯è§¦**: æ‹–æ‹½ä¸è·³è½¬ï¼Œä»…çº¯ç‚¹å‡»ï¼ˆClickï¼‰è·³è½¬ï¼›å¤šé€‰ä¸è·³è½¬ã€‚
* **å…¨å±€å¼€å…³**: é¡¶éƒ¨ NavBar å¢åŠ æ ‡å°ºæ˜¾éšæŒ‰é’®ã€‚

### 1.3 é€šç”¨æ‚¬æµ®èœå• (Floating Object Menu)
* **å½¢æ€**: HTML DOM æ‚¬æµ®å±‚ï¼Œè·Ÿéšé€‰ä¸­å¯¹è±¡ç§»åŠ¨ã€‚
* **åŠŸèƒ½**:
    * **é€šç”¨**: å¤åˆ¶ã€åˆ é™¤ã€é”å®šã€å›¾å±‚è°ƒæ•´ (ç½®é¡¶/åº•/ä¸Š/ä¸‹)ã€‚
    * **æ‰©å±•**: æä¾› Slot æ’æ§½ï¼Œå…è®¸æ ‡å°ºï¼ˆåˆ‡æ¢å•ä½ï¼‰æˆ–æ–‡å­—ï¼ˆç¼–è¾‘ï¼‰æ’å…¥ç‰¹æœ‰æŒ‰é’®ã€‚

---

## 2. å®æ–½è·¯çº¿å›¾ (Implementation Roadmap)

### âœ… é˜¶æ®µä¸€ï¼šåŸºç¡€è®¾æ–½ (Infrastructure)
* [ ] `useObjectActions.js`: å°è£…é€šç”¨çš„å¯¹è±¡æ“ä½œé€»è¾‘ (Copy/Paste/Lock/Layer)ã€‚
* [ ] `FloatingObjectMenu.vue`: å®ç° DOM è·Ÿéšç®—æ³•ä¸é€šç”¨ UIã€‚
* [ ] `Workspace.vue`: é›†æˆæ‚¬æµ®èœå•ã€‚

### ğŸ“… é˜¶æ®µäºŒï¼šæ ‡å°ºæ ¸å¿ƒ (Ruler Core)
* [ ] `useCanvasRuler.js`: æ ‡å°ºå¯¹è±¡æ¨¡å‹ä¸ç»˜åˆ¶é€»è¾‘ã€‚
* [ ] `AdjustRuler.vue`: æ ‡å°ºé¢æ¿ä¸é¢„è®¾ç³»ç»Ÿã€‚

### ğŸ“… é˜¶æ®µä¸‰ï¼šå…¨å±€é›†æˆ (Global Integration)
* [ ] `useCanvas.js`: å…¨å±€æ™ºèƒ½è·³è½¬ä¾¦å¬å™¨ã€‚
* [ ] `NavBar.vue`: å…¨å±€æ ‡å°ºå¼€å…³ã€‚
</file>

<file path=".spec/system-patterns.md">
"æ³¨æ„ï¼šåœ¨å¤§ç§˜ç¾å›¾ä¸­ï¼ŒFabric çš„ Canvas å¿…é¡»ç”¨ markRaw åŒ…è£…ï¼Œå¦åˆ™ä¼šå¯¼è‡´ Vue å“åº”å¼å¡æ­»ã€‚ä¹‹å‰åœ¨ 2024-12 é‡åˆ°è¿‡è¿™ä¸ªé—®é¢˜ã€‚"
</file>

<file path="jsconfig.json">
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/assets/vue.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>
</file>

<file path="src/components/common/CanvasContextMenu.vue">
<template>
  <div 
    v-show="visible" 
    class="context-menu"
    :style="{ left: position.x + 'px', top: position.y + 'px' }"
    @contextmenu.prevent 
  >
    <div 
      class="menu-item" 
      :class="{ disabled: !clipboardState.hasContent }"
      @click="handlePaste"
    >
      <span class="icon">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>
      </span>
      <span>ç²˜è´´</span>
      <span class="shortcut">Ctrl+V</span>
    </div>

    </div>
</template>

<script setup>
import { inject } from 'vue';
import { useObjectActions } from '@/composables/useObjectActions';

// æ¥æ”¶ Props æ§åˆ¶æ˜¾ç¤º
const props = defineProps({
  visible: Boolean,
  position: {
    type: Object,
    default: () => ({ x: 0, y: 0 })
  }
});

const emit = defineEmits(['close', 'paste']);

const actions = useObjectActions();
const clipboardState = actions.clipboardState;

const handlePaste = () => {
  if (!clipboardState.hasContent) return;
  emit('paste'); // é€šçŸ¥çˆ¶ç»„ä»¶è¿›è¡Œç²˜è´´
  emit('close'); // å…³é—­èœå•
};
</script>

<style scoped>
.context-menu {
  position: fixed; /* ä½¿ç”¨ fixed é¿å…å—çˆ¶å®¹å™¨ overflow å½±å“ */
  z-index: 3000;
  background: #ffffff;
  border: 1px solid #ebeef5;
  border-radius: 6px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
  padding: 4px 0;
  width: 140px;
  min-width: 120px;
}

.menu-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  font-size: 13px;
  color: #606266;
  cursor: pointer;
  transition: background 0.1s;
}

.menu-item:hover {
  background: #f5f7fa;
  color: var(--ie-primary-color);
}

.menu-item.disabled {
  color: #c0c4cc;
  cursor: not-allowed;
  background: transparent !important;
}

.icon {
  display: flex;
  align-items: center;
  margin-right: 8px;
  width: 16px;
}

.shortcut {
  margin-left: auto;
  font-size: 12px;
  color: #909399;
}
</style>
</file>

<file path="src/components/common/FloatingObjectMenu.vue">
<template>
  <div 
    v-show="isVisible" 
    class="floating-wrapper"
    :style="{ left: position.left + 'px', top: position.top + 'px' }"
  >
    <button 
      class="trigger-btn" 
      @click.stop="toggleMenu" 
      :class="{ active: isMenuOpen }"
      title="æ›´å¤šæ“ä½œ"
    >
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="1"></circle>
        <circle cx="19" cy="12" r="1"></circle>
        <circle cx="5" cy="12" r="1"></circle>
      </svg>
    </button>

    <div v-if="isMenuOpen" class="main-menu">
      
      <div class="menu-item" @click="handleAction(actions.copyActive)">
        <span class="icon">
           <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
        </span>
        <span class="label">å¤åˆ¶</span>
        <span class="shortcut">Ctrl+C</span>
      </div>

      <div class="menu-item" @click="handleAction(actions.cutActive)">
        <span class="icon">
           <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line></svg>
        </span>
        <span class="label">å‰ªåˆ‡</span>
        <span class="shortcut">Ctrl+X</span>
      </div>

      <div class="menu-item" @click="handleLock">
        <span class="icon">
          <svg v-if="isLocked" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
          <svg v-else width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path></svg>
        </span>
        <span class="label">{{ isLocked ? 'è§£é”' : 'é”å®š' }}</span>
        <span class="shortcut">Shift+Ctrl+L</span>
      </div>

      <div class="menu-item has-submenu">
        <span class="icon">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline><polyline points="2 7 12 12 22 7"></polyline></svg>
        </span>
        <span class="label">å›¾å±‚é¡ºåº</span>
        <span class="arrow-right">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </span>

        <div class="submenu">
           <div class="menu-item" @click="handleAction(() => actions.moveLayer('forward'))">
             <span class="label">ä¸Šä¸€å±‚</span>
             <span class="shortcut">]</span>
           </div>
           <div class="menu-item" @click="handleAction(() => actions.moveLayer('backward'))">
             <span class="label">ä¸‹ä¸€å±‚</span>
             <span class="shortcut">[</span>
           </div>
           <div class="divider"></div>
           <div class="menu-item" @click="handleAction(() => actions.moveLayer('front'))">
             <span class="label">ç½®é¡¶</span>
             <span class="shortcut">Shift+]</span>
           </div>
           <div class="menu-item" @click="handleAction(() => actions.moveLayer('back'))">
             <span class="label">ç½®åº•</span>
             <span class="shortcut">Shift+[</span>
           </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="menu-item delete" @click="handleAction(actions.deleteActive)">
        <span class="icon">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
        </span>
        <span class="label">åˆ é™¤</span>
        <span class="shortcut">Del</span>
      </div>

      <div v-if="$slots.extra">
          <div class="divider"></div>
          <slot name="extra"></slot>
      </div>

    </div>
  </div>
</template>

<script setup>
import { ref, inject, onMounted, onUnmounted, unref } from 'vue';
import { useObjectActions } from '@/composables/useObjectActions';

const canvasAPI = inject('canvasAPI');
const actions = useObjectActions();

const isVisible = ref(false);
const isMenuOpen = ref(false); 
const isLocked = ref(false);
const position = ref({ left: 0, top: 0 });

const toggleMenu = () => {
  isMenuOpen.value = !isMenuOpen.value;
};

const handleAction = (actionFn) => {
  actionFn();
  isMenuOpen.value = false; 
};

const handleLock = () => {
  const locked = actions.toggleLock();
  isLocked.value = locked;
};

// æ›´æ–°èœå•ä½ç½®
const updatePosition = () => {
  const canvas = unref(canvasAPI.canvas);
  const activeObj = canvas?.getActiveObject();

  if (!activeObj || activeObj.isMainImage) {
    isVisible.value = false;
    isMenuOpen.value = false;
    return;
  }

  const coords = activeObj.getBoundingRect(true, true);
  const containerWidth = canvas.getElement().parentElement.offsetWidth;
  const menuWidth = 40; 
  
  let newLeft = coords.left + coords.width + 40; 

  if (newLeft + menuWidth > containerWidth) {
      newLeft = coords.left - menuWidth + 76;
  }

  position.value = {
    left: newLeft,
    top: coords.top + 5
  };

  isVisible.value = true;
  isLocked.value = !!activeObj.lockMovementX;
};

const bindEvents = () => {
  const canvas = unref(canvasAPI.canvas);
  if (!canvas) return;

  const events = [
    'selection:created', 'selection:updated', 'object:moving', 
    'object:scaling', 'object:rotating', 'object:modified'
  ];
  events.forEach(evt => canvas.on(evt, updatePosition));
  
  canvas.on('selection:cleared', () => { 
    isVisible.value = false; 
    isMenuOpen.value = false;
  });
};

const unbindEvents = () => {
  const canvas = unref(canvasAPI.canvas);
  if (!canvas) return;
  canvas.off('selection:cleared');
  const events = [
    'selection:created', 'selection:updated', 'object:moving', 
    'object:scaling', 'object:rotating', 'object:modified'
  ];
  events.forEach(evt => canvas.off(evt));
};

onMounted(() => setTimeout(bindEvents, 200));
onUnmounted(unbindEvents);
</script>

<style scoped>
/* æ‚¬æµ®å®¹å™¨ */
.floating-wrapper {
  position: absolute;
  z-index: 2000;
  pointer-events: auto;
}

/* 1. è§¦å‘æŒ‰é’® */
.trigger-btn {
  width: 24px;
  height: 24px;
  border-radius: 8px;
  background: #ffffff;
  border: 1px solid #e4e7ed;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #606266;
  transition: all 0.2s;
  padding: 0 !important;
}

.trigger-btn:hover, .trigger-btn.active {
  background: #ecf5ff;
  color: var(--ie-primary-color);
  border-color: var(--ie-primary-color);
}

/* 2. ä¸»èœå• */
.main-menu {
  position: absolute;
  top: 15px;
  left: 22px;
  width: 180px; /* åŠ å®½ä¸€ç‚¹ä»¥å®¹çº³å¿«æ·é”® */
  background: #ffffff;
  border: 1px solid #ebeef5;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.1);
  padding: 4px 0;
  display: flex;
  flex-direction: column;
}

/* èœå•é¡¹å¸ƒå±€ä¼˜åŒ– */
.menu-item {
  position: relative;
  display: flex;
  align-items: center;
  padding: 8px 12px;
  font-size: 13px;
  color: #606266;
  cursor: pointer;
  transition: background 0.1s;
}

.menu-item:hover {
  background: #f5f7fa;
  color: var(--ie-primary-color);
}

.menu-item.delete:hover {
  background: #fef0f0;
  color: #f56c6c;
}

.icon {
  display: flex;
  align-items: center;
  margin-right: 8px;
  width: 16px;
  opacity: 0.8;
}

.label {
  flex: 1; /* æ’‘å¼€ä¸­é—´ï¼ŒæŠŠå¿«æ·é”®æŒ¤åˆ°å³è¾¹ */
}

/* âœ¨ å¿«æ·é”®æ ·å¼ */
.shortcut {
  font-size: 11px;
  color: #bfa; /* è¿™ä¸ªç»¿è‰²æ˜¯ç¤ºä¾‹ï¼Œå®é™…å»ºè®®ç”¨æµ…ç°è‰² */
  color: #909399; /* ä¿®æ­£ä¸ºæµ…ç°è‰²ï¼Œæ›´ä¸“ä¸š */
  margin-left: 8px;
  font-family: monospace; /* ç­‰å®½å­—ä½“æ›´å¥½çœ‹ */
  opacity: 0.8;
}

.arrow-right {
  margin-left: auto;
  opacity: 0.5;
  display: flex;
  align-items: center;
}

.divider {
  height: 1px;
  background: #ebeef5;
  margin: 4px 0;
}

/* 3. äºŒçº§èœå• */
.submenu {
  display: none;
  position: absolute;
  left: 100%;
  top: -4px;
  width: 140px; /* ä¹Ÿç¨å¾®åŠ å®½ */
  background: #ffffff;
  border: 1px solid #ebeef5;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.1);
  padding: 4px 0;
  margin-left: 4px;
}

.menu-item.has-submenu:hover .submenu {
  display: block;
}

.menu-item.has-submenu::after {
  content: '';
  position: absolute;
  top: 0;
  right: -10px;
  width: 10px;
  height: 100%;
}
</style>
</file>

<file path="src/components/common/LoadingOverlay.vue">
<template>
    <div v-if="state.isLoading" class="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <p class="loading-text">{{ state.loadingText }}</p>
        </div>
    </div>
</template>

<script setup>
import { useEditorState } from '@/composables/useEditorState';

// ç›´æ¥è¿æ¥å…¨å±€çŠ¶æ€
const { state } = useEditorState();
</script>

<style scoped>
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.7);
    /* åŠé€æ˜é»‘è‰²èƒŒæ™¯ */
    z-index: 9999;
    /* ç¡®ä¿å±‚çº§æœ€é«˜ï¼Œé®æŒ¡æ‰€æœ‰æ“ä½œ */
    display: flex;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(2px);
    /* è½»å¾®æ¨¡ç³ŠèƒŒæ™¯ */
}

.loading-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #ffffff;
    animation: spin 1s ease-in-out infinite;
}

.loading-text {
    color: #ffffff;
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 0.5px;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
</style>
</file>

<file path="src/components/common/Modal.vue">
<template>
    <Teleport to="body">
        <Transition name="fade">
            <div v-if="modelValue" class="modal-mask" @click.self="$emit('cancel')">
                <div class="modal-container">
                    <div class="modal-header">
                        <h3>{{ title }}</h3>
                    </div>
                    <div class="modal-body">
                        <slot>{{ content }}</slot>
                    </div>
                    <div class="modal-footer">
                        <button class="ie-btn btn-secondary" @click="$emit('discard')">ä¸ä¿å­˜</button>
                        <button class="ie-btn btn-primary" @click="$emit('confirm')">ä¿å­˜å¹¶é€€å‡º</button>
                    </div>
                </div>
            </div>
        </Transition>
    </Teleport>
</template>

<script setup>
defineProps({
    modelValue: Boolean,
    title: { type: String, default: 'æç¤º' },
    content: String
});
defineEmits(['update:modelValue', 'confirm', 'discard', 'cancel']);
</script>

<style scoped>
.modal-mask {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.modal-container {
    background: white;
    border-radius: 12px;
    width: 320px;
    padding: 24px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

.modal-header h3 {
    margin: 0 0 16px;
    font-size: 18px;
    color: #333;
}

.modal-body {
    font-size: 14px;
    color: #666;
    margin-bottom: 24px;
    line-height: 1.5;
}

.modal-footer {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
}

.ie-btn {
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    border: none;
    font-size: 14px;
}

.btn-primary {
    background: #409eff;
    color: white;
}

.btn-secondary {
    background: #f4f4f5;
    color: #606266;
}

.fade-enter-active,
.fade-leave-active {
    transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
    opacity: 0;
}
</style>
</file>

<file path="src/components/common/ShortcutsPanel.vue">
<template>
  <Teleport to="body">
    <Transition name="fade">
      <div v-if="visible" class="shortcut-overlay" @click="close"></div>
    </Transition>

    <Transition name="slide">
      <div v-if="visible" class="shortcut-drawer">
        <div class="drawer-header">
          <h3>å¿«æ·é”®åˆ—è¡¨</h3>
          <button class="close-btn" @click="close">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
          </button>
        </div>
        
        <div class="drawer-content">
          <div v-for="(group, index) in groups" :key="index" class="group-section">
            <h4 class="group-title">{{ group.title }}</h4>
            <div class="shortcut-list">
              <div v-for="(item, idx) in group.items" :key="idx" class="shortcut-item">
                <span class="label">{{ item.label }}</span>
                <div class="keys">
                  <span v-for="(key, kIdx) in item.keys" :key="kIdx" class="keycap">
                    {{ key }}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup>
import { defineProps, defineEmits } from 'vue';
import { SHORTCUT_GROUPS } from '@/config/shortcuts';

defineProps({
  visible: Boolean
});

const emit = defineEmits(['close']);
const groups = SHORTCUT_GROUPS;

const close = () => {
  emit('close');
};
</script>

<style scoped>
/* é®ç½©å±‚ */
.shortcut-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.4);
  z-index: 3000;
  backdrop-filter: blur(2px);
}

/* æŠ½å±‰é¢æ¿ */
.shortcut-drawer {
  position: fixed;
  top: 0;
  right: 0;
  width: 320px;
  height: 100vh;
  background: white;
  z-index: 3001;
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
}

/* å¤´éƒ¨ */
.drawer-header {
  padding: 20px;
  border-bottom: 1px solid #ebeef5;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.drawer-header h3 {
  margin: 0;
  font-size: 18px;
  color: #303133;
}

.close-btn {
  background: none;
  border: none;
  cursor: pointer;
  color: #909399;
  padding: 4px;
  border-radius: 4px;
  transition: background 0.2s;
  display: flex;
}
.close-btn:hover {
  background: #f5f7fa;
  color: #606266;
}

/* å†…å®¹åŒº */
.drawer-content {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.group-section {
  margin-bottom: 24px;
}

.group-title {
  font-size: 14px;
  color: #909399;
  margin: 0 0 12px 0;
  font-weight: 600;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  font-size: 14px;
  color: #606266;
}

/* âœ¨ Keycap é£æ ¼æ ¸å¿ƒä»£ç  */
.keys {
  display: flex;
  gap: 4px;
}

.keycap {
  display: inline-block;
  padding: 2px 8px;
  font-size: 12px;
  font-family: 'SF Mono', 'Roboto Mono', Monaco, monospace;
  color: #303133;
  background: #fdfdfd; /* ç¨å¾®ç™½ä¸€ç‚¹ */
  border: 1px solid #dcdfe6;
  border-bottom-width: 3px; /* åº•éƒ¨åŠ åšæ¨¡æ‹Ÿç«‹ä½“æ„Ÿ */
  border-radius: 6px;
  min-width: 20px;
  text-align: center;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/* åŠ¨ç”» */
.fade-enter-active, .fade-leave-active {
  transition: opacity 0.3s ease;
}
.fade-enter-from, .fade-leave-to {
  opacity: 0;
}

.slide-enter-active, .slide-leave-active {
  transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
}
.slide-enter-from, .slide-leave-to {
  transform: translateX(100%);
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustFilters.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m19 2 2 2-2 2-2-2Z"/><path d="m13 2 2 2-2 2-2-2Z"/><path d="m6 6 2 2-2 2-2-2Z"/>
          <path d="m3 21 9-9"/><path d="M12.22 7.28a3 3 0 0 0-4.24 0L3.5 11.76a3 3 0 0 0 0 4.24l4.48 4.48a3 3 0 0 0 4.24 0l4.48-4.48a3 3 0 0 0 0-4.24Z"/>
        </svg>
        <span>æ»¤é•œæ•ˆæœ</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6"/>
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content filter-panel">
      <div v-for="cat in categories" :key="cat.name" class="filter-category">
        <div class="cat-title">{{ cat.name }}</div>
        <div class="filter-grid">
          <div 
            v-for="item in cat.list" 
            :key="item.key" 
            class="filter-item"
            :class="{ active: currentFilter === item.key }"
            @click="selectFilter(item.key)"
          >
            <div class="thumb-container">
              <img v-if="thumbnailMap[item.key]" :src="thumbnailMap[item.key]" class="filter-thumb">
              <div v-else class="thumb-placeholder loading"></div>
            </div>
            <span class="filter-label">{{ item.label }}</span>
          </div>
        </div>
      </div>

      <div class="intensity-box" v-if="currentFilter !== 'original'">
        <div class="label-row">
          <span>å¼ºåº¦ï¼š{{ intensity }}</span>
        </div>
        <input type="range" v-model.number="intensity" min="0" max="100" class="ie-slider" @input="updateIntensity">
      </div>

      <div class="action-buttons">
        <button class="ie-btn ie-primary full" @click="handleConfirm">ç¡®å®š</button>
        <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, inject, onMounted, watch } from 'vue';
import { 
    registerFilterModule, applyFilterPreset, loadThumbnailsTask, 
    backupCurrentFilters, commitFilterChange, cancelFilterChange 
} from './useCanvasFilters';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const currentFilter = ref('original');
const intensity = ref(100);
const thumbnailMap = reactive({});

const categories = [
  { name: 'åŸºç¡€', list: [{key:'original', label:'åŸå›¾'}, {key:'natural', label:'è‡ªç„¶'}, {key:'bright', label:'é²œäº®'}, {key:'whitening', label:'å‡€ç™½'}] },
  { name: 'å¤å¤', list: [{key:'v8090', label:'8090'}, {key:'modern', label:'æ‘©ç™»'}, {key:'cool_space', label:'çƒˆç©º'}] },
  { name: 'é£æ™¯', list: [{key:'snow', label:'åˆé›ª'}, {key:'sunset', label:'å¦ä¸'}, {key:'hot_sun', label:'çƒˆæ—¥'}] },
  { name: 'ç”µå½±', list: [{key:'smoke', label:'å°˜çƒŸ'}, {key:'spring', label:'æ˜¥é£'}, {key:'lalaland', label:'çˆ±ä¹ä¹‹åŸ'}] },
];

const selectFilter = (key) => {
  currentFilter.value = key;
  applyFilterPreset(key, intensity.value);
};

const updateIntensity = () => applyFilterPreset(currentFilter.value, intensity.value);

const handleConfirm = () => {
    commitFilterChange();
    emit('toggle');
};

const handleCancel = () => {
    cancelFilterChange();
    emit('toggle');
};

const refreshThumbnails = () => {
    loadThumbnailsTask((map) => Object.assign(thumbnailMap, map));
};

// æ ¸å¿ƒä¼˜åŒ–ï¼šä»…åœ¨é¢æ¿å±•å¼€æ—¶ç›‘å¬ï¼Œå¹¶æ‰§è¡Œå¤‡ä»½
watch(() => props.isExpanded, (expanded) => {
    const canvas = canvasAPI?.canvas?.value;
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    
    if (expanded && bgImage) {
        // âœ… 1. å±•å¼€ç¬é—´ï¼Œæ ¹æ®å›¾ç‰‡ä¸Šå­˜å‚¨çš„å…ƒæ•°æ®åŒæ­¥ UI é«˜äº®å’Œå¼ºåº¦
        currentFilter.value = bgImage._lastFilterKey || 'original';
        intensity.value = bgImage._lastFilterIntensity ?? 100;

        // 2. æ‰§è¡Œå¤‡ä»½é€»è¾‘ (ç”¨äºå–æ¶ˆå›æ»š)
        backupCurrentFilters(); 
        
        // 3. åŠ è½½ç¼©ç•¥å›¾åŠæ³¨å†Œç›‘å¬
        refreshThumbnails();
        canvas.on('image:updated', refreshThumbnails);
    } else if (!expanded && canvas) {
        canvas.off('image:updated', refreshThumbnails);
    }
});

onMounted(() => {
    if (canvasAPI?.canvas) registerFilterModule(canvasAPI.canvas, canvasAPI.saveHistory);
});
</script>

<style scoped>
/* æ ·å¼ä¿ç•™åŸæœ‰çš„ç½‘æ ¼å¸ƒå±€å’Œä¸»é¢˜è‰²å®šä¹‰ */
.filter-panel { padding: 12px; max-height: 520px; overflow-y: auto; }
.cat-title { font-size: 13px; font-weight: bold; margin: 12px 0 8px; color: #333; }
.filter-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
.filter-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; }
.thumb-container { width: 70px; height: 70px; border-radius: 4px; overflow: hidden; border: 2px solid transparent; transition: 0.2s; background: #eee; }
.filter-thumb { width: 100%; height: 100%; object-fit: cover; }
.thumb-placeholder.loading { width: 100%; height: 100%; background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: loading-skeleton 1.5s infinite; }
@keyframes loading-skeleton { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
.filter-item.active .thumb-container { border-color: var(--ie-primary-color); }
.filter-label { font-size: 11px; margin-top: 6px; color: #666; }
.intensity-box { margin-top: 20px; padding: 12px 0; border-top: 1px solid #f0f0f0; }
.label-row { display: flex; justify-content: space-between; font-size: 12px; color: #606266; margin-bottom: 8px; }
.action-buttons { display: flex; gap: 10px; margin-top: 16px; }
.full { flex: 1; }
</style>
</file>

<file path="src/components/modules/adjust/AdjustRuler.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.4 2.4 0 0 1 0-3.4l2.6-2.6a2.4 2.4 0 0 1 3.4 0l12.6 12.6z"></path>
          <path d="m5 6 1.7 1.7"></path>
          <path d="m17 18 1.7 1.7"></path>
          <path d="m11 12 1.7 1.7"></path>
        </svg>
        <span>æµ‹é‡æ ‡å°º</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">
      
      <div class="action-row">
        <button 
          class="ie-btn ie-primary" 
          :class="{ 'active': isDrawing }"
          @click="toggleDrawMode"
        >
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:4px">
            <line x1="5" y1="12" x2="19" y2="12"></line>
            <polyline points="12 5 19 12 12 19"></polyline>
          </svg>
          {{ isDrawing ? 'ç»˜åˆ¶ä¸­ (Escé€€å‡º)' : 'æ–°å»ºæ ‡å°º' }}
        </button>
      </div>

      <div class="divider"></div>

      <div class="control-group">
        <div class="label-row">
          <span>æ ‡æ³¨æ•°å€¼</span>
        </div>
        <div class="input-group">
          <input 
            type="number" 
            v-model.number="rulerConfig.value" 
            class="ie-input-number" 
            style="flex:1; width:auto;"
            @input="updateActiveRuler"
          >
          <select v-model="rulerConfig.unit" class="ie-select" @change="updateActiveRuler">
            <option value="px">px</option>
            <option value="cm">cm</option>
            <option value="mm">mm</option>
            <option value="m">m</option>
            <option value="in">inch</option>
            <option value="ft">foot</option>
          </select>
        </div>
      </div>

      <div class="control-group">
        <div class="label-row">
          <span>çº¿æ¡é¢œè‰²</span>
          <input type="color" v-model="rulerConfig.color" @input="updateActiveRuler">
        </div>
        
        <div class="label-row">
          <span>é€æ˜åº¦</span>
          <span class="val">{{ rulerConfig.opacity }}%</span>
        </div>
        <input 
          type="range" 
          v-model.number="rulerConfig.opacity" 
          min="10" max="100" 
          class="ie-slider" 
          @input="updateActiveRuler"
        >
      </div>

      <div class="control-group">
        <div class="label-row">
          <span>çº¿æ¡ç²—ç»†</span>
          <span class="val">{{ rulerConfig.strokeWidth }}px</span>
        </div>
        <input 
          type="range" 
          v-model.number="rulerConfig.strokeWidth" 
          min="1" max="10" 
          class="ie-slider" 
          @input="updateActiveRuler"
        >
      </div>

      <div class="control-group">
        <div class="label-row">
          <span>å­—ä½“å¤§å°</span>
          <input 
            type="number" 
            v-model.number="rulerConfig.fontSize" 
            class="ie-input-number"
            @input="updateActiveRuler"
          >
        </div>
        <div class="label-row" style="margin-top:8px">
          <span>æ–‡å­—èƒŒæ™¯</span>
          <input type="checkbox" v-model="rulerConfig.showBg" @change="updateActiveRuler">
        </div>
      </div>

    </div>
  </div>
</template>

<script setup>
import { defineProps, defineEmits, inject, onMounted } from 'vue';
import { 
  registerRulerModule, 
  rulerConfig, 
  isDrawing, 
  startDrawMode, 
  stopDrawMode,
  updateActiveRuler 
} from './useCanvasRuler';

const props = defineProps({
  isExpanded: Boolean
});

const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI'); // ä¾èµ–æ³¨å…¥è·å– Canvas

const toggleDrawMode = () => {
  if (isDrawing.value) {
    stopDrawMode();
  } else {
    startDrawMode();
  }
};

onMounted(() => {
  if (canvasAPI && canvasAPI.canvas) {
    registerRulerModule(canvasAPI.canvas, canvasAPI.saveHistory);
  } else {
    console.warn('CanvasAPI not found in AdjustRuler');
  }
});
</script>

<style scoped>
.tool-content { padding: 16px; }

.action-row {
  display: flex;
  justify-content: center;
  margin-bottom: 16px;
}

.divider {
  height: 1px;
  background: #ebeef5;
  margin: 16px 0;
}

.control-group {
  margin-bottom: 16px;
}

.label-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12px;
  color: #606266;
  margin-bottom: 8px;
}

.input-group {
  display: flex;
  gap: 8px;
}

.ie-select {
  height: 28px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  font-size: 12px;
  color: #606266;
  padding: 0 4px;
  outline: none;
  background: white;
}

.ie-btn.active {
  background-color: #ecf5ff;
  color: var(--ie-primary-color);
  border-color: var(--ie-primary-color);
}

.val { font-family: monospace; }
</style>
</file>

<file path="src/components/modules/adjust/useCanvasFilters.js">
// src/components/modules/adjust/useCanvasFilters.js
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let thumbnailTimer = null;
let backupFilters = [];
let backupKey = 'original'; // ç”¨äºå¤‡ä»½æ»¤é•œ Key
let backupIntensity = 100;   // ç”¨äºå¤‡ä»½å¼ºåº¦


export const registerFilterModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};

// æ»¤é•œçŸ©é˜µé…ç½®ï¼ˆæ¨¡æ‹Ÿåº—å°ç§˜çš„å››å¤§åˆ†ç±»ï¼‰
export const filterDefinitions = {
    // åŸºç¡€ç±»
    natural: [1, 0, 0, 0, 0,  0, 1.05, 0, 0, 0,  0, 0, 1.02, 0, 0,  0, 0, 0, 1, 0], // è‡ªç„¶
    bright: [1.1, 0, 0, 0, 0,  0, 1.1, 0, 0, 0,  0, 0, 1.1, 0, 0,  0, 0, 0, 1, 0],   // é²œäº®
    whitening: [1.05, 0, 0, 0, 0.05,  0, 1.05, 0, 0, 0.05,  0, 0, 1.05, 0, 0.05,  0, 0, 0, 1, 0], // å‡€ç™½

    // å¤å¤ç±»
    v8090: [0.35, 0.25, 0.25, 0, 0,  0.25, 0.35, 0.25, 0, 0,  0.25, 0.25, 0.35, 0, 0,  0, 0, 0, 1, 0], // 8090
    modern: [0.393, 0.769, 0.189, 0, 0,  0.349, 0.686, 0.168, 0, 0,  0.272, 0.534, 0.131, 0, 0,  0, 0, 0, 1, 0], // æ‘©ç™»
    cool_space: [1, 0, 0, 0.1, -0.1,  0, 1, 0, 0.1, -0.1,  0, 0, 1.2, 0.2, -0.1,  0, 0, 0, 1, 0], // çƒˆç©º

    // é£æ™¯ç±»
    snow: [1, 0, 0, 0, 0.1,  0, 1, 0, 0, 0.1,  0, 0, 1.1, 0, 0.15,  0, 0, 0, 1, 0], // åˆé›ª
    sunset: [1.2, 0, 0, 0, 0,  0, 1, 0, 0, 0,  0, 0, 0.8, 0, 0,  0, 0, 0, 1, 0],     // å¦ä¸
    hot_sun: [1.1, 0, 0, 0.1, 0,  0, 1, 0, 0.1, 0,  0, 0, 0.9, 0, 0,  0, 0, 0, 1, 0], // çƒˆæ—¥

    // ç”µå½±ç±»
    smoke: [0.8, 0.1, 0.1, 0, 0,  0.1, 0.8, 0.1, 0, 0,  0.1, 0.1, 0.8, 0, 0,  0, 0, 0, 1, 0], // å°˜çƒŸ
    spring: [0.9, 0, 0, 0, 0,  0, 1.1, 0, 0, 0,  0, 0, 0.9, 0, 0,  0, 0, 0, 1, 0], // æ˜¥é£
    lalaland: [1, 0, 0, 0, 0,  0, 0.9, 0, 0, 0,  0, 0, 1.2, 0, 0,  0, 0, 0, 1, 0], // çˆ±ä¹ä¹‹åŸ
};

// å¤‡ä»½å½“å‰æ»¤é•œçŠ¶æ€
export const backupCurrentFilters = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        // æ·±æ‹·è´æ»¤é•œæ•°ç»„
        backupFilters = [...bgImage.filters];
        backupKey = bgImage._lastFilterKey || 'original';
        backupIntensity = bgImage._lastFilterIntensity ?? 100;
    }
};

/**
 * åº”ç”¨æ»¤é•œé¢„è®¾
 * @param {string} filterKey æ»¤é•œé…ç½®é”®å
 * @param {number} intensity å¼ºåº¦ (0-100)
 */
export const applyFilterPreset = (filterKey, intensity = 100) => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (!bgImage) return;

    // è®°å½•å½“å‰é€‰ä¸­çš„æ»¤é•œä¿¡æ¯åˆ°å¯¹è±¡ä¸Šï¼Œä»¥ä¾¿é‡æ–°æ‰“å¼€é¢æ¿æ—¶åŒæ­¥ UI
    bgImage._lastFilterKey = filterKey;
    bgImage._lastFilterIntensity = intensity;

    bgImage.filters = bgImage.filters.filter(f => !f._isArtFilter);

    if (filterKey !== 'original') {
        const matrix = filterDefinitions[filterKey];
        if (matrix) {
            const filter = new fabric.Image.filters.ColorMatrix({
                matrix: matrix,
                alpha: intensity / 100
            });
            filter._isArtFilter = true;
            bgImage.filters.push(filter);
        }
    }

    bgImage.applyFilters();
    canvas.requestRenderAll();
};

// ç¡®å®šï¼šä¿å­˜å†å²è®°å½•å¹¶æ¸…ç†å¤‡ä»½
export const commitFilterChange = () => {
    if (saveHistoryFn) saveHistoryFn();
    backupFilters = [];
};

/**
 * å–æ¶ˆä¿®æ”¹ï¼šæ ¸å¿ƒé€»è¾‘å›å½’ â€”â€” æ¢å¤åˆ°å¤‡ä»½çŠ¶æ€
 */
export const cancelFilterChange = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        bgImage.filters = [...backupFilters];
        // âœ… è¿˜åŸå…ƒæ•°æ®
        bgImage._lastFilterKey = backupKey;
        bgImage._lastFilterIntensity = backupIntensity;
        
        bgImage.applyFilters();
        canvas.requestRenderAll();
    }
    backupFilters = [];
};

/**
 * ç”Ÿæˆæ‰€æœ‰æ»¤é•œçš„é¢„è§ˆç¼©ç•¥å›¾
 * @returns {Promise<Object>} è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œé”®æ˜¯æ»¤é•œkeyï¼Œå€¼æ˜¯Base64å›¾ç‰‡æ•°æ®
 */
export const generateFilterThumbnails = () => {
  return new Promise((resolve, reject) => {
    const canvas = unref(canvasRef);
    if (!canvas) {
      reject("Canvas not initialized");
      return;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) {
      resolve({}); // æ²¡æœ‰å›¾ç‰‡æ—¶è¿”å›ç©º
      return;
    }

    const originalSrc = bgImage.getSrc();
    const thumbSize = 80; // ç¼©ç•¥å›¾å¤§å°ï¼Œè¶Šå°ç”Ÿæˆè¶Šå¿«

    // 1. åˆ›å»ºä¸€ä¸ªåå°å°å‹ç¦»å±ç”»å¸ƒ
    const tempCanvas = new fabric.StaticCanvas(null, {
      width: thumbSize,
      height: thumbSize,
      backgroundColor: 'transparent'
    });

    // 2. åŠ è½½åŸå›¾
    fabric.Image.fromURL(originalSrc, (thumbImg) => {
        // 3. å°†å›¾ç‰‡ç¼©æ”¾å¹¶å±…ä¸­å¡«æ»¡å°ç”»å¸ƒ
        const scale = Math.max(thumbSize / thumbImg.width, thumbSize / thumbImg.height);
        thumbImg.set({
            originX: 'center',
            originY: 'center',
            left: thumbSize / 2,
            top: thumbSize / 2,
            scaleX: scale,
            scaleY: scale
        });
        tempCanvas.add(thumbImg);

        const resultMap = {};

        // 4. å®šä¹‰ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥ç”Ÿæˆå•ä¸ªæ»¤é•œå›¾
        const renderOne = (matrix) => {
            thumbImg.filters = []; // æ¸…ç©ºæ—§æ»¤é•œ
            if (matrix) {
                const filter = new fabric.Image.filters.ColorMatrix({ matrix: matrix });
                thumbImg.filters.push(filter);
            }
            thumbImg.applyFilters();
            tempCanvas.renderAll();
            // ä½¿ç”¨è¾ƒä½è´¨é‡å¯¼å‡ºï¼Œæé«˜é€Ÿåº¦
            return tempCanvas.toDataURL({ format: 'jpeg', quality: 0.7 });
        };

        // 5. ç”Ÿæˆã€åŸå›¾ã€‘ç¼©ç•¥å›¾
        resultMap['original'] = renderOne(null);

        // 6. å¾ªç¯ç”Ÿæˆæ‰€æœ‰ã€æ»¤é•œã€‘ç¼©ç•¥å›¾
        for (const key in filterDefinitions) {
            resultMap[key] = renderOne(filterDefinitions[key]);
        }
        
        // æ¸…ç†å†…å­˜
        tempCanvas.dispose();
        resolve(resultMap);
    }, { crossOrigin: 'anonymous' }); // ç¡®ä¿è·¨åŸŸåŠ è½½
  });
};

/**
 * ä¼˜åŒ–çš„ç¼©ç•¥å›¾åŠ è½½é€»è¾‘ï¼ˆå¸¦å†…éƒ¨é˜²æŠ–ï¼‰
 * @param {Function} callback - æˆåŠŸç”Ÿæˆåçš„å›è°ƒ
 */
export const loadThumbnailsTask = (callback) => {
    if (thumbnailTimer) clearTimeout(thumbnailTimer);

    // è®¾ç½® 200ms é˜²æŠ–ï¼Œé˜²æ­¢é¢æ¿å¿«é€Ÿåˆ‡æ¢æˆ–å›¾ç‰‡è¿ç»­å˜æ¢æ—¶çš„è®¡ç®—æµªè´¹
    thumbnailTimer = setTimeout(async () => {
        try {
            const map = await generateFilterThumbnails(); // è°ƒç”¨ä¹‹å‰å®šä¹‰çš„ç”Ÿæˆå‡½æ•°
            if (callback) callback(map);
        } catch (e) {
            console.error("ç”Ÿæˆç¼©ç•¥å›¾å¤±è´¥:", e);
        }
    }, 200);
};
</file>

<file path="src/components/modules/adjust/useCanvasMosaic.js">
// [æ–‡ä»¶: src/components/modules/adjust/useCanvasMosaic.js]
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;

// å†…éƒ¨çŠ¶æ€ï¼šä¿æŒæŒä¹…åŒ–ï¼Œç›´åˆ°ç‚¹å‡»åº”ç”¨æˆ–å–æ¶ˆ
let mosaicPreviewLayer = null;
let maskGroup = null;

export const registerMosaicModule = (canvas, saveHistory) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
};

/**
 * æ ¸å¿ƒï¼šå¼€å¯æˆ–æ›´æ–°é©¬èµ›å…‹äº¤äº’ [éµå¾ªå…¨æ™¯æŠ¥å‘Šï¼šçŠ¶æ€ä¿æŠ¤]
 */
export const startMosaicInteraction = (mode, intensity = 15) => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  // 1. å¦‚æœé¢„è§ˆå±‚å·²å­˜åœ¨ï¼Œä»…æ›´æ–°æ»¤é•œå¼ºåº¦ï¼Œä¸é‡ç½®çŠ¶æ€
  if (mosaicPreviewLayer) {
    const filter = new fabric.Image.filters.Pixelate({ blocksize: intensity });
    mosaicPreviewLayer.filters = [filter];
    mosaicPreviewLayer.applyFilters();
    
    // åˆ‡æ¢æ¨¡å¼é€»è¾‘
    canvas.isDrawingMode = (mode === 'path');
    if (!canvas.isDrawingMode) addMosaicShape(mode);
    
    canvas.requestRenderAll();
    return;
  }

  // 2. é¦–æ¬¡åˆå§‹åŒ–ï¼šåˆ›å»ºé¢„è§ˆå±‚
  bgImage.clone((cloned) => {
    mosaicPreviewLayer = cloned;
    
    const pixelateFilter = new fabric.Image.filters.Pixelate({ blocksize: intensity });
    mosaicPreviewLayer.filters = [pixelateFilter];
    mosaicPreviewLayer.applyFilters();

    // åˆå§‹åŒ–è·¯å¾„é®ç½©ç»„
    maskGroup = new fabric.Group([], { absolutePositioned: true });

    mosaicPreviewLayer.set({
      selectable: false,
      evented: false,
      clipPath: maskGroup, // åˆå§‹å…³è”
      name: 'mosaic-preview-layer'
    });

    canvas.add(mosaicPreviewLayer);
    canvas.bringToFront(mosaicPreviewLayer);

    // è®¾ç½®äº¤äº’
    canvas.isDrawingMode = (mode === 'path');
    if (mode === 'path') {
      const brush = new fabric.PencilBrush(canvas);
      brush.width = 30;
      brush.color = 'rgba(0,0,0,1)'; // é®ç½©è‰²
      canvas.freeDrawingBrush = brush;
      canvas.on('path:created', onPathCreated);
    } else {
      addMosaicShape(mode);
    }
    
    canvas.requestRenderAll();
  });
};

const onPathCreated = (opt) => {
  const canvas = unref(canvasRef);
  if (maskGroup && mosaicPreviewLayer) {
    canvas.remove(opt.path);
    maskGroup.addWithUpdate(opt.path);
    canvas.requestRenderAll();
  }
};

/**
 * æ·»åŠ å¯äº¤äº’çš„å½¢çŠ¶æ¡† [ä¿®å¤äº¤äº’å¤±æ•ˆçš„å…³é”®]
 */
const addMosaicShape = (type) => {
  const canvas = unref(canvasRef);
  const center = canvas.getCenter();
  
  // æ£€æŸ¥æ˜¯å¦å·²æœ‰å½¢çŠ¶ï¼Œé¿å…é‡å¤ç”Ÿæˆ
  const existing = canvas.getObjects().find(o => o.name === 'mosaic-shape');
  if (existing) {
    canvas.setActiveObject(existing);
    return;
  }

  const commonTpl = {
    left: center.left, top: center.top,
    fill: 'rgba(64, 158, 255, 0.2)', // åŠé€æ˜è“è‰²ï¼Œè¡¨ç¤ºé€‰åŒº
    stroke: '#409eff', strokeWidth: 2,
    originX: 'center', originY: 'center',
    cornerColor: '#fff', cornerStrokeColor: '#409eff',
    transparentCorners: false,
    name: 'mosaic-shape',
    absolutePositioned: true
  };

  const shape = type === 'rect' 
    ? new fabric.Rect({ ...commonTpl, width: 150, height: 150 })
    : new fabric.Circle({ ...commonTpl, radius: 75 });

  canvas.add(shape);
  canvas.setActiveObject(shape);

  // âœ… å…³é”®ï¼šå½¢çŠ¶å˜åŠ¨æ—¶ï¼Œå¼ºåˆ¶é©¬èµ›å…‹é¢„è§ˆå±‚åˆ·æ–°æ¸²æŸ“
  const updateClip = () => canvas.requestRenderAll();
  shape.on('moving', updateClip);
  shape.on('scaling', updateClip);

  // ä¿®æ”¹é¢„è§ˆå±‚çš„ clipPathï¼Œä½¿å…¶åŒ…å«è·¯å¾„ç»„å’Œå½“å‰äº¤äº’å½¢çŠ¶
  mosaicPreviewLayer.clipPath = new fabric.Group([maskGroup, shape], { 
    absolutePositioned: true 
  });
  
  canvas.requestRenderAll();
};

/**
 * åº”ç”¨é©¬èµ›å…‹ï¼šç¦»å±é«˜æ¸…é‡åˆ¶ [éµå¾ªå…¨æ™¯æŠ¥å‘Šï¼šé«˜æ¸…å‡†åˆ™]
 */
export const applyMosaic = (intensity) => {
  return new Promise((resolve) => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (!bgImage) return resolve();

    // 1. æ•è·è§†è§‰å¿«ç…§ (Viewport Compensation)
    const prevVpt = [...canvas.viewportTransform];
    const prevZoom = canvas.getZoom();
    const imgCenter = bgImage.getCenterPoint();
    const rectCenterScreen = {
      x: imgCenter.x * prevVpt[0] + prevVpt[4],
      y: imgCenter.y * prevVpt[3] + prevVpt[5]
    };

    // 2. æ”¶é›†æ‰€æœ‰ä½œä¸ºé®ç½©çš„å¯¹è±¡
    const shapes = canvas.getObjects().filter(o => o.name === 'mosaic-shape');
    const allMaskObjects = [...maskGroup.getObjects(), ...shapes];
    if (allMaskObjects.length === 0) return resolve();

    const originalSrc = bgImage.getSrc();
    fabric.Image.fromURL(originalSrc, (highResImg) => {
      const { width, height } = highResImg;
      const tempCanvas = new fabric.StaticCanvas(null, { width, height });
      const scale = width / bgImage.getScaledWidth();

      const mosaicLayer = fabric.util.object.clone(highResImg);
      mosaicLayer.filters = [new fabric.Image.filters.Pixelate({ blocksize: intensity })];
      mosaicLayer.applyFilters();

      // åæ ‡æ¢ç®—
      const finalMaskObjects = allMaskObjects.map(obj => {
        const cloned = fabric.util.object.clone(obj);
        const localLeft = (obj.left - (bgImage.left - bgImage.getScaledWidth() / 2)) * scale;
        const localTop = (obj.top - (bgImage.top - bgImage.getScaledHeight() / 2)) * scale;
        cloned.set({
          left: localLeft, top: localTop,
          scaleX: obj.scaleX * scale, scaleY: obj.scaleY * scale,
          absolutePositioned: true
        });
        return cloned;
      });

      mosaicLayer.clipPath = new fabric.Group(finalMaskObjects, { absolutePositioned: true });

      tempCanvas.add(highResImg); 
      tempCanvas.add(mosaicLayer);
      tempCanvas.renderAll();

      const dataURL = tempCanvas.toDataURL({ format: 'png', quality: 1 });
      tempCanvas.dispose();

      // 3. åº”ç”¨å¹¶è¡¥å¿è§†å£
      bgImage.setSrc(dataURL, () => {
        const newZoom = prevZoom / scale;
        bgImage.set({
          scaleX: 1, scaleY: 1, angle: 0,
          originX: 'center', originY: 'center',
          left: canvas.width / 2, top: canvas.height / 2
        });
        bgImage.setCoords();
        canvas.centerObject(bgImage);

        stopMosaicInteraction();

        const newCenterLogic = { x: canvas.width / 2, y: canvas.height / 2 };
        const newPanX = rectCenterScreen.x - newCenterLogic.x * newZoom;
        const newPanY = rectCenterScreen.y - newCenterLogic.y * newZoom;
        canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);

        if (saveHistoryFn) saveHistoryFn();
        canvas.requestRenderAll();
        canvas.fire('zoom:change');
        resolve();
      });
    }, { crossOrigin: 'anonymous' });
  });
};

export const stopMosaicInteraction = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;
  canvas.off('path:created', onPathCreated);
  canvas.isDrawingMode = false;
  
  if (mosaicPreviewLayer) canvas.remove(mosaicPreviewLayer);
  const shapes = canvas.getObjects().filter(o => o.name === 'mosaic-shape');
  if (shapes.length > 0) canvas.remove(...shapes);

  mosaicPreviewLayer = null;
  maskGroup = null;
  canvas.requestRenderAll();
};

export const cancelMosaic = () => {
  stopMosaicInteraction();
};
</file>

<file path="src/components/modules/adjust/useCanvasRuler.js">
import { ref, unref, watch, nextTick } from 'vue';
import { fabric } from 'fabric';

// === æ¨¡å—çº§å•ä¾‹çŠ¶æ€ ===
let canvasRef = null;
let saveHistoryFn = null;

// å“åº”å¼çŠ¶æ€ (ä¾› UI åŒå‘ç»‘å®š)
const isDrawing = ref(false);
const rulerConfig = ref({
    value: 20,
    unit: 'cm',
    color: '#ff0000',
    opacity: 100,
    fontSize: 24,
    fontFamily: 'Arial',
    strokeWidth: 4,
    showBg: true,
    capStyle: 'line'
});

// === 1. æ³¨å†Œä¸åˆå§‹åŒ– ===
export const registerRulerModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;

    const c = unref(canvas);
    if (c) {
        // ç»‘å®šé€‰æ‹©äº‹ä»¶ï¼Œå®ç°â€œç‚¹å‡»æ ‡å°ºå›æ˜¾å±æ€§â€
        c.on('selection:created', onSelectionChanged);
        c.on('selection:updated', onSelectionChanged);
        c.on('selection:cleared', onSelectionCleared);
    }
};

// === 2. äº‹ä»¶ç›‘å¬é€»è¾‘ ===
const onSelectionChanged = (e) => {
    const activeObj = e.selected?.[0];
    if (activeObj && activeObj.isRuler) {
        // å›æ˜¾å±æ€§åˆ°é¢æ¿
        const items = activeObj.getObjects();
        rulerConfig.value.value = activeObj._rulerValue ?? 20;
        rulerConfig.value.unit = activeObj._rulerUnit ?? 'cm';
        rulerConfig.value.opacity = (activeObj.opacity || 1) * 100;
        
        // çº¿æ¡æ ·å¼å›æ˜¾ (å– Line å¯¹è±¡)
        if (items[0]) {
            rulerConfig.value.color = items[0].stroke;
            rulerConfig.value.strokeWidth = items[0].strokeWidth;
        }
        // æ–‡å­—æ ·å¼å›æ˜¾ (å– Text å¯¹è±¡)
        if (items[3]) {
            rulerConfig.value.fontSize = items[3].fontSize;
            rulerConfig.value.fontFamily = items[3].fontFamily;
            rulerConfig.value.showBg = !!items[3].backgroundColor;
        }
    }
};

const onSelectionCleared = () => {
    // å¯é€‰ï¼šæ¸…ç©ºæˆ–ä¿æŒæœ€åä¸€æ¬¡é…ç½®
    // rulerConfig.value.value = 20; 
};

// === 3. ç»˜åˆ¶äº¤äº’æµç¨‹ ===
let startPoint = null;
let activeLine = null;

export const startDrawMode = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;
    
    isDrawing.value = true;
    
    // é”å®šæ‰€æœ‰å¯¹è±¡ï¼Œé˜²æ­¢è¯¯è§¦
    canvas.discardActiveObject();
    canvas.selection = false;
    canvas.defaultCursor = 'crosshair';
    canvas.hoverCursor = 'crosshair';
    
    // ä¸´æ—¶é”å®šå…¶ä»–å¯¹è±¡
    canvas.getObjects().forEach(obj => {
        obj._prevSelectable = obj.selectable;
        obj.selectable = false;
    });

    canvas.on('mouse:down', onMouseDown);
};

export const stopDrawMode = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    isDrawing.value = false;
    
    canvas.selection = true;
    canvas.defaultCursor = 'default';
    canvas.hoverCursor = 'move';
    
    // æ¢å¤å¯¹è±¡å¯é€‰ä¸­
    canvas.getObjects().forEach(obj => {
        if (obj._prevSelectable !== undefined) {
            obj.selectable = obj._prevSelectable;
            delete obj._prevSelectable;
        }
    });

    canvas.off('mouse:down', onMouseDown);
    canvas.off('mouse:move', onMouseMove);
    canvas.off('mouse:up', onMouseUp);
};

const onMouseDown = (opt) => {
    const canvas = unref(canvasRef);
    const pointer = canvas.getPointer(opt.e);
    startPoint = { x: pointer.x, y: pointer.y };
    
    activeLine = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], {
        stroke: rulerConfig.value.color,
        strokeWidth: rulerConfig.value.strokeWidth,
        strokeDashArray: [5, 5],
        selectable: false,
        evented: false
    });
    
    canvas.add(activeLine);
    canvas.on('mouse:move', onMouseMove);
    canvas.on('mouse:up', onMouseUp);
};

const onMouseMove = (opt) => {
    if (!activeLine) return;
    const canvas = unref(canvasRef);
    const pointer = canvas.getPointer(opt.e);
    activeLine.set({ x2: pointer.x, y2: pointer.y });
    canvas.requestRenderAll();
};

const onMouseUp = () => {
    const canvas = unref(canvasRef);
    canvas.off('mouse:move', onMouseMove);
    canvas.off('mouse:up', onMouseUp);

    if (!activeLine) return;

    const endPoint = { x: activeLine.x2, y: activeLine.y2 };
    canvas.remove(activeLine);
    activeLine = null;

    // é˜²æ­¢è¯¯è§¦ç‚¹å‡»
    const dist = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));
    if (dist > 10) {
        createRulerObject(startPoint, endPoint);
    }
    
    // ç»˜åˆ¶ä¸€æ¬¡åè‡ªåŠ¨é€€å‡º
    stopDrawMode();
};

// === 4. åˆ›å»ºæ ‡å°ºå¯¹è±¡ (Group) ===
const createRulerObject = (start, end) => {
    const canvas = unref(canvasRef);
    const cfg = rulerConfig.value;
    const color = cfg.color;
    
    // 1. ä¸»çº¿æ¡
    const line = new fabric.Line([start.x, start.y, end.x, end.y], {
        stroke: color,
        strokeWidth: cfg.strokeWidth,
        originX: 'center', originY: 'center'
    });

    // 2. è®¡ç®—å‡ ä½•
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
    const midX = (start.x + end.x) / 2;
    const midY = (start.y + end.y) / 2;

    // 3. ç«¯ç‚¹ (Cap)
    const capSize = 10 + cfg.strokeWidth;
    const startCap = new fabric.Line([0, -capSize, 0, capSize], {
        stroke: color, strokeWidth: cfg.strokeWidth,
        left: start.x, top: start.y,
        angle: angle,
        originX: 'center', originY: 'center'
    });
    const endCap = new fabric.Line([0, -capSize, 0, capSize], {
        stroke: color, strokeWidth: cfg.strokeWidth,
        left: end.x, top: end.y,
        angle: angle,
        originX: 'center', originY: 'center'
    });

    // 4. æ–‡å­—
    const textStr = `${cfg.value} ${cfg.unit}`;
    const textObj = new fabric.Text(textStr, {
        fontSize: cfg.fontSize,
        fontFamily: cfg.fontFamily,
        fill: color,
        backgroundColor: cfg.showBg ? 'rgba(255,255,255,0.8)' : '',
        originX: 'center', originY: 'bottom',
        left: midX,
        top: midY - 10,
        angle: angle > 90 || angle < -90 ? angle + 180 : angle
    });

    // 5. ç»„åˆ Group
    const group = new fabric.Group([line, startCap, endCap, textObj], {
        left: midX, top: midY,
        originX: 'center', originY: 'center',
        opacity: cfg.opacity / 100,
        id: 'ruler-group',
        isRuler: true, // å…³é”®æ ‡è¯†
        _rulerValue: cfg.value, // æŒä¹…åŒ–æ•°æ®
        _rulerUnit: cfg.unit,
        lockScalingY: true, 
        lockUniScaling: true 
    });

    group.setControlsVisibility({
        mt: false, mb: false, ml: true, mr: true, 
        bl: false, br: false, tl: false, tr: false,
        mtr: true 
    });

    canvas.add(group);
    canvas.setActiveObject(group);
    if (saveHistoryFn) saveHistoryFn();
};

// === 5. æ›´æ–°é€‰ä¸­æ ‡å°º ===
export const updateActiveRuler = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const obj = canvas.getActiveObject();
    if (!obj || !obj.isRuler) return;

    const cfg = rulerConfig.value;
    const items = obj.getObjects();
    
    // æ›´æ–°å†…éƒ¨å­å¯¹è±¡
    [0, 1, 2].forEach(i => {
        if (items[i]) items[i].set({ stroke: cfg.color, strokeWidth: cfg.strokeWidth });
    });
    
    if (items[3]) { // Text
        items[3].set({ 
            text: `${cfg.value} ${cfg.unit}`,
            fill: cfg.color,
            fontSize: cfg.fontSize,
            fontFamily: cfg.fontFamily,
            backgroundColor: cfg.showBg ? 'rgba(255,255,255,0.8)' : ''
        });
    }

    obj.set({ opacity: cfg.opacity / 100 });
    obj._rulerValue = cfg.value;
    obj._rulerUnit = cfg.unit;

    canvas.requestRenderAll();
    if (saveHistoryFn) saveHistoryFn();
};

// å¯¼å‡º Vue å“åº”å¼æ•°æ®
export { rulerConfig, isDrawing };
</file>

<file path="src/components/modules/ai/AiExpand.vue">

</file>

<file path="src/components/modules/ai/AiGenerate.vue">

</file>

<file path="src/components/modules/ai/index.vue">
<!-- aiå·¥å…· -->
  <template>
    aiå·¥å…·
  </template>
</file>

<file path="src/components/modules/border/index.vue">
<!-- è¾¹æ¡† -->
  <template>
    è¾¹æ¡†
  </template>
</file>

<file path="src/components/modules/draw/DrawBrush.vue">
<!-- ç”»ç¬”è®¾ç½® -->
 <template>
    ç”»ç¬”è®¾ç½®
 </template>
</file>

<file path="src/components/modules/draw/DrawShape.vue">
<!-- å‡ ä½•å½¢çŠ¶ -->
  <template>
    å‡ ä½•å½¢çŠ¶
  </template>
</file>

<file path="src/components/modules/draw/index.vue">
<!-- ç»˜åˆ¶ -->
 <template>
    ç»˜åˆ¶
 </template>
</file>

<file path="src/components/modules/material/index.vue">
<!-- ç´ æ -->
  <template>
    ç´ æ
  </template>
</file>

<file path="src/components/modules/text/index.vue">
<!-- æ–‡æœ¬ -->
  <template>
    æ–‡æœ¬
  </template>
</file>

<file path="src/components/modules/text/TextAdd.vue">

</file>

<file path="src/components/modules/text/TextStyle.vue">
<!-- æ–‡æœ¬æ ·å¼ -->
  <template>
    æ–‡æœ¬æ ·å¼
  </template>
</file>

<file path="src/components/modules/watermark/index.vue">
<!-- æ°´å° -->
  <template>
    æ°´å°
  </template>
</file>

<file path="src/composables/useConstraint.js">
import { fabric } from 'fabric';

/**
 * è·å–å¯¹è±¡åœ¨ç”»å¸ƒä¸Šçš„é€»è¾‘çŸ©å½¢ï¼ˆæ¶ˆé™¤ç¼©æ”¾å’Œè§†å£åç§»çš„å½±å“ï¼‰
 * @param {fabric.Object} obj 
 * @param {fabric.Canvas} canvas 
 */
export const getLogicRect = (obj, canvas) => {
    if (!obj || !canvas) return { left: 0, top: 0, width: 0, height: 0 };

    const zoom = canvas.getZoom();
    const vpt = canvas.viewportTransform;

    // getBoundingRect è¿”å›çš„æ˜¯å±å¹•åæ ‡ï¼ˆå— zoom å’Œ viewport å½±å“ï¼‰
    const rawRect = obj.getBoundingRect();

    return {
        left: (rawRect.left - vpt[4]) / zoom,
        top: (rawRect.top - vpt[5]) / zoom,
        width: rawRect.width / zoom,
        height: rawRect.height / zoom
    };
};

/**
 * æ ¸å¿ƒç®—æ³•ï¼šè®¡ç®—â€œå¯¹è±¡â€ç›¸å¯¹äºâ€œå®¹å™¨â€çš„è¶Šç•Œä¿®æ­£å€¼
 * è¿”å›å…·ä½“çš„ deltaX å’Œ deltaYï¼Œä¸ç›´æ¥ä¿®æ”¹å¯¹è±¡
 */
export const calculateConstraintOffset = (targetRect, containerRect) => {
    let deltaX = 0;
    let deltaY = 0;

    // 1. å·¦è¾¹ç•Œæ£€æµ‹
    if (targetRect.left > containerRect.left) {
        deltaX = containerRect.left - targetRect.left;
    }

    // 2. ä¸Šè¾¹ç•Œæ£€æµ‹
    if (targetRect.top > containerRect.top) {
        deltaY = containerRect.top - targetRect.top;
    }

    // 3. å³è¾¹ç•Œæ£€æµ‹
    const targetRight = targetRect.left + targetRect.width;
    const containerRight = containerRect.left + containerRect.width;

    // å¦‚æœå½“å‰å·²ç»åœ¨å³è¾¹ç•Œå†…ï¼Œå°±ä¸éœ€è¦ä¿®æ­£ï¼ˆé™¤éå·¦è¾¹ä¿®æ­£å¯¼è‡´çš„è¿é”ååº”ï¼Œä½†è¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
    // é€»è¾‘ï¼šåªæœ‰å½“å³è¾¹â€œå‡ºç•Œâ€äº†ï¼ˆtargetRight < containerRight æ˜¯æŒ‡å›¾ç‰‡æ²¡å¡«æ»¡å³è¾¹ï¼‰
    // æ³¨æ„ï¼šè¿™é‡Œçš„è¯­ä¹‰æ˜¯â€œå›¾ç‰‡å¿…é¡»è¦†ç›–å®¹å™¨â€ï¼Œæ‰€ä»¥å›¾ç‰‡å³è¾¹å¿…é¡» >= å®¹å™¨å³è¾¹
    if (targetRight < containerRight) {
        // ä¼˜å…ˆä¿è¯å·¦å¯¹é½ï¼Œå¦‚æœå·¦è¾¹æ²¡é—®é¢˜ï¼Œæ‰ä¿®æ­£å³è¾¹
        if (deltaX === 0) {
            deltaX = containerRight - targetRight;
        }
    }

    // 4. ä¸‹è¾¹ç•Œæ£€æµ‹
    const targetBottom = targetRect.top + targetRect.height;
    const containerBottom = containerRect.top + containerRect.height;

    if (targetBottom < containerBottom) {
        if (deltaY === 0) {
            deltaY = containerBottom - targetBottom;
        }
    }

    return { deltaX, deltaY };
};

/**
 * åŠ¨ä½œï¼šç¬é—´ä¿®æ­£å¯¹è±¡ä½ç½®ï¼ˆé€šå¸¸ç”¨äº Resize è¿‡ç¨‹ä¸­ï¼Œæˆ–è€… mouse:up ä¸éœ€è¦åŠ¨ç”»æ—¶ï¼‰
 */
export const constrainObjectToRect = (obj, containerRect, canvas) => {
    if (!obj || !containerRect || !canvas) return false;

    const objRect = getLogicRect(obj, canvas);
    const boxRect = containerRect.type ? getLogicRect(containerRect, canvas) : containerRect;

    const { deltaX, deltaY } = calculateConstraintOffset(objRect, boxRect);

    if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
        obj.left += deltaX;
        obj.top += deltaY;
        obj.setCoords(); // é‡è¦ï¼šæ›´æ–°ç‚¹å‡»åŒºåŸŸ
        return true; // å‘ç”Ÿäº†ä¿®æ­£
    }
    return false; // æ— éœ€ä¿®æ­£
};

/**
 * åŠ¨ä½œï¼šå¸¦åŠ¨ç”»çš„å¹³æ»‘å›å¼¹ï¼ˆå®Œå–„ç‰ˆï¼‰
 * é€‚ç”¨åœºæ™¯ï¼šæ‹¼å›¾æ‹–æ‹½æ¾æ‰‹ã€å›¾ç‰‡ç§»åŠ¨æ¾æ‰‹
 */
export const animateRebound = (obj, containerRect, canvas) => {
    if (!obj || !containerRect || !canvas) return;

    // 1. è®¡ç®—éœ€è¦çš„ä¿®æ­£å€¼
    const objRect = getLogicRect(obj, canvas);
    const boxRect = containerRect.type ? getLogicRect(containerRect, canvas) : containerRect;

    const { deltaX, deltaY } = calculateConstraintOffset(objRect, boxRect);

    // 2. å¦‚æœåç§»é‡å¾ˆå°ï¼Œå¿½ç•¥
    if (Math.abs(deltaX) < 0.5 && Math.abs(deltaY) < 0.5) return;

    // 3. è®¡ç®—ç›®æ ‡åæ ‡
    const targetLeft = obj.left + deltaX;
    const targetTop = obj.top + deltaY;

    // 4. æ‰§è¡Œ Fabric åŠ¨ç”»
    obj.animate({
        left: targetLeft,
        top: targetTop
    }, {
        duration: 300, // åŠ¨ç”»æ—¶é•¿ 300ms
        onChange: canvas.requestRenderAll.bind(canvas), // æ¯ä¸€å¸§éƒ½é‡ç»˜
        onComplete: () => {
            obj.setCoords(); // åŠ¨ç”»ç»“æŸå¿…é¡»æ›´æ–°åæ ‡ï¼Œå¦åˆ™ç‚¹å‡»åŒºåŸŸä¼šé”™ä½
            canvas.requestRenderAll();
        },
        // ä½¿ç”¨æŒ‡æ•°ç¼“åŠ¨ï¼Œç‰©ç†æ„Ÿæ›´å¼º (easeOutExpo)
        easing: fabric.util.ease.easeOutExpo
    });
};
</file>

<file path="src/composables/useKeyboardShortcuts.js">
import { onMounted, onUnmounted } from 'vue';

export function useKeyboardShortcuts(actions) {
  
  const handleKeydown = (e) => {
    // 1. ğŸ›¡ï¸ é¿å¼€è¾“å…¥æ¡†ï¼šå¦‚æœç”¨æˆ·æ­£åœ¨æ‰“å­—ï¼Œä¸è§¦å‘å¿«æ·é”®
    const activeTag = document.activeElement.tagName.toUpperCase();
    if (activeTag === 'INPUT' || activeTag === 'TEXTAREA') {
      return;
    }

    const isCmd = e.ctrlKey || e.metaKey; // Windowsç”¨Ctrl, Macç”¨Command
    const isShift = e.shiftKey;
    const key = e.key.toLowerCase(); // ç»Ÿä¸€è½¬å°å†™åˆ¤æ–­

    // === ç»„åˆé”® (Cmd/Ctrl + ...) ===
    if (isCmd) {
      switch (key) {
        // --- åŸºç¡€ç¼–è¾‘ ---
        case 'c': 
          e.preventDefault(); 
          actions.copyActive();
          break;
          
        case 'v': 
          e.preventDefault();
          actions.pasteActive(); // è‡ªåŠ¨è§¦å‘"é”®ç›˜åç§»ç²˜è´´"
          break;
        
        case 'x': // å‰ªåˆ‡
          e.preventDefault();
          actions.cutActive();
          break;

        case 'z': // æ’¤é”€ & é‡åš
          e.preventDefault();
          if (isShift) {
            actions.redo && actions.redo(); // æ”¯æŒ Ctrl+Shift+Z é‡åš
          } else {
            actions.undo && actions.undo();
          }
          break;
          
        case 'y': // é‡åš (Windows ä¹ æƒ¯)
          e.preventDefault();
          actions.redo && actions.redo();
          break;

        case 'a': // å…¨é€‰ (é¢„ç•™)
          e.preventDefault();
          // actions.selectAll();
          break;

        case 's': // ä¿å­˜ (æ‹¦æˆªæµè§ˆå™¨ä¿å­˜)
          e.preventDefault();
          // actions.saveCanvas(); 
          break;
          
        // --- é”å®š (Ctrl + Shift + L) ---
        case 'l': 
          if (isShift) {
            e.preventDefault(); // é˜²æ­¢æµè§ˆå™¨è·³åˆ°åœ°å€æ 
            actions.toggleLock();
          }
          break;
      }
    } 
    
    // === å•é”®æˆ– Shift ç»„åˆé”® (ä¸æŒ‰ Ctrl) ===
    else {
      switch (e.key) { // è¿™é‡ŒåŒºåˆ†å¤§å°å†™æˆ–è€…ç”¨ key code æ›´å‡†ç¡®ï¼Œè¿™é‡Œç›´æ¥ç”¨å­—ç¬¦
        // --- åˆ é™¤ ---
        case 'Delete':
        case 'Backspace':
          actions.deleteActive();
          break;

        // --- å›¾å±‚å±‚çº§ (å…³é”®) ---
        case '[': // å·¦ä¸­æ‹¬å·
          if (isShift) {
             actions.moveLayer('back'); // Shift + [ = ç½®åº•
          } else {
             actions.moveLayer('backward'); // [ = ä¸‹ç§»ä¸€å±‚
          }
          break;

        case ']': // å³ä¸­æ‹¬å·
          if (isShift) {
             actions.moveLayer('front'); // Shift + ] = ç½®é¡¶
          } else {
             actions.moveLayer('forward'); // ] = ä¸Šç§»ä¸€å±‚
          }
          break;
      }
    }
  };

  onMounted(() => {
    window.addEventListener('keydown', handleKeydown);
  });

  onUnmounted(() => {
    window.removeEventListener('keydown', handleKeydown);
  });
}
</file>

<file path="src/composables/useObjectActions.js">
import { inject, unref, reactive, readonly } from 'vue';
import { toast } from '@/utils/toast'; 

// 1. å®šä¹‰å…¨å±€å‰ªè´´æ¿çŠ¶æ€ (æ”¾åœ¨å‡½æ•°å¤–ï¼Œä¿è¯è·¨ç»„ä»¶å…±äº«)
const clipboardState = reactive({
    hasContent: false, 
    data: null         
});

export function useObjectActions() {
    const canvasAPI = inject('canvasAPI');
    
    const getContext = () => {
        const canvas = unref(canvasAPI?.canvas);
        const activeObj = canvas?.getActiveObject();
        return { canvas, activeObj };
    };

    // === 1. åˆ é™¤ ===
    const deleteActive = () => {
        const { canvas, activeObj } = getContext();
        if (!canvas || !activeObj) return;
        
        if (activeObj.type === 'activeSelection') {
            activeObj.forEachObject(obj => canvas.remove(obj));
            canvas.discardActiveObject();
        } else {
            canvas.remove(activeObj);
        }
        canvas.requestRenderAll();
        canvasAPI.saveHistory && canvasAPI.saveHistory();
    };

    // === 2. å¤åˆ¶ ===
    const copyActive = () => {
        const { activeObj } = getContext();
        if (!activeObj) return;
        
        activeObj.clone((cloned) => {
            // å­˜å…¥å…¨å±€çŠ¶æ€
            clipboardState.data = cloned;
            clipboardState.hasContent = true; 
            toast.success('å·²å¤åˆ¶');
        });
    };

    // === 3. å‰ªåˆ‡ ===
    const cutActive = () => {
        const { canvas, activeObj } = getContext();
        if (!activeObj) return;
        
        activeObj.clone((cloned) => {
            clipboardState.data = cloned;
            clipboardState.hasContent = true;
            
            // å¤åˆ¶ååˆ é™¤åŸå¯¹è±¡
            if (activeObj.type === 'activeSelection') {
                activeObj.forEachObject(obj => canvas.remove(obj));
                canvas.discardActiveObject();
            } else {
                canvas.remove(activeObj);
            }
            canvas.requestRenderAll();
            canvasAPI.saveHistory && canvasAPI.saveHistory();
            toast.success('å·²å‰ªåˆ‡');
        });
    };

    // === 4. ç²˜è´´ (æ ¸å¿ƒä¿®æ”¹é€»è¾‘) ===
    const pasteActive = (point = null) => {
        // ä»å…¨å±€çŠ¶æ€è¯»å–
        if (!clipboardState.data) {
            return;
        }

        const { canvas } = getContext();
        if (!canvas) return;

        clipboardState.data.clone((clonedObj) => {
            canvas.discardActiveObject();

            clonedObj.set({
                evented: true,
            });

            if (point) {
                // æƒ…å†µ A: å³é”®å®šç‚¹ç²˜è´´
                clonedObj.set({
                    left: point.x,
                    top: point.y,
                    originX: 'left',
                    originY: 'top',
                });
            } else {
                // æƒ…å†µ B: é”®ç›˜å¿«æ·é”®ç²˜è´´ (è‡ªåŠ¨åç§»)
                clonedObj.set({
                    left: clonedObj.left + 20,
                    top: clonedObj.top + 20,
                    originX: 'left',
                    originY: 'top',
                });
            }

            if (clonedObj.type === 'activeSelection') {
                clonedObj.canvas = canvas;
                clonedObj.forEachObject((obj) => {
                    canvas.add(obj);
                });
                clonedObj.setCoords();
            } else {
                canvas.add(clonedObj);
            }
            
            canvas.setActiveObject(clonedObj);
            canvas.requestRenderAll();
            canvasAPI.saveHistory && canvasAPI.saveHistory();
            
            // æ›´æ–°å‰ªè´´æ¿å¼•ç”¨ï¼Œæ”¯æŒè¿ç»­ç²˜è´´
            clipboardState.data = clonedObj; 
        });
    };

    // === 5. é”å®š/è§£é” ===
    const toggleLock = () => {
        const { canvas, activeObj } = getContext();
        if (!activeObj) return;

        const isLocked = !activeObj.lockMovementX;
        
        activeObj.set({
            lockMovementX: isLocked,
            lockMovementY: isLocked,
            lockRotation: isLocked,
            lockScalingX: isLocked,
            lockScalingY: isLocked
        });

        if (isLocked) {
             activeObj.selectable = true; 
             toast.success('å¯¹è±¡å·²é”å®š');
        } else {
             toast.success('å¯¹è±¡å·²è§£é”');
        }
        
        canvas.requestRenderAll();
        canvasAPI.saveHistory && canvasAPI.saveHistory();
        return isLocked;
    };

    // === 6. å›¾å±‚è°ƒæ•´ (ä¿ç•™æ‰€æœ‰é€»è¾‘) ===
    const moveLayer = (direction) => {
        const { canvas, activeObj } = getContext();
        if (!activeObj) return;

        const objects = canvas.getObjects();
        // æŸ¥æ‰¾ä¸»å›¾ä½ç½®ï¼Œç¡®ä¿ä¸è¦†ç›–ä¸»å›¾
        const mainImgIndex = objects.findIndex(o => o.isMainImage);
        const floorIndex = mainImgIndex >= 0 ? mainImgIndex + 1 : 0;
        const currentIndex = objects.indexOf(activeObj);

        switch (direction) {
            case 'front': 
                activeObj.bringToFront(); 
                break;
            case 'back': 
                if (currentIndex > floorIndex) activeObj.moveTo(floorIndex);
                break;
            case 'forward': 
                activeObj.bringForward(); 
                break;
            case 'backward': 
                if (currentIndex > floorIndex) {
                    activeObj.sendBackwards();
                    // é˜²æ­¢è¢«é€åˆ°åº•å›¾ä¸‹é¢
                    const newIndex = canvas.getObjects().indexOf(activeObj);
                    if (newIndex <= mainImgIndex && mainImgIndex !== -1) {
                         activeObj.moveTo(floorIndex);
                    }
                }
                break;
        }
        canvas.requestRenderAll();
        canvasAPI.saveHistory && canvasAPI.saveHistory();
    };

    return {
        clipboardState: readonly(clipboardState),
        deleteActive,
        copyActive,
        cutActive,
        pasteActive,
        toggleLock,
        moveLayer
    };
}
</file>

<file path="src/composables/useOffscreenHelper.js">
import { fabric } from 'fabric';

/**
 * é€šç”¨ï¼šé«˜ä¿çœŸç¦»å±æ¸²æŸ“å™¨
 * @param {fabric.Image} originalImageObj ç”»å¸ƒä¸Šçš„æºå›¾ç‰‡å¯¹è±¡ï¼ˆç”¨äºè·å–åŸå›¾ URL å’Œå½“å‰çŠ¶æ€ï¼‰
 * @param {Number} targetWidth ç›®æ ‡å¯¼å‡ºå®½åº¦
 * @param {Number} targetHeight ç›®æ ‡å¯¼å‡ºé«˜åº¦
 * @param {Function} transformCallback å›è°ƒå‡½æ•°ï¼Œè®©ä½ åœ¨ç¦»å± canvas ä¸Šè°ƒæ•´å›¾ç‰‡å‚æ•°
 * @returns {Promise<string>} è¿”å›ç”Ÿæˆçš„ Base64
 */
export const renderHighResSnapshot = (originalImageObj, targetWidth, targetHeight, transformCallback) => {
    return new Promise((resolve) => {
        const originalSrc = originalImageObj.getSrc();

        // 1. åˆ›å»ºç¦»å±ç”»å¸ƒ
        const tempCanvas = new fabric.StaticCanvas(null, {
            width: targetWidth,
            height: targetHeight,
            backgroundColor: 'transparent'
        });

        // 2. åŠ è½½åŸå›¾ï¼ˆé¿å…ä½¿ç”¨ç¼“å­˜çš„ç¼©ç•¥å›¾ï¼‰
        fabric.Image.fromURL(originalSrc, (highResImg) => {

            // 3. æ‰§è¡Œè°ƒç”¨è€…çš„è‡ªå®šä¹‰å˜æ¢é€»è¾‘
            if (transformCallback) {
                transformCallback(highResImg, tempCanvas);
            } else {
                // é»˜è®¤è¡Œä¸ºï¼šå±…ä¸­å¡«æ»¡
                highResImg.set({
                    originX: 'center', originY: 'center',
                    left: targetWidth / 2, top: targetHeight / 2
                });
                // ç®€å•çš„ Cover é€»è¾‘...
            }

            tempCanvas.add(highResImg);
            tempCanvas.renderAll();

            // 4. å¯¼å‡º
            const dataURL = tempCanvas.toDataURL({ format: 'png', quality: 1 });

            // 5. æ¸…ç†å†…å­˜
            tempCanvas.dispose();

            resolve(dataURL);
        }, { crossOrigin: 'anonymous' });
    });
};
</file>

<file path="src/config/shortcuts.js">
// src/config/shortcuts.js

export const SHORTCUT_GROUPS = [
  {
    title: 'åŸºç¡€ç¼–è¾‘ (Editing)',
    items: [
      { label: 'å¤åˆ¶', keys: ['Ctrl', 'C'] },
      { label: 'ç²˜è´´', keys: ['Ctrl', 'V'] },
      { label: 'å‰ªåˆ‡', keys: ['Ctrl', 'X'] },
      { label: 'æ’¤é”€', keys: ['Ctrl', 'Z'] },
      { label: 'é‡åš', keys: ['Ctrl', 'Y'] },
      { label: 'åˆ é™¤', keys: ['Delete'] },
    ]
  },
  {
    title: 'å›¾å±‚ç®¡ç† (Layers)',
    items: [
      { label: 'ä¸Šç§»ä¸€å±‚', keys: [']'] },
      { label: 'ä¸‹ç§»ä¸€å±‚', keys: ['['] },
      { label: 'ç½®é¡¶', keys: ['Shift', ']'] },
      { label: 'ç½®åº•', keys: ['Shift', '['] },
      { label: 'é”å®š/è§£é”', keys: ['Ctrl', 'Shift', 'L'] },
    ]
  },
  {
    title: 'ç”»å¸ƒè§†å›¾ (View)',
    items: [
      { label: 'æ”¾å¤§', keys: ['Ctrl', '+'] }, // å‡è®¾ä½ æœªæ¥ä¼šåŠ è¿™ä¸ª
      { label: 'ç¼©å°', keys: ['Ctrl', '-'] },
      { label: 'é‡ç½®ç¼©æ”¾', keys: ['Ctrl', '0'] },
      { label: 'å¹³ç§»ç”»å¸ƒ', keys: ['Space', 'Drag'] },
    ]
  }
];
</file>

<file path="src/index.js">
import EditorLayout from './components/layout/EditorLayout.vue';
import './style.css'; // ç¡®ä¿æ ·å¼è¢«å¼•å…¥

// å¯¼å‡ºä¸»ç»„ä»¶
export { EditorLayout };
// é»˜è®¤å¯¼å‡º
export default EditorLayout;
</file>

<file path=".spec/project-charter.md">
# Project Charter: Image Editor SDK (å¤§ç§˜ç¾å›¾)

> **Version**: 3.5.0 (Final)
> **Last Updated**: 2025-12
> **Context**: High-performance Web Image Processing SDK

## 1. é¡¹ç›®æ„¿æ™¯ (Vision)

æ„å»ºä¸€ä¸ª**æ¨¡å—åŒ–ã€é«˜æ€§èƒ½**çš„ Web ç«¯å›¾åƒå¤„ç† SDKã€‚æ ¸å¿ƒæ¶æ„é‡‡ç”¨â€œè½»é‡çº§æ ¸å¿ƒ (Core) + åŠŸèƒ½æ’ä»¶åŒ– (Modules)â€çš„è®¾è®¡æ¨¡å¼ï¼Œæ”¯æŒä»åŸºç¡€çš„è£å‰ªæ—‹è½¬åˆ°å¤æ‚çš„ AI æ¶ˆé™¤ã€æ‹¼å›¾å’Œæ»¤é•œå¤„ç†ï¼Œç¡®ä¿åœ¨ç§»åŠ¨ç«¯å’Œæ¡Œé¢ç«¯å‡æœ‰æµç•…çš„ Canvas äº¤äº’ä½“éªŒã€‚

## 2. æŠ€æœ¯æ ˆä¸ç‰ˆæœ¬çº¦æŸ (Tech Stack)

> âš ï¸ **å…³é”®çº¦æŸ**ï¼šæ‰€æœ‰è‡ªåŠ¨ç”Ÿæˆçš„ä»£ç å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹ç‰ˆæœ¬ç‰¹æ€§ï¼Œä¸¥ç¦æ··ç”¨ä¸åŒç‰ˆæœ¬çš„ APIã€‚

- **Core Framework**: Vue 3.3+ (Composition API, `<script setup>`)
- **Graphics Engine**: **Fabric.js v5.3.0**
  - âŒ **ä¸¥ç¦**: ä½¿ç”¨ Fabric v6 çš„ `Canvas` ç±»åï¼ˆv6 å˜æ›´ä¸º `Canvas`ï¼Œv5 æ˜¯ `fabric.Canvas`ï¼‰æˆ– v6 çš„ Promise-based æ¸²æŸ“æ–¹æ³•ã€‚
  - âœ… **å¿…é¡»**: ä½¿ç”¨ `new fabric.Canvas()`, `new fabric.Image.fromURL()` ç­‰ v5 é£æ ¼ APIã€‚
- **Build Tool**: Vite 7.x
- **State Management**: **Custom Reactive Singleton**
  - æœ¬é¡¹ç›®**æœªä½¿ç”¨** Pinia/Vuexã€‚
  - å…¨å±€çŠ¶æ€å¿…é¡»é€šè¿‡ `src/composables/useEditorState.js` ç®¡ç†ã€‚
- **Styling**: Standard CSS (BEM å‘½åè§„èŒƒ) + Scoped CSSã€‚

## 3. æ¶æ„è®¾è®¡è§„èŒƒ (Architecture)

### 3.1 ç›®å½•ä¸æ¨¡å—åŒ–æ ‡å‡† (The "Module Pattern")

é¡¹ç›®é‡‡ç”¨**åŠŸèƒ½å‚ç›´åˆ†å±‚**ç»“æ„ï¼Œæ‰€æœ‰ç‹¬ç«‹ä¸šåŠ¡åŠŸèƒ½ï¼ˆFeatureï¼‰å¿…é¡»éµå¾ªæ­¤ç›®å½•èŒƒå¼ï¼š

- **UI ç»„ä»¶**: `src/components/modules/{featureName}/index.vue` (è´Ÿè´£ UI äº¤äº’ï¼Œå¦‚æ»‘å—ã€æŒ‰é’®)ã€‚
- **é€»è¾‘ Hook**: `src/components/modules/{featureName}/useCanvas{FeatureName}.js` (è´Ÿè´£ Fabric.js å¯¹è±¡æ“ä½œ)ã€‚
- **æ³¨å†Œæœºåˆ¶**: å¿…é¡»åœ¨ `useCanvas.js` æˆ–ä¸»ç»„ä»¶ä¸­æ˜¾å¼æŒ‚è½½é€»è¾‘ï¼Œä¿æŒæ ¸å¿ƒ `useCanvas` çš„çº¯å‡€ã€‚

### 3.2 çŠ¶æ€ç®¡ç†ä¸é€šä¿¡ (State & Events)

- **å…¨å±€çŠ¶æ€**: ä»…é€šè¿‡ `useEditorState.js` ç®¡ç†å·¥å…·æ¿€æ´» (`activeTool`) å’Œå†å²çŠ¶æ€ (`canUndo/Redo`)ã€‚
- **å±€éƒ¨çŠ¶æ€**: å…·ä½“çš„å‚æ•°ï¼ˆå¦‚æ»¤é•œå¼ºåº¦ã€ç”»ç¬”é¢œè‰²ï¼‰åº”ä¿ç•™åœ¨å„è‡ªçš„ `useCanvas{Feature}.js` é—­åŒ…æˆ– Vue ç»„ä»¶å†…éƒ¨ã€‚
- **äº‹ä»¶æ€»çº¿**: ä½¿ç”¨ Fabric è‡ªå¸¦çš„äº‹ä»¶ç³»ç»Ÿè¿›è¡Œè§£è€¦é€šä¿¡ï¼š
  - **è§¦å‘**: `canvas.value.fire('image:updated')` (ç”¨äºé€šçŸ¥æ»¤é•œé‡æ–°è®¡ç®—é¢„è§ˆç­‰)ã€‚
  - **ç›‘å¬**: `canvas.on('image:updated', callback)`ã€‚

### 3.3 ç”»å¸ƒç”Ÿå‘½å‘¨æœŸä¸æ€§èƒ½ (Performance)

- **å“åº”å¼é™·é˜± (Critical)**:
  - âœ… **å¿…é¡»**: åˆå§‹åŒ– Canvas æ—¶ä½¿ç”¨ `markRaw(new fabric.Canvas(...))`ã€‚
  - âŒ **ä¸¥ç¦**: å°† Fabric å¯¹è±¡æ”¾å…¥ `ref()` æˆ– `reactive()` çš„æ·±å±‚ä»£ç†ä¸­ã€‚Fabric å¯¹è±¡æå…¶å¤æ‚ï¼ŒVue çš„æ·±åº¦ä»£ç†ä¼šå¯¼è‡´ä¸¥é‡çš„æ€§èƒ½å¡é¡¿ç”šè‡³æµè§ˆå™¨å´©æºƒã€‚
- **æ¸²æŸ“å¾ªç¯**: æ‰¹é‡ä¿®æ”¹å¯¹è±¡å±æ€§åï¼Œå¿…é¡»è°ƒç”¨ `canvas.requestRenderAll()` è€Œé `renderAll()`ï¼Œä»¥åˆ©ç”¨å¸§è¿™ä¸€çº§çš„èŠ‚æµä¼˜åŒ–ã€‚

## 4. é€šç”¨èµ„æºä¸å¤ç”¨è§„èŒƒ (Shared Resources & Utilities)

> ğŸ¯ **åŸåˆ™**: DRY (Don't Repeat Yourself)ã€‚**ä»»ä½•åŠŸèƒ½å¦‚æœä¸ä¾èµ– `this`ã€Vue å®ä¾‹æˆ–ç‰¹å®šçš„ Canvas å¯¹è±¡ï¼Œå®ƒå°±æ˜¯ä¸€ä¸ªå·¥å…·å‡½æ•°ï¼Œå¿…é¡»è¢«æå–ã€‚**

### 4.1 çº¯å·¥å…·å‡½æ•° (Pure Utils)

- **ä½ç½®**: `src/utils/`
- **å®šä¹‰**: çº¯ JavaScript å‡½æ•°ï¼Œ**æ— çŠ¶æ€**ï¼Œä¸ä¾èµ– Vue ç»„ä»¶å®ä¾‹ã€‚
- **å¼ºåˆ¶æ‰§è¡Œ**:
  - âŒ **ä¸¥ç¦**: åœ¨ Vue ç»„ä»¶æˆ– Composable ä¸­ç›´æ¥ç¼–å†™å¤æ‚çš„è¾…åŠ©ç®—æ³•å‡½æ•°ï¼ˆå¦‚ HEX è½¬ RGBã€è·ç¦»è®¡ç®—ï¼‰ã€‚
  - âœ… **å¿…é¡»**: å°†å…¶å°è£…åˆ° `src/utils/` ä¸‹çš„å¯¹åº”æ–‡ä»¶ï¼ˆå¦‚ `math.js`, `file.js`, `color.js`ï¼‰ï¼Œå¹¶å¯¼å‡ºä½¿ç”¨ã€‚
  - **ç°æœ‰èµ„æº**: æ¶ˆæ¯æç¤ºå¿…é¡»è°ƒç”¨ `src/utils/toast.js`ã€‚

### 4.2 é€šç”¨ UI ç»„ä»¶ (Common Components)

- **ä½ç½®**: `src/components/common/`
- **å®šä¹‰**: è·¨æ¨¡å—å¤ç”¨çš„â€œå“‘ç»„ä»¶â€ (Dumb Components)ï¼Œå¦‚å¼¹çª— (Modal)ã€åŠ è½½ Spinnerã€é€šç”¨æ»‘å—ã€‚
- **çº¦æŸ**: é€šç”¨ç»„ä»¶ä¸åº”åŒ…å«å…·ä½“çš„ Canvas ä¸šåŠ¡é€»è¾‘ï¼Œåªé€šè¿‡ `props` å’Œ `emits` é€šä¿¡ã€‚

### 4.3 æ ¸å¿ƒé€»è¾‘å¤ç”¨ (Core Composables)

- **ä½ç½®**: `src/composables/`
- **å®šä¹‰**: æ¶‰åŠ Canvas æ ¸å¿ƒæ“ä½œæˆ–å…¨å±€ç¼–è¾‘å™¨çŠ¶æ€çš„æœ‰çŠ¶æ€é€»è¾‘ã€‚
- **ç°æœ‰èµ„æº**:
  - `useConstraint.js`: æ‹–æ‹½é™åˆ¶é€»è¾‘ã€‚
  - `useOffscreenHelper.js`: ç¦»å±æ¸²æŸ“é€»è¾‘ã€‚
  - **è§„åˆ™**: å‡¡æ˜¯æ¶‰åŠå¤šä¸ªæ¨¡å—å…±äº«çš„**ä¸šåŠ¡é€»è¾‘**ï¼ˆå¦‚â€œæ°´å°ç”Ÿæˆâ€ã€â€œç¦»å±å¯¼å‡ºâ€ï¼‰ï¼Œå¿…é¡»æå‡è‡³æ­¤ç›®å½•ï¼Œç¦æ­¢åœ¨æ¨¡å—é—´å¤åˆ¶ä»£ç ã€‚

## 5. æ ¸å¿ƒåŠŸèƒ½å®æ–½æ ‡å‡† (Implementation Standards)

### 5.1 åæ ‡ç³»ä¸ç¼©æ”¾ (Coordinates)

- **é€»è¾‘åæ ‡**: æ‰€æœ‰çš„ä¸šåŠ¡é€»è¾‘ï¼ˆå¦‚è£å‰ªæ¡†ä½ç½®ã€æ‹¼å›¾ç½‘æ ¼ï¼‰å¿…é¡»åŸºäº**åŸå§‹å›¾ç‰‡å°ºå¯¸**è®¡ç®—ã€‚
- **è§†å›¾åæ ‡**: ä»…åœ¨è§†å£å˜æ¢ï¼ˆZoom/Panï¼‰æ—¶ä½¿ç”¨ `setViewportTransform`ã€‚
- **Zoom é™åˆ¶**: é”å®šåœ¨ `0.1` ~ `50` ä¹‹é—´ï¼Œä¸”å¿…é¡»ä¿ç•™ `ZOOM_PADDING = 0.921` çš„å®‰å…¨è¾¹è·ã€‚

### 5.2 å†å²è®°å½• (History Stack)

- **å¿«ç…§ç­–ç•¥**: åŸºäº `canvas.toJSON(['id', 'selectable', 'name'])`ã€‚
- **æ’é™¤å¯¹è±¡**: è¾…åŠ©çº¿ã€å¹½çµèŠ‚ç‚¹ã€è£å‰ªæ¡†ï¼ˆtype: 'rect' / 'crop-zone'ï¼‰**ä¸åº”**è¢«è®¡å…¥å†å²è®°å½•å †æ ˆã€‚
- **è§¦å‘æ—¶æœº**: å¿…é¡»åœ¨ `object:modified` (ç”¨æˆ·æ“ä½œç»“æŸ) æ—¶ä¿å­˜ï¼Œä¸¥ç¦åœ¨ `object:moving` (æ‹–æ‹½ä¸­) é¢‘ç¹ä¿å­˜ã€‚

### 5.3 AI ä¸å¼‚æ­¥ä»»åŠ¡ (Async & AI)

- **API ä½ç½®**: æ‰€æœ‰åç«¯äº¤äº’å°è£…åœ¨ `src/api/` ç›®å½• (å¦‚ `src/api/ai.js`)ã€‚
- **Loading çŠ¶æ€**: è°ƒç”¨ AI æ¥å£ï¼ˆå¦‚æŠ å›¾ã€å»å™ªï¼‰æœŸé—´ï¼Œå¿…é¡»é€šè¿‡ `useEditorState` çš„ `setLoading(true)` å±•ç¤ºé®ç½©ï¼Œå¹¶ä¸´æ—¶ç¦ç”¨ Canvas äº¤äº’ï¼Œé˜²æ­¢ç”¨æˆ·åœ¨å¤„ç†æœŸé—´è¿›è¡Œç”»å¸ƒæ“ä½œã€‚

## 6. UI/UX è®¾è®¡è§„èŒƒ (Design System)

> ğŸ¯ **åŸåˆ™**: æ–°å¢æ¨¡å—çš„ UI å¿…é¡»ä¸ç°æœ‰æ¨¡å—ï¼ˆå¦‚æ»¤é•œã€è£å‰ªï¼‰ä¿æŒè§†è§‰ç»Ÿä¸€ã€‚**ä¸¥ç¦ç¡¬ç¼–ç é¢œè‰²å€¼ã€‚**

### 6.1 è‰²å½©ç³»ç»Ÿ (Color Palette)

æ‰€æœ‰ç»„ä»¶å¿…é¡»ä½¿ç”¨ `src/style.css` ä¸­å®šä¹‰çš„ CSS å˜é‡ï¼š

- **ä¸»è‰²è°ƒ**: `var(--primary-color)` (é€šå¸¸ä¸ºè“è‰² #007bff)
- **èƒŒæ™¯è‰²**:
  - é¢æ¿èƒŒæ™¯: `var(--panel-bg, #ffffff)`
  - é¡µé¢èƒŒæ™¯: `var(--app-bg, #1e1e1e)`
- **æ–‡æœ¬è‰²**:
  - æ ‡é¢˜: `var(--text-main, #333333)`
  - æ¬¡è¦/æ ‡ç­¾: `var(--text-sub, #666666)`
- **è¾¹æ¡†**: `var(--border-color, #e0e0e0)`

### 6.2 é€šç”¨ç»„ä»¶æ ·å¼ (Standard UI Classes)

æ‰€æœ‰åŠŸèƒ½é¢æ¿ (`.vue`) å¿…é¡»å¤ç”¨ä»¥ä¸‹æ ‡å‡†ç±»åï¼Œä¿æŒå¸ƒå±€ä¸€è‡´ï¼š

| ç»„ä»¶éƒ¨åˆ† | æ ‡å‡†ç±»å | æ ·å¼ç‰¹å¾ |
| :--- | :--- | :--- |
| **é¢æ¿å®¹å™¨** | `.tool-panel-content` | ç»Ÿä¸€çš„ Padding (16px) |
| **æ¨¡å—æ ‡é¢˜** | `.panel-title` | 14px, 600 weight, åº•éƒ¨ Margin |
| **æ§åˆ¶ç»„** | `.control-group` | åŒ…å«æ ‡ç­¾å’Œæ§ä»¶çš„å®¹å™¨ï¼Œåº•éƒ¨ Margin (24px) |
| **å±æ€§è¡Œ** | `.label-row` | Flex å¸ƒå±€ (ä¸¤ç«¯å¯¹é½)ï¼Œç”¨äºæ˜¾ç¤º "å±æ€§å - æ•°å€¼" |
| **ä¸»è¦æŒ‰é’®** | `.btn-primary` | 100% å®½åº¦ï¼Œä¸»è‰²èƒŒæ™¯ï¼Œåœ†è§’ (4px) |
| **æ¬¡è¦æŒ‰é’®** | `.btn-secondary` | ç°è‰²èƒŒæ™¯/æè¾¹ï¼Œç”¨äºå–æ¶ˆæˆ–æ¬¡è¦æ“ä½œ |
| **æ»‘åŠ¨æ¡** | `.slider-input` | ç»Ÿä¸€å®½åº¦çš„ range input |
| **æ•°å€¼è¾“å…¥æ¡†** | `.ie-input-number` | å›ºå®šå®½ 50pxï¼Œé«˜ 28pxï¼Œå±…ä¸­å¯¹é½ï¼Œæ— åŸç”Ÿç®­å¤´ï¼Œå¸¸é…åˆ Slider ä½¿ç”¨ |

## 7. å¼€å‘å·¥ä½œæµ (OpenSpec Workflow)

### 7.1 æè®® (Proposal)

åœ¨å¼€å‘æ–°åŠŸèƒ½å‰ï¼Œå¿…é¡»åœ¨ `.spec/proposals/` ä¸‹åˆ›å»ºæ–‡æ¡£ï¼Œå¹¶å›ç­”ä»¥ä¸‹â€œçµé­‚ä¸‰é—®â€ï¼š

1.  **å¤ç”¨æ£€æŸ¥**: â€œæˆ‘è¦å†™çš„è¿™ä¸ªè¾…åŠ©å‡½æ•°ï¼Œ`src/utils` é‡Œæœ‰æ²¡æœ‰ï¼ŸUI ç»„ä»¶åœ¨ `common` é‡Œæœ‰æ²¡æœ‰ï¼Ÿâ€
2.  **UI ä½ç½®**: åœ¨ `ToolPanel` çš„å“ªä¸ªä½ç½®å¢åŠ å…¥å£ï¼Ÿ
3.  **äº¤äº’é€»è¾‘**: æ‹–å…¥ç”»å¸ƒåçš„é»˜è®¤è¡Œä¸ºï¼ˆå±…ä¸­ï¼Ÿè‡ªåŠ¨ç¼©æ”¾ï¼Ÿï¼‰ã€‚

### 7.2 å®æ–½æ£€æŸ¥æ¸…å• (The "Golden Checklist") [CRITICAL]

> ğŸ›‘ **Code Review å¿…è¿‡é¡¹**ï¼šç”Ÿæˆä»£ç å‰ï¼Œå¿…é¡»ä½œä¸ºæœ€åä¸€æ­¥é€ä¸€æ ¸å¯¹ã€‚

#### ğŸ›¡ï¸ ç¨³å®šæ€§ä¸è§„èŒƒ

- [ ] **Fabric ç‰ˆæœ¬**: ç¡®è®¤ä½¿ç”¨çš„æ˜¯ `new fabric.Canvas` (v5) è€Œé `new Canvas` (v6)ï¼Ÿ
- [ ] **çŠ¶æ€ç®¡ç†**: ç¡®è®¤**æ²¡æœ‰**å¼•å…¥ `pinia` æˆ– `vuex`ï¼Ÿæ˜¯å¦å¤ç”¨äº† `useEditorState`ï¼Ÿ
- [ ] **æ€§èƒ½å®‰å…¨**: `fabric.Canvas` å®ä¾‹æ˜¯å¦è¢« `markRaw()` åŒ…è£…ï¼Ÿï¼ˆé˜²æ­¢ Vue æ·±åº¦ä»£ç†å¯¼è‡´å¡é¡¿ï¼‰
- [ ] **æ¸²æŸ“ä¼˜åŒ–**: æ˜¯å¦ä½¿ç”¨äº† `requestRenderAll()` æ›¿ä»£ `renderAll()`ï¼Ÿ

#### ğŸ§© å¤ç”¨ä¸è§£è€¦

- [ ] **DRY (Utils)**: æ˜¯å¦æœ‰çº¯è®¡ç®—é€»è¾‘ï¼Ÿå¦‚æœæœ‰ï¼Œæ˜¯å¦æå–åˆ°äº† `src/utils/`ï¼Ÿ
- [ ] **DRY (UI)**: é”™è¯¯æç¤ºæ˜¯å¦è°ƒç”¨äº† `toast.js`ï¼Ÿç¡®è®¤å¼¹çª—æ˜¯å¦å¤ç”¨äº† `Modal.vue`ï¼Ÿ
- [ ] **æ¨¡å—åŒ–**: æ–°å¢çš„ Fabric æ“ä½œé€»è¾‘æ˜¯å¦å°è£…åœ¨ç‹¬ç«‹çš„ Hook ä¸­ï¼Œè€Œä¸æ˜¯å¡è¿› `useCanvas.js`ï¼Ÿ

#### ğŸ¨ UI/UX ä¸€è‡´æ€§

- [ ] **è‰²å½©å˜é‡**: ç¡®è®¤ä»£ç ä¸­**ä¸å­˜åœ¨**åå…­è¿›åˆ¶é¢œè‰²å€¼ (å¦‚ `#007bff`)ï¼Œè€Œæ˜¯ä½¿ç”¨äº† `var(--primary-color)`ï¼Ÿ
- [ ] **æ ‡å‡†ç±»å**: æŒ‰é’®æ˜¯å¦ä½¿ç”¨äº† `.btn-primary`ï¼Ÿé¢æ¿æ ‡é¢˜æ˜¯å¦ä½¿ç”¨äº† `.panel-title`ï¼Ÿ
- [ ] **å¼‚æ­¥åé¦ˆ**: è°ƒç”¨ AI æˆ–è€—æ—¶æ“ä½œå‰ï¼Œæ˜¯å¦è°ƒç”¨äº† `setLoading(true)`ï¼Ÿ
</file>

<file path=".spec/prompt.md">
# ç»ˆç«¯è¿è¡Œ npx repomix

# è§„èŒƒåŒ–æé—®

æ‰”ç¬¬ä¸€æ®µ -> AI å˜èº«æ¶æ„å¸ˆã€‚ï¼ˆæ–°çª—å£ï¼‰

æ‰”ç¬¬äºŒæ®µ -> AI å¸®ä½ å†™æ–‡æ¡£ã€æŸ¥æ¼è¡¥ç¼ºã€‚

æ‰”ç¬¬ä¸‰æ®µ -> AI å¸®ä½ å†™å‡ºé«˜è´¨é‡ã€æ—  Bug çš„ä»£ç ã€‚

# ç¬¬ä¸€æ­¥ åˆå§‹åŒ–

ä½ å¥½ï¼Œä½ æ˜¯â€œå¤§ç§˜ç¾å›¾ (Dami Meitu)â€é¡¹ç›®çš„é¦–å¸­æ¶æ„å¸ˆã€‚

æˆ‘å°†å‘ç»™ä½ ä¸€ä»½é¡¹ç›®çš„ **æ ¸å¿ƒå®ªæ³• (Project Charter)**ã€‚åœ¨æ¥ä¸‹æ¥çš„å¯¹è¯ä¸­ï¼Œä½ ç”Ÿæˆçš„æ‰€æœ‰ä»£ç å’Œå»ºè®®å¿…é¡»**ä¸¥æ ¼éµå®ˆ**è¿™ä»½æ–‡æ¡£ä¸­çš„æŠ€æœ¯çº¦æŸã€‚

**âš ï¸ å…³é”®çº¦æŸæé†’ (åŸºäºå®ªæ³• v3.5)ï¼š**

1.  **Fabric.js ç‰ˆæœ¬**ï¼šå¿…é¡»ä½¿ç”¨ v5 è¯­æ³•ï¼ˆ`new fabric.Canvas`ï¼‰ï¼Œ**ä¸¥ç¦** v6 (Promise-based)ã€‚
2.  **çŠ¶æ€ç®¡ç†**ï¼š**ä¸¥ç¦**å¼•å…¥ Pinia/Vuexï¼Œå¿…é¡»å¤ç”¨ `useEditorState.js` å•ä¾‹ã€‚
3.  **UI è®¾è®¡è§„èŒƒ**ï¼š**ä¸¥ç¦**ç¡¬ç¼–ç é¢œè‰²ï¼ˆå¦‚ `#007bff`ï¼‰ï¼Œå¿…é¡»ä½¿ç”¨ CSS å˜é‡ï¼ˆå¦‚ `var(--primary-color)`ï¼‰å’Œæ ‡å‡†ç±»åï¼ˆå¦‚ `.btn-primary`ï¼‰ã€‚
4.  **æ€§èƒ½é“å¾‹**ï¼šCanvas å®ä¾‹å¿…é¡»ç”¨ `markRaw()` åŒ…è£…ï¼›æ‰¹é‡æ“ä½œå¿…é¡»ç”¨ `requestRenderAll()`ã€‚
5.  **éªŒæ”¶æ ‡å‡†**ï¼šæ‰€æœ‰ä»£ç ç”Ÿæˆå‰ï¼Œå¿…é¡»é€šè¿‡å®ªæ³• 7.2 èŠ‚çš„ **â€œé»„é‡‘æ£€æŸ¥æ¸…å•â€**ã€‚

è¯·é˜…è¯»å·²æœ‰çš„ æˆ‘ä¸Šä¼ çš„repomix-output.xml æ–‡ä»¶ã€‚å¦‚æœä½ å‡†å¤‡å¥½äº†ï¼Œè¯·å›å¤ï¼šâ€œ**å·²åŠ è½½é¡¹ç›®å®ªæ³• v3.5 (Final)ï¼Œæ¶æ„å¸ˆå°±ä½ã€‚**â€
è¯·è¾“å‡º Markdown æ ¼å¼çš„ Proposal æ–‡æ¡£ã€‚

# ç¬¬äºŒæ­¥ æ¸…ç©ºç”»å¸ƒæŒ‰é’®åŠŸèƒ½ï¼ˆä¸¾ä¾‹ï¼‰

æˆ‘æƒ³è¦å¼€å‘ä¸€ä¸ªæ–°åŠŸèƒ½ï¼šåœ¨é¡¶éƒ¨å¯¼èˆªæ åŠ ä¸€ä¸ªâ€œæ¸…ç©ºç”»å¸ƒâ€çš„æŒ‰é’®ã€‚
è¯·æ ¹æ®å®ªæ³• **ç¬¬ 7.1 èŠ‚ (OpenSpec Workflow)**ï¼Œä¸ºæˆ‘èµ·è‰ä¸€ä»½ **å®æ–½æè®® (Proposal)**ã€‚

**è¯·å›ç­”â€œçµé­‚ä¸‰é—®â€å¹¶è§„åˆ’ï¼š**

1.  **å¤ç”¨æ£€æŸ¥**ï¼š
    - ç¡®è®¤å¼¹çª—æ˜¯å¦å¤ç”¨ `src/components/common/Modal.vue`ï¼Ÿ
    - é”™è¯¯æç¤ºæ˜¯å¦å¤ç”¨ `src/utils/toast.js`ï¼Ÿ
2.  **UI ä½ç½®**ï¼šåº”è¯¥ä¿®æ”¹å“ªä¸ªæ–‡ä»¶ï¼Ÿæ˜¯å¦ç¬¦åˆ UI è§„èŒƒï¼Ÿ
3.  **æ ¸å¿ƒé€»è¾‘**ï¼š
    - `clearCanvas` æ–¹æ³•åº”æ”¾åœ¨ `useCanvas.js` è¿˜æ˜¯ç‹¬ç«‹ Hookï¼Ÿ
    - æ¸…ç©ºåæ˜¯å¦éœ€è¦é‡ç½® `history` å †æ ˆï¼Ÿ

è¯·è¾“å‡º Markdown æ ¼å¼çš„ Proposal æ–‡æ¡£ã€‚

# ç¬¬ä¸‰æ­¥ æ¸…ç©ºç”»å¸ƒæŒ‰é’®åŠŸèƒ½ï¼ˆå®ç°ï¼‰

æè®®é€šè¿‡ã€‚è¯·ç”Ÿæˆä»£ç ã€‚

**ğŸ›‘ é‡è¦ï¼šåœ¨è¾“å‡ºä»£ç å—ä¹‹å‰ï¼Œè¯·å…ˆæ‰§è¡Œâ€œå®ªæ³• 7.2 é»„é‡‘æ£€æŸ¥æ¸…å•â€çš„è‡ªæˆ‘å®¡æŸ¥ï¼š**

1.  [ ] æ£€æŸ¥æ˜¯å¦ç”¨äº† `markRaw`ï¼Ÿ
2.  [ ] æ£€æŸ¥æ˜¯å¦ç”¨äº† Fabric v5 APIï¼Ÿ
3.  [ ] æ£€æŸ¥æ˜¯å¦å¤ç”¨äº† CSS å˜é‡ï¼ˆæ— ç¡¬ç¼–ç é¢œè‰²ï¼‰ï¼Ÿ
4.  [ ] æ£€æŸ¥é€šç”¨é€»è¾‘æ˜¯å¦æå–åˆ°äº† `src/utils`ï¼Ÿ

**å¦‚æœæ£€æŸ¥é€šè¿‡ï¼Œè¯·è¾“å‡ºæœ€ç»ˆçš„ Vue/JS ä»£ç ã€‚**

# ç¬¬å››æ­¥ æ›´æ–° active-context.md

è¿™æ˜¯æˆ‘æœ€æ–°çš„ active-context.mdï¼ˆæ–‡ä»¶ä¸Šä¼ æ¯ä¸ªæ–°çª—å£åªç”¨ä¼ ä¸€æ¬¡ï¼‰
â€œä»£ç å†™å¾—ä¸é”™ã€‚è¯·å¸®æˆ‘æ›´æ–° .spec/active-context.mdï¼ŒæŠŠåˆšæ‰å®Œæˆçš„ä»»åŠ¡å‹¾é€‰æ‰ï¼Œå¹¶è®°å½•ä¸‹è¿™æ¬¡çš„å˜æ›´ç‚¹ã€‚â€
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>image-editor</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
</file>

<file path="src/App.vue">
<template>
  <EditorLayout />
</template>

<script setup>
import EditorLayout from './components/layout/EditorLayout.vue';
</script>

<style>
html,
body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  /* é˜²æ­¢å‡ºç°æ»šåŠ¨æ¡ */
}

#app {
  width: 100%;
  height: 100%;
}

.app-wrapper {
  width: 100vw;
  /* å¼ºåˆ¶è§†å£å®½åº¦ */
  height: 100vh;
  /* å¼ºåˆ¶è§†å£é«˜åº¦ */
  display: flex;
  flex-direction: column;
}
</style>
</file>

<file path="src/components/layout/LeftSidebar.vue">
<template>
  <div class="left-sidebar">
    <div v-for="item in menuItems" :key="item.id" class="menu-item" :class="{ active: state.activeTool === item.id }"
      @click="setActiveTool(item.id)">
      <svg class="menu-icon" viewBox="0 0 1024 1024" width="20" height="20">
        <path :d="item.iconPath" fill="currentColor" />
      </svg>
      <span class="label">{{ item.label }}</span>
    </div>
  </div>
</template>

<script setup>
import { useEditorState } from '../../composables/useEditorState';

// 1. æ›¿ä»£ Pinia
const { state, setActiveTool } = useEditorState();

// 2. å®šä¹‰èœå•é…ç½® (å« SVG è·¯å¾„)
// è¿™é‡Œçš„è·¯å¾„æ•°æ®å¯¹åº”åŸæœ‰çš„å›¾æ ‡éšå–»
const menuItems = [
  {
    id: 'adjust',
    label: 'è°ƒæ•´',
    // Operation (Sliders)
    iconPath: 'M192 128v768h128V672h192v224h128V672h192V544H512V128H192zm128 128h192v160H320V256z'
  },
  {
    id: 'draw',
    label: 'ç»˜åˆ¶',
    // Brush
    iconPath: 'M853.504 192.064l-235.008 235.008-60.352-60.352 235.008-235.008a64 64 0 0 1 90.496 0l-30.144 30.144 30.144 30.208z m-467.2 491.52l60.352-60.352L249.408 425.984l-60.352 60.352 197.248 197.248zM189.056 365.632l60.352-60.352 384.896 384.896-60.352 60.352L189.056 365.632zM128 896a64 64 0 0 1-64-64c0-68.992 48.128-196.608 107.52-256l192 192C304.128 827.392 192 896 128 896z'
  },
  {
    id: 'text',
    label: 'æ–‡æœ¬',
    // Document
    iconPath: 'M832 64H192a64 64 0 0 0-64 64v768a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V128a64 64 0 0 0-64-64zM256 256h512v64H256v-64zm512 448H256v-64h512v64zm0-192H256v-64h512v64z'
  },
  {
    id: 'border',
    label: 'è¾¹æ¡†',
    // FullScreen (Frame)
    iconPath: 'M160 160v192h-64V96h256v64H160z m0 704h192v64H96V672h64v192z m704-192v192H672v64h256V672h-64z m0-288V160H672V96h256v288h-64z'
  },
  {
    id: 'material',
    label: 'ç´ æ',
    // Grid
    iconPath: 'M448 128H128v320h320V128zm-64 256H192V192h192v192z m448-256H576v320h256V128zm-64 256H640V192h192v192z M448 576H128v320h320V576zm-64 256H192V640h192v192z m448-256H576v320h256V576zm-64 256H640V640h192v192z'
  },
  {
    id: 'watermark',
    label: 'æ°´å°',
    // Stamp
    iconPath: 'M832 320H608V128h-64a96 96 0 0 0-96-96h-64a96 96 0 0 0-96 96h-64v192H192a64 64 0 0 0-64 64v512h768V384a64 64 0 0 0-64-64z m-320-96h64v96h-64v-96z m0-128h64a32 32 0 0 1 32 32v32h-128V128a32 32 0 0 1 32-32zM256 704a64 64 0 1 1 0-128 64 64 0 0 1 0 128zm256 128a64 64 0 1 1 0-128 64 64 0 0 1 0 128zm256-128a64 64 0 1 1 0-128 64 64 0 0 1 0 128z'
  },
  {
    id: 'puzzle',
    label: 'æ‹¼å›¾',
    // Connection
    iconPath: 'M704 576a128 128 0 0 1-128 128h-64v256h-64V704h-64a128 128 0 1 1 0-256h64V192h64v256h64a128 128 0 0 1 128 128z m-256-64h64V256h-64v256zM320 576a64 64 0 1 0 64-64h-64v64zm384 0a64 64 0 1 0-64-64h64v64z'
  },
  {
    id: 'ai',
    label: 'AI',
    // Cpu/Chip
    iconPath: 'M832 192H192v640h640V192z m64-64v768H128V128h768z M320 320h128v128H320V320z m0 256h128v128H320V576z m256-256h128v128H576V320z m0 256h128v128H576V576z'
  },
];
</script>

<style scoped>
.left-sidebar {
  width: 72px;
  background-color: #fff;
  border-right: 1px solid #e4e7ed;
  display: flex;
  flex-direction: column;
  padding-top: 12px;
  overflow-y: auto;
}

.left-sidebar::-webkit-scrollbar {
  display: none;
}

.menu-item {
  height: 68px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #606266;
  gap: 6px;
  transition: all 0.2s;
  flex-shrink: 0;
}

.menu-item:hover {
  color: #409eff;
  background-color: #f5f7fa;
}

.menu-item.active {
  color: #409eff;
  font-weight: 500;
  background-color: #ecf5ff;
  position: relative;
}

.menu-item.active::before {
  content: '';
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 3px;
  height: 24px;
  background-color: #409eff;
  border-radius: 0 2px 2px 0;
}

.label {
  font-size: 12px;
  line-height: 1;
}

/* ç¡®ä¿ SVG é¢œè‰²è·Ÿéšæ–‡å­—é¢œè‰²å˜åŒ– */
.menu-icon {
  fill: currentColor;
  display: block;
  /* æ¶ˆé™¤ baseline é—´éš™ */
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustMosaic.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="7" height="7" /><rect x="14" y="3" width="7" height="7" />
          <rect x="14" y="14" width="7" height="7" /><rect x="3" y="14" width="7" height="7" />
        </svg>
        <span>é©¬èµ›å…‹</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content filter-panel">
      <div class="mode-row">
        <div class="mode-btn" :class="{ active: activeMode === 'path' }" @click="setMode('path')" title="æ¶‚æŠ¹">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM4 11c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm16 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
        </div>
        <div class="mode-btn" :class="{ active: activeMode === 'rect' }" @click="setMode('rect')" title="çŸ©å½¢">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" /></svg>
        </div>
        <div class="mode-btn" :class="{ active: activeMode === 'circle' }" @click="setMode('circle')" title="åœ†å½¢">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9" /></svg>
        </div>
      </div>

      <div class="intensity-section">
        <div class="label-row">
          <span>å¼ºåº¦</span>
          <input type="number" v-model.number="intensity" class="ie-input-number" @change="updateConfig">
        </div>
        <input type="range" v-model.number="intensity" min="4" max="100" class="ie-slider" @input="updateConfig">
      </div>

      <div class="action-buttons">
        <button class="ie-btn ie-primary full" @click="handleApply" :disabled="loading">
          {{ loading ? 'å¤„ç†ä¸­...' : 'ç¡®å®šåº”ç”¨' }}
        </button>
        <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted } from 'vue';
import { registerMosaicModule, startMosaicInteraction, applyMosaic, cancelMosaic } from './useCanvasMosaic';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const activeMode = ref('path');
const intensity = ref(15);
const loading = ref(false);

const setMode = (mode) => {
  activeMode.value = mode;
  startMosaicInteraction(mode, intensity.value);
};

const updateConfig = () => {
  startMosaicInteraction(activeMode.value, intensity.value);
};

const handleApply = async () => {
  loading.value = true;
  await applyMosaic(intensity.value);
  loading.value = false;
  emit('toggle');
};

const handleCancel = () => {
  cancelMosaic();
  emit('toggle');
};

watch(() => props.isExpanded, (val) => {
  if (val) setMode('path');
  else cancelMosaic();
});

onMounted(() => {
  if (canvasAPI?.canvas) registerMosaicModule(canvasAPI.canvas, canvasAPI.saveHistory);
});

// ç»„ä»¶é”€æ¯æ—¶ç¡®ä¿æ¸…ç†äº¤äº’çŠ¶æ€
onUnmounted(() => {
  cancelMosaic();
});
</script>

<style scoped>
.filter-panel { padding: 16px; }
.mode-row { display: flex; justify-content: space-between; margin-bottom: 24px; gap: 12px; }
.mode-btn { 
  flex: 1; height: 44px; display: flex; align-items: center; justify-content: center; 
  border-radius: 8px; background: #f5f7fa; cursor: pointer; border: 1px solid transparent; transition: 0.2s; 
}
.mode-btn:hover { background: #eef1f6; color: #333; }
.mode-btn.active { background: #ecf5ff; border-color: var(--ie-primary-color); color: var(--ie-primary-color); }

.intensity-section { margin-bottom: 24px; }
/* label-row ç»§æ‰¿å®ªæ³•è§„èŒƒï¼Œè¿™é‡Œå¾®è°ƒé—´è· */
.label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; font-size: 13px; color: #606266; }

.action-buttons { display: flex; gap: 10px; }
.full { flex: 1; }
</style>
</file>

<file path="src/components/modules/adjust/useCanvasColor.js">
// src/components/modules/adjust/useCanvasColor.js
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let originalFilters = []; // ç”¨äºå–æ¶ˆæ—¶æ¢å¤

export const registerColorModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};

/**
 * æ ¸å¿ƒï¼šåº”ç”¨ç»„åˆæ»¤é•œ
 * @param {Object} params - åŒ…å«äº®åº¦ã€å¯¹æ¯”åº¦ç­‰æ•°å€¼çš„å¯¹è±¡
 */
export const applyColorAdjust = (params) => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) return;

    // è®°å½•åˆå§‹çŠ¶æ€ç”¨äºæ¢å¤
    if (originalFilters.length === 0 && bgImage.filters.length > 0) {
        originalFilters = [...bgImage.filters];
    }

    const filters = [];

    // 1. æ¨¡ç³Š (-100 ~ 0) / é”åŒ– (0 ~ 100)
    if (params.blurSharpen < 0) {
        filters.push(new fabric.Image.filters.Blur({ blur: Math.abs(params.blurSharpen) / 100 }));
    } else if (params.blurSharpen > 0) {
        filters.push(new fabric.Image.filters.Convolute({
            matrix: [0, -1, 0, -1, 5, -1, 0, -1, 0] // é”åŒ–çŸ©é˜µ
        }));
    }

    // 2. é¥±å’Œåº¦ (-100 ~ 100 -> -1 ~ 1)
    if (params.saturation !== 0) {
        filters.push(new fabric.Image.filters.Saturation({ saturation: params.saturation / 100 }));
    }

    // 3. äº®åº¦ (-100 ~ 100 -> -1 ~ 1)
    if (params.brightness !== 0) {
        filters.push(new fabric.Image.filters.Brightness({ brightness: params.brightness / 100 }));
    }

    // 4. å¯¹æ¯”åº¦ (-100 ~ 100 -> -1 ~ 1)
    if (params.contrast !== 0) {
        filters.push(new fabric.Image.filters.Contrast({ contrast: params.contrast / 100 }));
    }

    // 5. è‰²æ¸© (é€šè¿‡ ColorMatrix æ¨¡æ‹Ÿ)
    if (params.temperature !== 0) {
        const temp = params.temperature / 100;
        filters.push(new fabric.Image.filters.ColorMatrix({
            matrix: [
                1 + temp, 0, 0, 0, 0, // R
                0, 1, 0, 0, 0,        // G
                0, 0, 1 - temp, 0, 0, // B
                0, 0, 0, 1, 0         // A
            ]
        }));
    }

    // 6. è‰²è°ƒ (-100 ~ 100 -> -1 ~ 1)
    if (params.hue !== 0) {
        filters.push(new fabric.Image.filters.HueRotation({ rotation: params.hue / 100 }));
    }

    bgImage.filters = filters;
    bgImage.applyFilters();
    canvas.requestRenderAll();
};

export const cancelColorAdjust = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        bgImage.filters = [...originalFilters];
        bgImage.applyFilters();
        canvas.requestRenderAll();
    }
    originalFilters = [];
};

export const commitColorAdjust = () => {
    if (saveHistoryFn) saveHistoryFn();
    originalFilters = [];
};
</file>

<file path="src/components/modules/adjust/useCanvasColorOverlay.js">
// src/components/modules/adjust/useCanvasColorOverlay.js
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let backupFilters = [];
let backupColor = null;    // âœ… æ–°å¢ï¼šå¤‡ä»½é¢œè‰²
let backupOpacity = 30;


export const registerColorOverlayModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};


/**
 * å¤‡ä»½å½“å‰çŠ¶æ€ï¼ˆåŒ…å«æ»¤é•œæ•°ç»„å’Œå…ƒæ•°æ®ï¼‰
 */
export const backupCurrentColorOverlay = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        // æ·±æ‹·è´æ»¤é•œæ•°ç»„
        backupFilters = [...bgImage.filters];
        // å¤‡ä»½å…ƒæ•°æ®
        backupColor = bgImage._lastOverlayColor || null;
        backupOpacity = bgImage._lastOverlayOpacity ?? 30;
    }
};

/**
 * åº”ç”¨é¢œè‰²å åŠ ï¼šè®°å½•å…ƒæ•°æ®åˆ°å›¾ç‰‡å¯¹è±¡
 */
export const applyColorOverlay = (color, opacity = 30) => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) return;

    // è®°å½•å…ƒæ•°æ®ï¼Œç”¨äº UI çŠ¶æ€åŒæ­¥
    bgImage._lastOverlayColor = color;
    bgImage._lastOverlayOpacity = opacity;

    const existingIndex = bgImage.filters.findIndex(f => f instanceof fabric.Image.filters.BlendColor);

    if (!color) {
        if (existingIndex > -1) {
            bgImage.filters.splice(existingIndex, 1);
        }
    } else {
        const filter = new fabric.Image.filters.BlendColor({
            color: color,
            mode: 'tint',
            alpha: opacity / 100
        });

        if (existingIndex > -1) {
            bgImage.filters[existingIndex] = filter;
        } else {
            bgImage.filters.push(filter);
        }
    }

    bgImage.applyFilters();
    canvas.requestRenderAll();
};

/**
 * å–æ¶ˆä¿®æ”¹ï¼šè¿˜åŸæ»¤é•œæ•°ç»„å’Œå…ƒæ•°æ®
 */
export const cancelColorOverlayChange = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        bgImage.filters = [...backupFilters];
        // è¿˜åŸå…ƒæ•°æ®
        bgImage._lastOverlayColor = backupColor;
        bgImage._lastOverlayOpacity = backupOpacity;
        
        bgImage.applyFilters();
        canvas.requestRenderAll();
    }
    backupFilters = [];
};

export const commitColorOverlay = () => {
    if (saveHistoryFn) saveHistoryFn(); // ä¿å­˜å†å²è®°å½•
    backupFilters = [];
};
</file>

<file path="src/utils/toast.js">
export const toast = {
    show(text, type = 'info') {
        const div = document.createElement('div');
        div.className = 'ie-toast';
        div.innerText = text;
        // ç®€å•åŒºåˆ†é¢œè‰²
        if (type === 'error') div.style.background = 'rgba(255, 77, 79, 0.9)';
        if (type === 'success') div.style.background = 'rgba(82, 196, 26, 0.9)';

        document.body.appendChild(div);
        setTimeout(() => {
            div.style.transition = 'opacity 0.3s';
            div.style.opacity = '0';
            setTimeout(() => div.remove(), 300);
        }, 2000);
    },
    success(text) { this.show(text, 'success'); },
    warning(text) { this.show(text, 'warning'); },
    error(text) { this.show(text, 'error'); },
    info(text) { this.show(text, 'info'); }
};
</file>

<file path=".spec/active-context.md">
# Active Context & Development State

> **Last Updated**: 2025-12-22
> **Current Focus**: Feature Stabilization & Module Documentation

## 1. å½“å‰å¼€å‘çŠ¶æ€ (Current Status)

### âœ… å·²å®Œæˆ (Completed)

#### 1.1 æ™ºèƒ½è°ƒæ•´æ¨¡å— (Smart AI Features)
* **æ™ºèƒ½æ¶ˆé™¤ç¬” (Smart Inpaint)**:
    * [x] **äº¤äº’é‡æ„**: å®ç°äº†â€œæ‰€è§å³æ‰€å¾—â€çš„è‡ªåŠ¨è§¦å‘æœºåˆ¶ï¼ˆç”»ç¬” 1ç§’é˜²æŠ– / æ¡†é€‰æ¾æ‰‹å³å‘ï¼‰ã€‚
    * [x] **å¯¹è±¡é”å®šç³»ç»Ÿ (Hard Lock)**: è§£å†³äº† Fabric.js åº•å±‚å›¾ç‰‡æŠ¢å é¼ æ ‡äº‹ä»¶çš„é—®é¢˜ï¼Œå®ç°äº†è¿›å…¥æ¨¡å—å³å¼ºåˆ¶é”å®šåº•å›¾äº¤äº’ã€‚
    * [x] **é˜²é—ªçƒæ¸²æŸ“**: é‡‡ç”¨ **ç¦»å±æ¸²æŸ“ (Offscreen Rendering)** æŠ€æœ¯ç”Ÿæˆé»‘ç™½é®ç½©ï¼Œæ¶ˆé™¤äº† AI å¤„ç†å‰çš„å±å¹•é—ªçƒ (ADR-004)ã€‚
    * [x] **çŠ¶æ€ç®¡ç†**: å¼•å…¥ **å¤‡å¿˜å½•æ¨¡å¼ (Memento Pattern)**ï¼Œè¿›å…¥æ¨¡å—è‡ªåŠ¨ä¿å­˜å¿«ç…§ï¼Œæ”¯æŒâ€œæ¢å¤åŸå›¾â€ã€‚

#### 1.2 åŸºç¡€ç¼–è¾‘æ¨¡å— (Basic Editing)
* **å‰ªè£/æ—‹è½¬ (Crop & Rotate)** `AdjustCrop.vue`:
    * [x] **è‡ªç”±å‰ªè£**: æ”¯æŒæ‹–æ‹½ 8 ä¸ªæ§åˆ¶ç‚¹è°ƒæ•´å‰ªè£æ¡†ï¼Œå†…ç½®å¸¸ç”¨æ¯”ä¾‹ (1:1, 16:9, 4:3 ç­‰)ã€‚
    * [x] **ä»»æ„æ—‹è½¬**: æ”¯æŒ -45Â° è‡³ 45Â° çš„å¾®è°ƒæ—‹è½¬ä»¥åŠ 90Â° æ­¥è¿›æ—‹è½¬ã€‚
    * [x] **äº¤äº’é€»è¾‘**: è¿›å…¥æ¨¡å—æ—¶è‡ªåŠ¨æ·»åŠ è¦†ç›–å±‚ (Overlay)ï¼Œå‰ªè£æ“ä½œåŸºäº Viewport å˜æ¢å®ç°ï¼Œéç ´åæ€§ç¼–è¾‘ã€‚
* **è°ƒæ•´å°ºå¯¸ (Resize)** `AdjustResize.vue`:
    * [x] **åƒç´ æ§åˆ¶**: æ”¯æŒæ‰‹åŠ¨è¾“å…¥å®½/é«˜åƒç´ å€¼ã€‚
    * [x] **æ¯”ä¾‹é”å®š**: å®ç°äº†â€œå®½é«˜æ¯”é”å®šâ€å¼€å…³ï¼Œè°ƒæ•´ä¸€è¾¹è‡ªåŠ¨è®¡ç®—å¦ä¸€è¾¹ã€‚
    * [x] **å•ä½è½¬æ¢**: (é¢„ç•™) ç›®å‰åŸºäºåƒç´  (px) å¤„ç†ã€‚
* **å›¾ç‰‡è¡¥ç™½ (AdjustWhite)** `AdjustWhite.vue`:
    * [x] **ç”»å¸ƒæ‰©å±•**: æ”¯æŒä»¥å›¾ç‰‡ä¸ºä¸­å¿ƒå‘å››å‘¨æ‰©å±•ç”»å¸ƒã€‚
    * [x] **èƒŒæ™¯å¡«å……**: æ‰©å±•åŒºåŸŸæ”¯æŒå¡«å……è‡ªå®šä¹‰é¢œè‰² (é»˜è®¤ç™½è‰²)ã€‚
    * [x] **æ¯”ä¾‹ç¼©æ”¾**: æä¾›äº†é€šè¿‡æ»‘å— (0-100%) å¿«é€Ÿè°ƒæ•´ç•™ç™½æ¯”ä¾‹çš„äº¤äº’ã€‚

#### 1.3 è‰²å½©ä¸æ»¤é•œæ¨¡å— (Color & Filters)
* **è‰²å½©è°ƒèŠ‚ (Color Adjust)** `AdjustColor.vue`:
    * [x] **å…¨èƒ½å‚æ•°**: å®ç°äº† 6 ç»´è°ƒèŠ‚ï¼šäº®åº¦ (Brightness)ã€å¯¹æ¯”åº¦ (Contrast)ã€é¥±å’Œåº¦ (Saturation)ã€æ¨¡ç³Š/é”åŒ– (Blur/Sharpen)ã€è‰²æ¸© (Temperature)ã€è‰²è°ƒ (Hue)ã€‚
    * [x] **æ€§èƒ½ä¼˜åŒ–**: åŸºäº WebGL æ»¤é•œåç«¯ï¼Œæ»‘å—æ‹–åŠ¨æ—¶å®æ—¶æ¸²æŸ“ã€‚
    * [x] **æ’¤é”€æ”¯æŒ**: è°ƒèŠ‚è¿‡ç¨‹æ”¯æŒåŸå­çº§æ’¤é”€/é‡åšã€‚
* **é¢œè‰²å åŠ  (Color Overlay)** `AdjustColorOverlay.vue`:
    * [x] **æ··åˆæ¨¡å¼**: åŸºäº `BlendColor` æ»¤é•œå®ç°ï¼Œæ”¯æŒè‡ªå®šä¹‰ HEX é¢œè‰²å’Œé€æ˜åº¦ (Alpha) æ··åˆã€‚
    * [x] **é¢„è®¾å¸ç®¡**: æä¾›äº†å¸¸ç”¨è‰²å—é¢„è®¾å’ŒåŸç”Ÿå–è‰²å™¨ã€‚
* **æ»¤é•œæ•ˆæœ (Filters)** `AdjustFilters.vue`:
    * [x] **é¢„è®¾åº“**: é›†æˆäº†é»‘ç™½ (Grayscale)ã€æ€€æ—§ (Sepia/Vintage)ã€æŸ¯è¾¾ (Kodachrome) ç­‰ç»å…¸æ»¤é•œã€‚
    * [x] **ä¸€é”®åº”ç”¨**: ç‚¹å‡»å³ç”¨ï¼Œæ”¯æŒå åŠ å…¶ä»–è‰²å½©è°ƒèŠ‚æ“ä½œã€‚

#### 1.4 åŸºç¡€è®¾æ–½ä¸äº¤äº’æ¡†æ¶ (Infrastructure & Interaction)
* **ç”»å¸ƒå·¥ä½œåŒº (Workspace)** `Workspace.vue`:
    * [x] **åŠ¨æ€ç”»å¸ƒ**: åŸºäº `canvasAPI` æ³¨å…¥ï¼Œå®ç°äº†å“åº”å¼å®½é«˜çš„ Fabric.js ç”»å¸ƒåˆå§‹åŒ–ã€‚
    * [x] **åŒå‘ç¼©æ”¾ (Zoom)**: å®ç°äº† Canvas ç¼©æ”¾ä¸ UI ç™¾åˆ†æ¯”çš„å®æ—¶åŒæ­¥ï¼Œç›‘å¬ `zoom:change` å’Œ `mouse:wheel` äº‹ä»¶ã€‚
* **å¿«æ·é”®ç³»ç»Ÿ (Keyboard Shortcuts)** `New!`:
    * [x] **é…ç½®åŒ–é©±åŠ¨**: å»ºç«‹äº† `src/config/shortcuts.js` ä½œä¸ºå•ä¸€æ•°æ®æºï¼Œç»Ÿä¸€ç®¡ç†é”®ä½æ˜ å°„ã€‚
    * [x] **å…¨å±€ç›‘å¬**: å®ç°äº† `useKeyboardShortcuts`ï¼Œæ”¯æŒé€šç”¨å¿«æ·é”® (Ctrl+C/V/Z, Delete) å’Œå›¾å±‚æ“ä½œ ( `[` `]` )ã€‚
    * [x] **å¯è§†åŒ–é¢æ¿**: æ–°å¢ **ä¾§è¾¹æŠ½å±‰ç»„ä»¶ (ShortcutsPanel)**ï¼Œé‡‡ç”¨ Keycap é£æ ¼å±•ç¤ºå¿«æ·é”®åˆ—è¡¨ï¼Œæ”¯æŒç‚¹å‡»å¯¼èˆªæ  **Commandå›¾æ ‡** å”¤èµ·ã€‚
    * [x] **UI é›†æˆ**: æ‚¬æµ®èœå• (`FloatingObjectMenu`) æ–°å¢äº†å¿«æ·é”®æ–‡å­—æç¤º (Tooltips)ã€‚
* **å³é”®èœå• (Context Menu)** `CanvasContextMenu.vue`:
    * [x] **åæ ‡ä¿®æ­£**: ä¿®å¤äº†ç²˜è´´ä½ç½®åç§»é—®é¢˜ï¼Œç°åœ¨é¼ æ ‡æŒ‡é’ˆå³ä¸ºç²˜è´´å¯¹è±¡çš„**å·¦ä¸Šè§’ (Top-Left)**ã€‚
    * [x] **äº¤äº’äº’æ–¥**: å®ç°äº†ç‚¹å‡»ç”»å¸ƒç©ºç™½å¤„æˆ–èœå•å¤–åŒºåŸŸè‡ªåŠ¨å…³é—­èœå•çš„é€»è¾‘ã€‚
* **æ‚¬æµ®å¯¹è±¡èœå• (Floating Menu)** `FloatingObjectMenu.vue`:
    * [x] **äº‹ä»¶éš”ç¦»**: å®ç°äº†é˜²è¯¯è§¦é€»è¾‘ï¼Œåœ¨æ‚¬æµ®æ¡ä¸Šç‚¹å‡»å³é”®ä¸ä¼šè§¦å‘åº•å±‚çš„ Canvas å³é”®èœå•ã€‚
    * [x] **ç»„ä»¶é›†æˆ**: å®Œæˆäº†ç»„ä»¶æŒ‚è½½ä¸åŸºç¡€æ˜¾éšæ§åˆ¶ã€‚

---

## 3. æŠ€æœ¯ç»†èŠ‚å¤‡å¿˜ (Technical Memo)

### 3.1 åŸºç¡€ç¼–è¾‘å®ç°é€»è¾‘
* **å‰ªè£ (Crop)**:
    * **æ ¸å¿ƒ**: ä¸ç›´æ¥åˆ‡å‰²å›¾ç‰‡åƒç´ ï¼Œè€Œæ˜¯é€šè¿‡ `canvas.setViewportTransform` æ”¹å˜å¯è§†çª—å£ï¼Œå¹¶åœ¨å¯¼å‡º (`toDataURL`) æ—¶æŒ‡å®š `left/top/width/height` å‚æ•°æ¥å®ç°ç‰©ç†å‰ªè£ã€‚
    * **é®ç½©**: ä½¿ç”¨åŠé€æ˜çš„ `fabric.Path` æˆ–ç»„åˆå›¾å½¢æ„å»ºâ€œæŒ–ç©ºâ€çš„è§†è§‰æ•ˆæœï¼Œè®©ç”¨æˆ·èšç„¦äºä¿ç•™åŒºåŸŸã€‚
* **è¡¥ç™½ (White/Padding)**:
    * **é€»è¾‘**: ä¿®æ”¹ `canvas.width` / `canvas.height`ï¼Œä¿æŒ `activeObject` (å›¾ç‰‡) å±…ä¸­ï¼Œå¹¶è®¾ç½® `canvas.backgroundColor`ã€‚

### 3.2 è‰²å½©æ»¤é•œæµæ°´çº¿
* **Filter Backend**: å¼ºåˆ¶å¼€å¯ `fabric.textureSize = 4096` ä»¥æ”¯æŒé«˜åˆ†å›¾ WebGL å¤„ç†ã€‚
* **æ»¤é•œæ ˆç®¡ç†**:
    * `AdjustColor` ä½¿ç”¨å›ºå®šçš„æ»¤é•œç´¢å¼• (å¦‚ index 0=Brightness, 1=Contrast)ï¼Œç¡®ä¿å¤šæ¬¡è°ƒèŠ‚æ»‘å—æ˜¯æ›´æ–°åŒä¸€ä¸ªæ»¤é•œå®ä¾‹ï¼Œè€Œä¸æ˜¯æ— é™å åŠ ã€‚
    * `AdjustColorOverlay` ç‹¬å ä¸€ä¸ª `BlendImage` æ»¤é•œå®ä¾‹ã€‚
    * çŠ¶æ€æ¢å¤æ—¶ï¼Œéœ€æ£€æŸ¥ `image.filters` æ•°ç»„å¹¶ååºåˆ—åŒ–å› UI æ§ä»¶æ•°å€¼ã€‚

### 3.3 æ™ºèƒ½æ¶ˆé™¤ç¬” (`useCanvasInpaint.js`)
* **é˜²æŠ–é€»è¾‘**: ç”»ç¬”æ¨¡å¼ä¸‹ï¼Œ`path:created` äº‹ä»¶è§¦å‘ `setTimeout(execute, 1000)`ã€‚å¦‚æœæœŸé—´äº§ç”Ÿæ–°è·¯å¾„ï¼Œæ¸…é™¤æ—§ Timerã€‚
* **å¿«ç…§æ¢å¤**: ä½¿ç”¨ `canvas.toJSON(['id', 'selectable', 'name'])` ä¿å­˜è½»é‡çº§å¿«ç…§ã€‚æ¢å¤æ—¶éœ€é‡æ–°åº”ç”¨é”å®šçŠ¶æ€ã€‚
* **é”å®šæœºåˆ¶**: è§ **ADR-005**ï¼Œé€šè¿‡éå†å¯¹è±¡è®¾ç½® `evented: false` å®ç°äº‹ä»¶ç©¿é€ã€‚

### 3.4 å‰ªè´´æ¿ä¸ç²˜è´´ç­–ç•¥ (Clipboard & Paste Strategy) `New!`
* **å•ä¾‹æ¨¡å¼ (Singleton)**: åºŸå¼ƒäº†å‡½æ•°å†…éƒ¨çš„å±€éƒ¨å˜é‡ï¼Œæ”¹ç”¨ `clipboardState` (Reactive Object) å­˜å‚¨å‰ªè´´æ¿æ•°æ®ã€‚
    * **ç›®çš„**: è§£å†³äº†è·¨ç»„ä»¶ï¼ˆå¦‚å³é”®èœå• vs å¿«æ·é”®ç›‘å¬å™¨ï¼‰è°ƒç”¨æ—¶æ•°æ®ä¸äº’é€šçš„é—®é¢˜ã€‚
* **åŒæ¨¡ç²˜è´´é€»è¾‘ (Dual Mode)**:
    * **å³é”®ç²˜è´´**: ä¼ å…¥ `pointer` åæ ‡ï¼Œå¼ºåˆ¶å¯¹è±¡ `left/top` ç­‰äºé¼ æ ‡ä½ç½® (Origin: Top-Left)ã€‚
    * **é”®ç›˜ç²˜è´´ (Ctrl+V)**: ä¸ä¼ åæ ‡ï¼Œé€»è¾‘è‡ªåŠ¨åº”ç”¨ `offset (+20px)`ï¼Œé˜²æ­¢æ–°å¯¹è±¡å®Œå…¨è¦†ç›–æ—§å¯¹è±¡ï¼Œç¬¦åˆæ¡Œé¢è½¯ä»¶ä¹ æƒ¯ã€‚

### 3.5 å¿«æ·é”®æ¶æ„ (Shortcut Architecture) `New!`
* **é˜²è¯¯è§¦**: åœ¨ `handleKeydown` ä¸­ä¸¥æ ¼æ£€æµ‹ `document.activeElement`ï¼Œè‹¥ä¸º `INPUT` æˆ– `TEXTAREA` åˆ™è‡ªåŠ¨é˜»æ–­å¿«æ·é”®è§¦å‘ã€‚
* **è¡Œä¸šæ ‡å‡†é”®ä½**:
    * **å›¾å±‚ç§»åŠ¨**: é‡‡ç”¨ Figma/PS æ ‡å‡†ï¼Œ`[` (ä¸‹ç§»)ã€`]` (ä¸Šç§»)ã€`Shift + [` (ç½®åº•)ã€`Shift + ]` (ç½®é¡¶)ã€‚
    * **é”å®š**: é‡‡ç”¨ `Ctrl + Shift + L`ï¼Œé¿å…ä¸æµè§ˆå™¨åœ°å€æ å¿«æ·é”®å†²çªã€‚
* **æ•°æ®æº**: `ShortcutsPanel` å’Œ `useKeyboardShortcuts` å…±äº«åŒä¸€ä»½ `config/shortcuts.js` é…ç½®ï¼Œç¡®ä¿æ–‡æ¡£ä¸è¡Œä¸ºæ°¸è¿œåŒæ­¥ã€‚

### 3.6 åæ ‡ç³»ä¸äº¤äº’äº‹ä»¶ (Coordinates & Events)
* **åæ ‡è·å– (Pointer Capture)**:
    * **åŸåˆ™**: å¿…é¡»ä½¿ç”¨ `canvas.getPointer(e)` è·å–é¼ æ ‡åæ ‡ã€‚
    * **åŸå› **: `e.clientX/Y` æ˜¯å±å¹•ç‰©ç†åæ ‡ï¼Œæ— æ³•å“åº” Canvas çš„ `setZoom` (ç¼©æ”¾) å’Œ `viewportTransform` (å¹³ç§»)ã€‚`getPointer` èƒ½è‡ªåŠ¨è½¬æ¢ä¸º Canvas å†…éƒ¨é€»è¾‘åæ ‡ã€‚
* **äº‹ä»¶ç›‘å¬ç”Ÿå‘½å‘¨æœŸ**:
    * **Zoom åŒæ­¥**: `fabricCanvas.on('zoom:change', updateZoomState)` å¿…é¡»åœ¨ `onUnmounted` ä¸­é€šè¿‡ `.off()` ç§»é™¤ï¼Œå¦åˆ™ç»„ä»¶é”€æ¯åä¼šå¯¼è‡´å†…å­˜æ³„æ¼æˆ–æ§åˆ¶å°æŠ¥é”™ã€‚
    * **èœå•éš”ç¦»**: `handleRightClick` ä¸­ä½¿ç”¨ `e.target.closest('.floating-wrapper')` åˆ¤æ–­ç‚¹å‡»æºï¼Œå®ç° UI å±‚çº§äº‹ä»¶è¿‡æ»¤ã€‚

---

## 4. ä¸‹ä¸€æ­¥è®¡åˆ’ (Next Steps)
### ğŸ“… é˜¶æ®µäºŒï¼šæ ‡å°ºæ ¸å¿ƒ (Ruler Core)
* [ ] `useCanvasRuler.js`: æ ‡å°ºå¯¹è±¡æ¨¡å‹ä¸ç»˜åˆ¶é€»è¾‘ã€‚
* [ ] `AdjustRuler.vue`: æ ‡å°ºé¢æ¿ä¸é¢„è®¾ç³»ç»Ÿã€‚

### ğŸ“… é˜¶æ®µä¸‰ï¼šå…¨å±€é›†æˆ (Global Integration)
* [ ] `useCanvas.js`: å…¨å±€æ™ºèƒ½è·³è½¬ä¾¦å¬å™¨ã€‚
* [ ] `NavBar.vue`: å…¨å±€æ ‡å°ºå¼€å…³ã€‚
</file>

<file path="src/api/ai.js">
// src/api/ai.js

// é»˜è®¤åœ°å€ (ä½œä¸ºå…œåº•ï¼Œé˜²æ­¢è°ƒç”¨æ—¶ä¼ ç©º)
const DEFAULT_BASE_URL = 'http://localhost:3000/ai';

export const aiApi = {
  /**
   * ç§»é™¤èƒŒæ™¯
   * @param {File} file - å›¾ç‰‡æ–‡ä»¶
   * @param {string} [baseUrl] - åç«¯ API åŸºç¡€åœ°å€
   * @returns {Promise<string>} - Blob URL
   */
  async removeBackground(file, baseUrl = DEFAULT_BASE_URL) {
    const formData = new FormData();
    formData.append('image', file);

    // æ‹¼æ¥å®Œæ•´çš„ URLï¼Œç§»é™¤æœ«å°¾å¯èƒ½å¤šä½™çš„æ–œæ 
    const cleanBaseUrl = baseUrl.replace(/\/+$/, '');

    try {
      const response = await fetch(`${cleanBaseUrl}/rembg`, {
        method: 'POST',
        body: formData,
        // fetch è‡ªåŠ¨å¤„ç† multipart/form-data çš„ Content-Typeï¼Œæ— éœ€æ‰‹åŠ¨è®¾ç½®
      });

      if (!response.ok) {
        throw new Error(`è¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
      }

      const blob = await response.blob();
      return URL.createObjectURL(blob);
    } catch (error) {
      console.error('AI API Error:', error);
      throw error;
    }
  },

  /**
   * å›¾åƒä¿®å¤ (Inpaint)
   * @param {Blob} imageBlob 
   * @param {Blob} maskBlob 
   * @param {string} [baseUrl] 
   */
  async inpaint(imageBlob, maskBlob, baseUrl = DEFAULT_BASE_URL) {
    const formData = new FormData();
    formData.append('image', imageBlob);
    formData.append('mask', maskBlob);

    const cleanBaseUrl = baseUrl.replace(/\/+$/, '');

    try {
      const response = await fetch(`${cleanBaseUrl}/inpaint`, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`è¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
      }

      const blob = await response.blob();
      return URL.createObjectURL(blob);
    } catch (error) {
      console.error('AI API Error:', error);
      throw error;
    }
  },

  /**
    * AI æ™ºèƒ½æ¶ˆé™¤æ¥å£
    * @param {string} imageUrl - åŸå›¾ URL
    * @param {string} maskBase64 - é®ç½©å›¾ç‰‡ Base64 (é»‘åº•ç™½å›¾)
    * @returns {Promise<string>} å¤„ç†åçš„å›¾ç‰‡ URL
    */
  async inpaint(imageUrl, maskBase64) {
    // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    return new Promise((resolve) => {
      console.log('Calling AI Inpaint API...');
      console.log('Image:', imageUrl.substring(0, 50) + '...');
      console.log('Mask Length:', maskBase64.length);

      setTimeout(() => {
        // âš ï¸ è¿™é‡Œç›®å‰ç›´æ¥è¿”å›åŸå›¾ï¼Œä»…åšæµç¨‹è·‘é€šæ¼”ç¤º
        // çœŸå®å¼€å‘è¯·æ›¿æ¢ä¸ºï¼š
        // const formData = new FormData();
        // formData.append('image', ...);
        // formData.append('mask', ...);
        // const res = await fetch('/api/inpaint', { ... });

        resolve(imageUrl);
      }, 2000);
    });
  }
};
</file>

<file path="src/components/modules/adjust/AdjustColor.vue">
<template>
    <div class="tool-group">
        <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
            <div class="left">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10" />
                    <path d="M12 2a10 10 0 0 0 0 20Z" />
                </svg>
                <span>è‰²å½©è°ƒèŠ‚</span>
            </div>
            <div class="right-icon">
                <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2">
                    <path d="m9 18 6-6-6-6" />
                </svg>
            </div>
        </div>

        <div v-if="isExpanded" class="tool-content">
            <div class="color-controls">
                <div v-for="item in config" :key="item.key" class="control-row">
                    <div class="label-box">
                        <span>{{ item.label }}</span>
                        <input type="number" v-model.number="values[item.key]" class="ie-input-number"
                            @input="updateFilters">
                    </div>
                    <input type="range" v-model.number="values[item.key]" :min="item.min" :max="item.max" step="1"
                        class="ie-slider" @input="updateFilters">
                </div>
            </div>

            <div class="action-buttons">
                <button class="ie-btn ie-primary full" @click="handleApply">ç¡®å®š</button>
                <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
</template>

<script setup>
import { reactive, inject, onMounted } from 'vue';
import { registerColorModule, applyColorAdjust, commitColorAdjust, cancelColorAdjust } from './useCanvasColor';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const values = reactive({
    blurSharpen: 0,
    saturation: 0,
    brightness: 0,
    contrast: 0,
    temperature: 0,
    hue: 0
});

const config = [
    { label: 'æ¨¡ç³Š / é”åŒ–', key: 'blurSharpen', min: -10, max: 10 },
    { label: 'é¥±å’Œåº¦', key: 'saturation', min: -100, max: 100 },
    { label: 'äº®åº¦', key: 'brightness', min: -10, max: 10 },
    { label: 'å¯¹æ¯”åº¦', key: 'contrast', min: -10, max: 10 },
    { label: 'è‰²æ¸©', key: 'temperature', min: -20, max: 20 },
    { label: 'è‰²è°ƒ', key: 'hue', min: -20, max: 20 },
];

const updateFilters = () => applyColorAdjust(values);
const handleToggle = () => emit('toggle');

const handleApply = () => {
    commitColorAdjust();
    emit('toggle');
};

const handleCancel = () => {
    cancelColorAdjust();
    emit('toggle');
};

onMounted(() => {
    if (canvasAPI?.canvas) {
        registerColorModule(canvasAPI.canvas, canvasAPI.saveHistory);
    }
});
</script>

<style scoped>
.color-controls {
    padding: 8px 0;
}

.control-row {
    margin-bottom: 16px;
}

.label-box {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
    font-size: 13px;
    color: #606266;
}

/* å·²ç§»é™¤å±€éƒ¨çš„ ie-small-input æ ·å¼ */

.ie-slider {
    width: 100%;
    height: 4px;
    background: #e4e7ed;
    border-radius: 2px;
    appearance: none;
    outline: none;
}

.ie-slider::-webkit-slider-thumb {
    appearance: none;
    width: 12px;
    height: 12px;
    background: #fff;
    border: 2px solid var(--ie-primary-color); /* ä¿®æ­£ä¸ºä¸»é¢˜è‰² */
    border-radius: 50%;
    cursor: pointer;
    transition: transform 0.2s;
}

.ie-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
}

.action-buttons {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.full {
    flex: 1;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustColorOverlay.vue">
<template>
    <div class="tool-group">
        <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
            <div class="left">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3-4-3-4-1 2.4-3 4-3 3.5-3 5.5a7 7 0 0 0 7 7Z"/>
                </svg>
                <span>é¢œè‰²å åŠ </span>
            </div>
            <div class="right-icon">
                <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="m9 18 6-6-6-6" />
                </svg>
            </div>
        </div>

        <div v-if="isExpanded" class="tool-content">
            <div class="section-label">é€‰æ‹©é¢œè‰²</div>
            <div class="color-presets">
                <div class="preset-item color-picker-wrapper" :class="{ active: isCustomActive }">
                    <input type="color" v-model="customColor" @input="handleCustomColorInput" class="native-color-picker">
                    <div class="rainbow-gradient"></div>
                </div>
                <div v-for="color in presets" :key="color" class="preset-item" :style="{ background: color }"
                    :class="{ active: selectedColor === color }" @click="selectColor(color)"></div>
                <div class="preset-item clear-item" :class="{ active: selectedColor === null }" @click="selectColor(null)">
                    <div class="slash-line"></div>
                </div>
            </div>

            <div class="intensity-section">
                <div class="label-row">
                    <span>å åŠ å¼ºåº¦</span>
                    <input type="number" v-model.number="intensity" class="ie-input-number" @input="updateOverlay">
                </div>
                <input type="range" v-model.number="intensity" min="0" max="100" class="ie-slider" @input="updateOverlay">
            </div>

            <div class="action-buttons">
                <button class="ie-btn ie-primary full" @click="handleConfirm">ç¡®å®š</button>
                <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
</template>

<script setup>
import { ref, inject, onMounted, computed, watch } from 'vue';
import { 
    registerColorOverlayModule, applyColorOverlay, commitColorOverlay, 
    backupCurrentColorOverlay, cancelColorOverlayChange 
} from './useCanvasColorOverlay';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const selectedColor = ref(null);
const customColor = ref('#ff0000');
const intensity = ref(30);
const presets = ['#000000', '#808080', '#ffffff'];

const isCustomActive = computed(() => selectedColor.value !== null && !presets.includes(selectedColor.value));

const selectColor = (color) => {
    selectedColor.value = color;
    updateOverlay();
};

const handleCustomColorInput = (e) => {
    selectedColor.value = e.target.value;
    updateOverlay();
};

const updateOverlay = () => {
    applyColorOverlay(selectedColor.value, intensity.value);
};

const handleConfirm = () => {
    commitColorOverlay();
    emit('toggle');
};

const handleCancel = () => {
    cancelColorOverlayChange();
    emit('toggle');
};

watch(() => props.isExpanded, (expanded) => {
    const canvas = canvasAPI?.canvas?.value;
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    
    if (expanded && bgImage) {
        selectedColor.value = bgImage._lastOverlayColor || null;
        intensity.value = bgImage._lastOverlayOpacity ?? 30;
        if (selectedColor.value && !presets.includes(selectedColor.value)) {
            customColor.value = selectedColor.value;
        }
        backupCurrentColorOverlay();
    }
});

onMounted(() => {
    if (canvasAPI?.canvas) {
        registerColorOverlayModule(canvasAPI.canvas, canvasAPI.saveHistory);
    }
});
</script>

<style scoped>
.section-label { font-size: 12px; color: #666; margin-bottom: 8px; }
.color-presets { display: flex; gap: 8px; margin-bottom: 20px; }
.preset-item { width: 36px; height: 20px; border-radius: 4px; border: 1px solid #ddd; cursor: pointer; position: relative; overflow: hidden; }
.preset-item.active { border-color: var(--ie-primary-color); border-width: 2px; }
.rainbow-gradient { width: 100%; height: 100%; background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red); }
.color-picker-wrapper { position: relative; }
.native-color-picker { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
.clear-item { background: #fff; }
.slash-line { position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: red; transform: rotate(-45deg); }
.intensity-section { margin-bottom: 16px; }
.label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 13px; color: #606266; }
/* å·²ç§»é™¤å±€éƒ¨çš„ input æ ·å¼ */
.action-buttons { display: flex; gap: 10px; margin-top: 16px; }
.full { flex: 1; }
</style>
</file>

<file path="src/components/modules/adjust/useCanvasInpaint.js">
import { ref, unref, watch } from 'vue';
import { fabric } from 'fabric';
import { aiApi } from '@/api/ai';
import { toast } from '@/utils/toast';
import { useEditorState } from '@/composables/useEditorState';

// === æ¨¡å—çº§å•ä¾‹çŠ¶æ€ ===
let canvasRef = null;
let saveHistoryFn = null;
let initialSnapshot = null; 
let autoInpaintTimer = null;
let isDragging = false;
let startPoint = null;
let activeRect = null;

// å“åº”å¼çŠ¶æ€
export const brushSize = ref(30);
export const drawMode = ref('brush'); 

// æ³¨å†Œæ¨¡å—
export const registerInpaintModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};

// === ğŸ”’ ç”»å¸ƒé”å®šç³»ç»Ÿ ===
const setObjectsLocked = (locked) => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const objects = canvas.getObjects();
    objects.forEach(obj => {
        if (obj.isMaskObject || obj.type === 'path') return; // è·³è¿‡é®ç½©å±‚

        if (locked) {
            obj._prevSelectable = obj.selectable;
            obj._prevEvented = obj.evented;
            obj.selectable = false;
            obj.evented = false; // è®©äº‹ä»¶ç©¿é€åº•å›¾
            obj.lockMovementX = true;
            obj.lockMovementY = true;
        } else {
            obj.selectable = obj._prevSelectable ?? true;
            obj.evented = obj._prevEvented ?? true;
            obj.lockMovementX = false;
            obj.lockMovementY = false;
        }
    });

    if (locked) {
        canvas.discardActiveObject();
        canvas.selection = false;
    } else {
        canvas.selection = true;
    }
    canvas.requestRenderAll();
};

// === ğŸ›  æ ¸å¿ƒä¿®å¤ï¼šç¦»å±ç”Ÿæˆé®ç½© (è§£å†³é—ªå±é—®é¢˜) ===
const getInpaintMaskOffscreen = async () => {
    const canvas = unref(canvasRef);
    if (!canvas) return null;

    // 1. ç­›é€‰å‡ºå±å¹•ä¸Šçš„çº¢çº¿æˆ–çº¢æ¡†
    const maskObjects = canvas.getObjects().filter(o => o.isMaskObject || o.type === 'path');
    if (maskObjects.length === 0) return null;

    // 2. åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ã€ä¸å¯è§çš„ç”»å¸ƒ (StaticCanvas)
    // å¤§å°ä¸ä¸»ç”»å¸ƒä¸€è‡´ï¼ŒèƒŒæ™¯è®¾ä¸ºé»‘è‰²
    const tempCanvas = new fabric.StaticCanvas(null, {
        width: canvas.width,
        height: canvas.height,
        backgroundColor: 'black' 
    });

    // 3. å…‹éš†é®ç½©å¯¹è±¡å¹¶â€œæ´—ç™½â€
    const clonePromises = maskObjects.map(obj => {
        return new Promise(resolve => {
            obj.clone((cloned) => {
                // å¼ºåˆ¶è®¾ä¸ºçº¯ç™½ï¼Œä¸é€æ˜
                cloned.set({
                    left: obj.left,
                    top: obj.top,
                    fill: 'white', 
                    stroke: 'white',
                    opacity: 1,
                    visible: true,
                    evented: false
                });

                // é’ˆå¯¹ç”»ç¬”(Path)å’Œæ¡†é€‰(Rect)åšå¾®è°ƒï¼Œç¡®ä¿æ˜¯å®å¿ƒç™½
                if (cloned.type === 'path') {
                    cloned.set({ fill: null, stroke: 'white' });
                } else if (cloned.type === 'rect') {
                    cloned.set({ fill: 'white', stroke: 'transparent' });
                }

                resolve(cloned);
            });
        });
    });

    // 4. å°†å…‹éš†ä½“æ·»åŠ åˆ°ä¸´æ—¶ç”»å¸ƒ
    const clones = await Promise.all(clonePromises);
    clones.forEach(c => tempCanvas.add(c));
    
    // 5. æ¸²æŸ“å¹¶å¯¼å‡º (è¿™ä¸€æ­¥å‘ç”Ÿåœ¨å†…å­˜ä¸­ï¼Œç”¨æˆ·çœ‹ä¸è§)
    tempCanvas.renderAll();
    const dataUrl = tempCanvas.toDataURL({ 
        format: 'png',
        multiplier: 1 
    });
    
    // 6. é”€æ¯ä¸´æ—¶ç”»å¸ƒé‡Šæ”¾å†…å­˜
    tempCanvas.dispose();
    
    return dataUrl;
};

// === è¿›å…¥/é€€å‡ºæ¨¡å— ===
export const enterInpaintMode = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    initialSnapshot = JSON.stringify(canvas.toJSON(['id', 'selectable', 'name']));
    setObjectsLocked(true); // é”å®šåº•å›¾
    drawMode.value = 'brush';
    enableBrush();
};

export const exitInpaintMode = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    if (autoInpaintTimer) clearTimeout(autoInpaintTimer);
    unbindEvents();
    
    canvas.isDrawingMode = false;
    setObjectsLocked(false); // è§£é”åº•å›¾
    clearMaskObjects();
    canvas.defaultCursor = 'default';
};

// === æ¨¡å¼åˆ‡æ¢ ===
const enableBrush = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    unbindEvents();
    canvas.isDrawingMode = true;
    
    const brush = new fabric.PencilBrush(canvas);
    brush.color = 'rgba(255, 0, 0, 0.5)';
    brush.width = brushSize.value;
    canvas.freeDrawingBrush = brush;
    
    canvas.on('path:created', onPathCreated);
};

const enableRect = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    canvas.isDrawingMode = false;
    unbindEvents();
    setObjectsLocked(true); 
    canvas.defaultCursor = 'crosshair';

    canvas.on('mouse:down', onRectDown);
    canvas.on('mouse:move', onRectMove);
    canvas.on('mouse:up', onRectUp);
};

// === äº‹ä»¶å¤„ç† ===
const onPathCreated = (opt) => {
    const path = opt.path;
    if (path) {
        path.excludeFromHistory = true; 
        path.isMaskObject = true;
    }
    // 1ç§’é˜²æŠ–
    if (autoInpaintTimer) clearTimeout(autoInpaintTimer);
    autoInpaintTimer = setTimeout(() => executeInpaint(), 1000);
};

const onRectDown = (opt) => {
    const canvas = unref(canvasRef);
    if (opt.target && !opt.target.isMaskObject) return;

    const pointer = canvas.getPointer(opt.e);
    isDragging = true;
    startPoint = { x: pointer.x, y: pointer.y };

    activeRect = new fabric.Rect({
        left: startPoint.x, top: startPoint.y,
        width: 0, height: 0,
        fill: 'rgba(255, 0, 0, 0.5)',
        stroke: 'transparent',
        selectable: false, evented: false,
        isMaskObject: true,
        excludeFromHistory: true
    });
    canvas.add(activeRect);
};

const onRectMove = (opt) => {
    if (!isDragging || !activeRect) return;
    const canvas = unref(canvasRef);
    const pointer = canvas.getPointer(opt.e);
    
    let w = Math.abs(pointer.x - startPoint.x);
    let h = Math.abs(pointer.y - startPoint.y);
    
    if (pointer.x < startPoint.x) activeRect.set({ left: pointer.x });
    if (pointer.y < startPoint.y) activeRect.set({ top: pointer.y });

    activeRect.set({ width: w, height: h });
    canvas.requestRenderAll();
};

const onRectUp = () => {
    isDragging = false;
    if (activeRect && (activeRect.width < 5 || activeRect.height < 5)) {
        unref(canvasRef).remove(activeRect);
    } else {
        executeInpaint(); // æ¾æ‰‹å³è§¦å‘
    }
    activeRect = null;
};

const unbindEvents = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;
    canvas.off('path:created', onPathCreated);
    canvas.off('mouse:down', onRectDown);
    canvas.off('mouse:move', onRectMove);
    canvas.off('mouse:up', onRectUp);
};

// === ğŸš€ æ ¸å¿ƒæ‰§è¡Œé€»è¾‘ ===
const executeInpaint = async () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    // 1. æ£€æŸ¥æ˜¯å¦æœ‰é®ç½©å†…å®¹
    const hasContent = canvas.getObjects().some(o => o.isMaskObject || o.type === 'path');
    if (!hasContent) return;

    const { setLoading } = useEditorState(); // è·å–å…¨å±€ Loading æ§åˆ¶

    try {
        setLoading(true, 'AI æ­£åœ¨æ¶ˆé™¤...'); // å¼€å¯ Loadingï¼Œé®ä½ç”»å¸ƒ
        
        // 2. å¯»æ‰¾åº•å›¾
        const activeObj = canvas.getObjects().find(o => o.type === 'image' && !o.isMaskObject);
        if (!activeObj) throw new Error('æœªæ‰¾åˆ°åº•å›¾');

        // 3. ã€æ–°é€»è¾‘ã€‘ä½¿ç”¨ç¦»å±æ¸²æŸ“è·å– Maskï¼Œä¸å†å¯¼è‡´ä¸»ç”»å¸ƒé—ªé»‘
        const maskBase64 = await getInpaintMaskOffscreen();
        if (!maskBase64) return;

        // 4. è°ƒç”¨ AI æ¥å£
        const resultUrl = await aiApi.inpaint(activeObj.getSrc(), maskBase64);
        
        if (resultUrl) {
            // 5. æˆåŠŸåæ›¿æ¢å›¾ç‰‡
            activeObj.setSrc(resultUrl, () => {
                clearMaskObjects(); // æ¸…é™¤çº¢çº¿
                setObjectsLocked(true); // é‡æ–°é”å®šæ–°å›¾ç‰‡
                
                if (saveHistoryFn) saveHistoryFn();
                toast.success('æ¶ˆé™¤å®Œæˆ');
                canvas.requestRenderAll();
                
                // å›¾ç‰‡åŠ è½½å®Œå†å…³é—­ Loadingï¼Œä½“éªŒæ›´å¹³æ»‘
                setLoading(false);
            }, { crossOrigin: 'anonymous' });
        } else {
            setLoading(false);
        }
    } catch (error) {
        console.error('Inpaint error:', error);
        toast.error('æ¶ˆé™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
        clearMaskObjects();
        setLoading(false);
    }
};

const clearMaskObjects = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;
    const masks = canvas.getObjects().filter(o => o.isMaskObject || o.type === 'path');
    canvas.remove(...masks);
    canvas.requestRenderAll();
};

// === æ¢å¤åŸå›¾ ===
export const handleRestoreOriginal = () => {
    const canvas = unref(canvasRef);
    if (!canvas || !initialSnapshot) return;

    canvas.loadFromJSON(initialSnapshot, () => {
        setObjectsLocked(true);
        if (drawMode.value === 'brush') enableBrush();
        else enableRect();
        
        if (saveHistoryFn) saveHistoryFn();
        toast.success('å·²æ¢å¤è‡³åˆå§‹çŠ¶æ€');
    });
};

watch(drawMode, (newMode) => {
    if (newMode === 'brush') enableBrush();
    else enableRect();
});

watch(brushSize, (val) => {
    const canvas = unref(canvasRef);
    if (canvas && canvas.freeDrawingBrush) {
        canvas.freeDrawingBrush.width = val;
    }
});
</file>

<file path="src/components/modules/puzzle/config.js">
// src/components/modules/puzzle/config.js

// =========================================================================
// 1. ç½‘æ ¼æ¨¡æ¿æ•°æ® - æŒ‰å›¾ç‰‡æ•°é‡åˆ†ç»„
// =========================================================================
export const gridTemplates = {
  1: [
    {
      id: '1-1',
      label: 'å…¨å±å•å›¾',
      wrapStyle: { 'grid-template-columns': '1fr', 'grid-template-rows': '1fr' },
      gridAreas: ['1 / 1 / 2 / 2'],
    }
  ],
  2: [
    {
      id: '2-1',
      label: 'å·¦å³å‡åˆ†',
      wrapStyle: { 'grid-template-columns': '1fr 1fr', 'grid-template-rows': '1fr' },
      gridAreas: ['1 / 1 / 2 / 2', '1 / 2 / 2 / 3'],
    },
    {
      id: '2-2',
      label: 'ä¸Šä¸‹å‡åˆ†',
      wrapStyle: { 'grid-template-columns': '1fr', 'grid-template-rows': '1fr 1fr' },
      gridAreas: ['1 / 1 / 2 / 2', '2 / 1 / 3 / 2'],
    },
    {
      id: '2-3',
      label: 'å·¦2å³1',
      wrapStyle: { 'grid-template-columns': '2fr 1fr', 'grid-template-rows': '1fr' },
      gridAreas: ['1 / 1 / 2 / 2', '1 / 2 / 2 / 3'],
    },
    {
      id: '2-4',
      label: 'ä¸Š2ä¸‹1',
      wrapStyle: { 'grid-template-columns': '1fr', 'grid-template-rows': '2fr 1fr' },
      gridAreas: ['1 / 1 / 2 / 2', '2 / 1 / 3 / 2'],
    }
  ],
  3: [
    {
      id: '3-1',
      label: 'ä¸‰åˆ—å‡åˆ†',
      wrapStyle: { 'grid-template-columns': '1fr 1fr 1fr', 'grid-template-rows': '1fr' },
      gridAreas: ['1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4'],
    },
    {
      id: '3-2',
      label: 'ä¸‰è¡Œå‡åˆ†',
      wrapStyle: { 'grid-template-columns': '1fr', 'grid-template-rows': '1fr 1fr 1fr' },
      gridAreas: ['1 / 1 / 2 / 2', '2 / 1 / 3 / 2', '3 / 1 / 4 / 2'],
    },
    {
      id: '3-3',
      label: 'å·¦ä¸»å³å‰¯',
      wrapStyle: { 'grid-template-columns': '2fr 1fr', 'grid-template-rows': '1fr 1fr' },
      gridAreas: ['1 / 1 / 3 / 2', '1 / 2 / 2 / 3', '2 / 2 / 3 / 3'],
    },
    {
      id: '3-4',
      label: 'ä¸Šä¸»ä¸‹å‰¯',
      wrapStyle: { 'grid-template-columns': '1fr 1fr', 'grid-template-rows': '2fr 1fr' },
      gridAreas: ['1 / 1 / 2 / 3', '2 / 1 / 3 / 2', '2 / 2 / 3 / 3'],
    }
  ],
  4: [
    {
      id: '4-1',
      label: 'ç”°å­—æ ¼',
      wrapStyle: { 'grid-template-columns': '1fr 1fr', 'grid-template-rows': '1fr 1fr' },
      gridAreas: ['1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '2 / 1 / 3 / 2', '2 / 2 / 3 / 3'],
    },
    {
      id: '4-2',
      label: 'å››åˆ—èƒ¶ç‰‡',
      wrapStyle: { 'grid-template-columns': '1fr 1fr 1fr 1fr', 'grid-template-rows': '1fr' },
      gridAreas: ['1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4', '1 / 4 / 2 / 5'],
    },
    {
      id: '4-3',
      label: 'å·¦ä¸€å³ä¸‰',
      wrapStyle: { 'grid-template-columns': '1.5fr 1fr', 'grid-template-rows': '1fr 1fr 1fr' },
      gridAreas: ['1 / 1 / 4 / 2', '1 / 2 / 2 / 3', '2 / 2 / 3 / 3', '3 / 2 / 4 / 3'],
    },
    {
      id: '4-4',
      label: 'ä¸Šä¸€ä¸‹ä¸‰',
      wrapStyle: { 'grid-template-columns': '1fr 1fr 1fr', 'grid-template-rows': '2fr 1fr' },
      gridAreas: ['1 / 1 / 2 / 4', '2 / 1 / 3 / 2', '2 / 2 / 3 / 3', '2 / 3 / 3 / 4'],
    },
    {
      id: '4-5',
      label: 'é”™ä½å¸ƒå±€',
      wrapStyle: { 'grid-template-columns': '1fr 1fr', 'grid-template-rows': '1fr 1fr 1fr' },
      gridAreas: ['1 / 1 / 2 / 2', '1 / 2 / 3 / 3', '2 / 1 / 4 / 2', '3 / 2 / 4 / 3'],
    }
  ],
  5: [
    {
      id: '5-1',
      label: 'ä¸ŠäºŒä¸‹ä¸‰',
      wrapStyle: { 'grid-template-columns': 'repeat(6, 1fr)', 'grid-template-rows': '1fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 4', '1 / 4 / 2 / 7',
        '2 / 1 / 3 / 3', '2 / 3 / 3 / 5', '2 / 5 / 3 / 7'
      ],
    },
    {
      id: '5-2',
      label: 'å·¦ä¸€å³å››',
      wrapStyle: { 'grid-template-columns': '1.5fr 1fr 1fr', 'grid-template-rows': '1fr 1fr' },
      gridAreas: [
        '1 / 1 / 3 / 2',
        '1 / 2 / 2 / 3', '1 / 3 / 2 / 4',
        '2 / 2 / 3 / 3', '2 / 3 / 3 / 4'
      ],
    },
    {
      id: '5-3',
      label: 'ä¸­å¿ƒç¯ç»•',
      wrapStyle: { 'grid-template-columns': '1fr 2fr 1fr', 'grid-template-rows': '1fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 2', '1 / 2 / 3 / 3', '1 / 3 / 2 / 4',
        '2 / 1 / 3 / 2', '2 / 3 / 3 / 4'
      ],
    },
    {
      id: '5-4',
      label: 'ç Œç –å¸ƒå±€',
      wrapStyle: { 'grid-template-columns': '1fr 1fr', 'grid-template-rows': '1fr 1fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 3',
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3',
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3'
      ]
    }
  ],
  6: [
    {
      id: '6-1',
      label: 'æ ‡å‡†2x3',
      wrapStyle: { 'grid-template-columns': 'repeat(3, 1fr)', 'grid-template-rows': '1fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4',
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3', '2 / 3 / 3 / 4'
      ],
    },
    {
      id: '6-2',
      label: 'æ ‡å‡†3x2',
      wrapStyle: { 'grid-template-columns': '1fr 1fr', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3',
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3',
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3'
      ],
    },
    {
      id: '6-3',
      label: 'å·¦å¤§å³ç¢',
      wrapStyle: { 'grid-template-columns': '2fr 1fr', 'grid-template-rows': 'repeat(5, 1fr)' },
      gridAreas: [
        '1 / 1 / 6 / 2',
        '1 / 2 / 2 / 3', '2 / 2 / 3 / 3', '3 / 2 / 4 / 3', '4 / 2 / 5 / 3', '5 / 2 / 6 / 3'
      ],
    },
    {
      id: '6-4',
      label: 'ä¸Šå¤§ä¸‹ç¢',
      wrapStyle: { 'grid-template-columns': 'repeat(5, 1fr)', 'grid-template-rows': '2fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 6',
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3', '2 / 3 / 3 / 4', '2 / 4 / 3 / 5', '2 / 5 / 3 / 6'
      ],
    }
  ],
  7: [
    {
      id: '7-1',
      label: 'ä¸Šä¸‰ä¸­å››',
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': 'repeat(2, 1fr)' },
      // ä¸ºäº†å¯¹é½ï¼Œä½¿ç”¨ 12 åˆ—ç½‘æ ¼ (3å’Œ4çš„å…¬å€æ•°)
      wrapStyle: { 'grid-template-columns': 'repeat(12, 1fr)', 'grid-template-rows': '1fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 5', '1 / 5 / 2 / 9', '1 / 9 / 2 / 13', // ä¸Š3 (æ¯æ ¼4åˆ—)
        '2 / 1 / 3 / 4', '2 / 4 / 3 / 7', '2 / 7 / 3 / 10', '2 / 10 / 3 / 13' // ä¸‹4 (æ¯æ ¼3åˆ—)
      ],
    },
    {
      id: '7-2',
      label: 'ä¸»å›¾ç¯ç»•',
      wrapStyle: { 'grid-template-columns': 'repeat(3, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        '1 / 1 / 3 / 3', // å·¦ä¸Šå¤§å›¾ 2x2
        '1 / 3 / 2 / 4', '2 / 3 / 3 / 4',
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3', '3 / 3 / 4 / 4',
        '2 / 2 / 2 / 2' // (ä¿®æ­£ï¼šè¡¥å……ç¼ºå£) -> ä¸‹é¢è¿™ç§å¸ƒå±€æ›´ç¨³
      ],
      // ä¿®æ­£ç‰ˆï¼šå·¦å¤§ + å³3 + ä¸‹3
      wrapStyle: { 'grid-template-columns': '2fr 1fr', 'grid-template-rows': 'repeat(6, 1fr)' },
      gridAreas: [
        '1 / 1 / 5 / 2', // å·¦å¤§
        '1 / 2 / 2 / 3', '2 / 2 / 3 / 3', '3 / 2 / 4 / 3', '4 / 2 / 5 / 3', // å³4
        '5 / 1 / 7 / 2', '5 / 2 / 7 / 3' // ä¸‹2? è¿™æ ·æ˜¯7å¼ 
      ],
      // ç®€å•ä¸”å¥½çœ‹çš„7å¼ ï¼š1å¤§ + 6å°
      wrapStyle: { 'grid-template-columns': 'repeat(3, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        '1 / 1 / 3 / 3', // å·¦ä¸Šå¤§å›¾ 2x2
        '1 / 3 / 2 / 4', // å³1
        '2 / 3 / 3 / 4', // å³2
        '3 / 1 / 4 / 2', // ä¸‹1
        '3 / 2 / 4 / 3', // ä¸‹2
        '3 / 3 / 4 / 4', // ä¸‹3
        // ç¼ºäº†ä¸€å¼ ? ä¸Šé¢åªæœ‰6å¼ ã€‚
        // é‡æ¥ï¼š3x3ç½‘æ ¼ï¼Œ1ä¸ªå 2x2(4æ ¼)ï¼Œå‰©ä¸‹5æ ¼æ”¾5å¼ ã€‚å…±6å¼ ã€‚
        // 7å¼ å›¾æ–¹æ¡ˆï¼šä¸Š1å¤§(å…¨å®½)ï¼Œä¸‹2è¡Œ3åˆ—
      ],
      wrapStyle: { 'grid-template-columns': 'repeat(3, 1fr)', 'grid-template-rows': '2fr 1fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 4', // ä¸Šå¤§
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3', '2 / 3 / 3 / 4',
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3', '3 / 3 / 4 / 4'
      ]
    },
    {
      id: '7-3',
      label: 'éå¯¹ç§°æ‹¼è´´',
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': 'repeat(4, 1fr)' },
      gridAreas: [
        '1 / 1 / 3 / 3', // å·¦ä¸Š 2x2
        '3 / 3 / 5 / 5', // å³ä¸‹ 2x2
        '1 / 3 / 2 / 5', // å³ä¸Šé•¿æ¡
        '2 / 3 / 3 / 5',
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3',
        '4 / 1 / 5 / 3'  // å·¦ä¸‹é•¿æ¡
      ]
    }
  ],
  8: [
    {
      id: '8-1',
      label: '4x2ç½‘æ ¼',
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': '1fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4', '1 / 4 / 2 / 5',
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3', '2 / 3 / 3 / 4', '2 / 4 / 3 / 5'
      ],
    },
    {
      id: '8-2',
      label: '2x4ç½‘æ ¼',
      wrapStyle: { 'grid-template-columns': '1fr 1fr', 'grid-template-rows': 'repeat(4, 1fr)' },
      gridAreas: [
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3',
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3',
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3',
        '4 / 1 / 5 / 2', '4 / 2 / 5 / 3'
      ],
    },
    {
      id: '8-3',
      label: 'åŒä¸»å›¾å¯¹è§’',
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        '1 / 1 / 3 / 3', // å·¦ä¸Šå¤§å›¾
        '2 / 3 / 4 / 5', // å³ä¸‹å¤§å›¾
        '1 / 3 / 2 / 4', '1 / 4 / 2 / 5',
        '2 / 3 / 3 / 4', '2 / 4 / 3 / 5', // è¿™é‡Œçš„2/3/4/5å…¶å®å°±æ˜¯å³ä¸‹å¤§å›¾
        // ä¿®æ­£ï¼š
        '1 / 3 / 2 / 4', '1 / 4 / 2 / 5', // å³ä¸Šä¸¤å¼ 
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3', // å·¦ä¸‹ä¸¤å¼ 
        '2 / 3 / 2 / 4', '2 / 4 / 2 / 5'  // è¡¥ä½? å¤æ‚äº†ï¼Œæ¢ç®€å•æ–¹æ¡ˆï¼š
      ],
      // 8å›¾æ–¹æ¡ˆï¼šä¸­é—´2å¤§ï¼Œä¸¤è¾¹å„3
      wrapStyle: { 'grid-template-columns': '1fr 2fr 1fr', 'grid-template-rows': '1fr 1fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 2', '2 / 1 / 3 / 2', '3 / 1 / 4 / 2', // å·¦3
        '1 / 2 / 2.5 / 3', '2.5 / 2 / 4 / 3', // ä¸­2 (æ¨ªå‘åˆ‡åˆ†? ä¸æ”¯æŒå°æ•°) -> æ”¹ä¸ºä¸Šä¸‹å„å 1.5
        // ä¿®æ­£ï¼šç”¨ 6è¡Œ
        '1 / 3 / 2 / 4', '2 / 3 / 3 / 4', '3 / 3 / 4 / 4'  // å³3
      ],
      // ç¨³å¦¥æ–¹æ¡ˆï¼šä¸Š3 ä¸­2 ä¸‹3
      wrapStyle: { 'grid-template-columns': 'repeat(6, 1fr)', 'grid-template-rows': '1fr 1.5fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 3', '1 / 3 / 2 / 5', '1 / 5 / 2 / 7', // ä¸Š3 (æ¯æ ¼2åˆ—)
        '2 / 1 / 3 / 4', '2 / 4 / 3 / 7',                  // ä¸­2 (æ¯æ ¼3åˆ—)
        '3 / 1 / 4 / 3', '3 / 3 / 4 / 5', '3 / 5 / 4 / 7'  // ä¸‹3 (æ¯æ ¼2åˆ—)
      ]
    }
  ],
  9: [
    {
      id: '9-1',
      label: 'ä¹å®«æ ¼',
      wrapStyle: { 'grid-template-columns': 'repeat(3, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4',
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3', '2 / 3 / 3 / 4',
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3', '3 / 3 / 4 / 4'
      ],
    },
    {
      id: '9-2',
      label: 'ä¸­å¿ƒèšç„¦',
      wrapStyle: { 'grid-template-columns': 'repeat(3, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4',
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3', '2 / 3 / 3 / 4',
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3', '3 / 3 / 4 / 4'
      ],
      // ä¿®æ­£ï¼š9å›¾å¸ƒå±€ï¼Œä¸­é—´å¤§å›¾ï¼Œå››å‘¨8å›¾ï¼Œéœ€è¦ 4x4 ç½‘æ ¼
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': 'repeat(4, 1fr)' },
      gridAreas: [
        '2 / 2 / 4 / 4', // ä¸­é—´å¤§å›¾ 2x2
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4', '1 / 4 / 2 / 5', // ä¸Š4
        '2 / 1 / 3 / 2', // å·¦ä¸­
        '2 / 4 / 3 / 5', // å³ä¸­
        '3 / 1 / 4 / 2', // å·¦ä¸‹
        '3 / 4 / 4 / 5', // å³ä¸‹
        // å“å‘€ï¼Œä¸‹é¢è¿˜ç¼ºä¸€è¡Œï¼Ÿ4x4æ˜¯16æ ¼ã€‚å¤§å›¾å 4æ ¼ï¼Œå‰©12æ ¼ã€‚æˆ‘ä»¬åªæœ‰8å¼ å°å›¾ã€‚
        // æ‰€ä»¥è¿™ä¸ªå¸ƒå±€æ˜¯ 9 å¼ å›¾ï¼Œä¸­é—´å¤§å›¾å  2x2ï¼Œå‘¨å›´éœ€è¦12æ ¼ï¼Ÿä¸å¯¹ã€‚
        // 3x3ç½‘æ ¼ï¼Œä¸­é—´å¤§å›¾å 1æ ¼ï¼Ÿé‚£å°±æ˜¯ä¹å®«æ ¼ã€‚
        // æ­£ç¡®çš„â€œä¸­å¿ƒå¤§å›¾+å‘¨å›´â€é€šå¸¸æ˜¯ 1å¤§8å° = 9å›¾ã€‚
        // å¸ƒå±€ï¼š3x3ï¼Œä¸­é—´æ ¼åˆ†è£‚ä¸º4å°æ ¼ï¼Ÿä¸ï¼Œæ˜¯åè¿‡æ¥ï¼š3x3ï¼Œå‘¨å›´æ ¼åˆ†è£‚ã€‚
        // æ–¹æ¡ˆï¼š4x4ç½‘æ ¼ã€‚ä¸­é—´ 2x2 å 4æ ¼ã€‚å‰©ä½™ 16-4 = 12 æ ¼ã€‚
        // å¦‚æœè¦æ”¾8å¼ å°å›¾ï¼Œæœ‰äº›å°å›¾è¦å  1.5æ ¼ï¼Ÿ
        // ç®€å•æ–¹æ¡ˆï¼š3è¡Œé”™ä½ã€‚
      ],
      wrapStyle: { 'grid-template-columns': 'repeat(6, 1fr)', 'grid-template-rows': 'repeat(6, 1fr)' },
      gridAreas: [
        '2 / 2 / 6 / 6', // ä¸­é—´æå¤§ 4x4
        '1 / 1 / 2 / 3', '1 / 3 / 2 / 5', '1 / 5 / 2 / 7', // ä¸Š3
        '2 / 1 / 4 / 2', // å·¦1
        '4 / 1 / 6 / 2', // å·¦2
        '2 / 6 / 4 / 7', // å³1
        '4 / 6 / 6 / 7', // å³2
        '6 / 1 / 7 / 4', // ä¸‹1
        '6 / 4 / 7 / 7'  // ä¸‹2
      ]
    }
  ],
  10: [
    {
      id: '10-1',
      label: '5x2å‡åˆ†',
      wrapStyle: { 'grid-template-columns': 'repeat(5, 1fr)', 'grid-template-rows': '1fr 1fr' },
      gridAreas: [
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4', '1 / 4 / 2 / 5', '1 / 5 / 2 / 6',
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3', '2 / 3 / 3 / 4', '2 / 4 / 3 / 5', '2 / 5 / 3 / 6'
      ]
    },
    {
      id: '10-2',
      label: '2x5å‡åˆ†',
      wrapStyle: { 'grid-template-columns': '1fr 1fr', 'grid-template-rows': 'repeat(5, 1fr)' },
      gridAreas: [
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3',
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3',
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3',
        '4 / 1 / 5 / 2', '4 / 2 / 5 / 3',
        '5 / 1 / 6 / 2', '5 / 2 / 6 / 3'
      ]
    },
    {
      id: '10-3',
      label: '4-3-3å¸ƒå±€',
      wrapStyle: { 'grid-template-columns': 'repeat(12, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        '1 / 1 / 2 / 4', '1 / 4 / 2 / 7', '1 / 7 / 2 / 10', '1 / 10 / 2 / 13', // ç¬¬ä¸€è¡Œ4å¼ 
        '2 / 1 / 3 / 5', '2 / 5 / 3 / 9', '2 / 9 / 3 / 13', // ç¬¬äºŒè¡Œ3å¼ 
        '3 / 1 / 4 / 5', '3 / 5 / 4 / 9', '3 / 9 / 4 / 13'  // ç¬¬ä¸‰è¡Œ3å¼ 
      ]
    }
  ],
  11: [
    {
      id: '11-1',
      label: '4-4-3å¸ƒå±€',
      wrapStyle: { 'grid-template-columns': 'repeat(12, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        '1 / 1 / 2 / 4', '1 / 4 / 2 / 7', '1 / 7 / 2 / 10', '1 / 10 / 2 / 13', // ä¸Š4
        '2 / 1 / 3 / 4', '2 / 4 / 3 / 7', '2 / 7 / 3 / 10', '2 / 10 / 3 / 13', // ä¸­4
        '3 / 1 / 4 / 5', '3 / 5 / 4 / 9', '3 / 9 / 4 / 13' // ä¸‹3
      ]
    },
    {
      id: '11-2',
      label: '3-4-4å¸ƒå±€',
      wrapStyle: { 'grid-template-columns': 'repeat(12, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        '1 / 1 / 2 / 5', '1 / 5 / 2 / 9', '1 / 9 / 2 / 13', // ä¸Š3
        '2 / 1 / 3 / 4', '2 / 4 / 3 / 7', '2 / 7 / 3 / 10', '2 / 10 / 3 / 13', // ä¸­4
        '3 / 1 / 4 / 4', '3 / 4 / 4 / 7', '3 / 7 / 4 / 10', '3 / 10 / 4 / 13'  // ä¸‹4
      ]
    }
  ],
  12: [
    {
      id: '12-1',
      label: '3x4ç½‘æ ¼',
      wrapStyle: { 'grid-template-columns': 'repeat(3, 1fr)', 'grid-template-rows': 'repeat(4, 1fr)' },
      gridAreas: Array.from({ length: 12 }, (_, i) => {
        const r = Math.floor(i / 3) + 1;
        const c = (i % 3) + 1;
        return `${r} / ${c} / ${r + 1} / ${c + 1}`;
      })
    },
    {
      id: '12-2',
      label: '4x3ç½‘æ ¼',
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: Array.from({ length: 12 }, (_, i) => {
        const r = Math.floor(i / 4) + 1;
        const c = (i % 4) + 1;
        return `${r} / ${c} / ${r + 1} / ${c + 1}`;
      })
    },
    {
      id: '12-3',
      label: 'ä¸­å¿ƒèšç„¦',
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4', '1 / 4 / 2 / 5', // ä¸Š4
        '2 / 1 / 3 / 2', /* ä¸­é—´ç©º2æ ¼ */  '2 / 4 / 3 / 5', // ä¸­2
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3', '3 / 3 / 4 / 4', '3 / 4 / 4 / 5', // ä¸‹4
        // è¡¥ä¸­é—´å¤§å›¾ (2x2)
        '2 / 2 / 3 / 4' // æ³¨æ„ï¼šè¿™é‡Œåªå äº†1è¡Œé«˜åº¦(Row 2)ï¼Œå®½åº¦å 2åˆ—ã€‚å¦‚æœæƒ³æ˜¯æ­£æ–¹å½¢å¤§å›¾éœ€è°ƒæ•´è¡Œé«˜
      ],
      // ä¿®æ­£ï¼š1å¤§ + 11å° = 12å›¾
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': 'repeat(4, 1fr)' },
      gridAreas: [
        '2 / 2 / 4 / 4', // ä¸­é—´å¤§å›¾ 2x2
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4', '1 / 4 / 2 / 5', // Row 1 (4)
        '2 / 1 / 3 / 2', '2 / 4 / 3 / 5', // Row 2 sides (2)
        '3 / 1 / 4 / 2', '3 / 4 / 4 / 5', // Row 3 sides (2)
        '4 / 1 / 5 / 2', '4 / 2 / 5 / 3', '4 / 3 / 5 / 4' // Row 4 (3, ç¼ºä¸€ä¸ªï¼Ÿ)
        // 4+2+2+3 = 11å°å›¾ã€‚æ­£å¥½ã€‚
      ]
    }
  ],
  13: [
    {
      id: '13-1',
      label: 'ä¸­å¿ƒå¤§å›¾+12',
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': 'repeat(4, 1fr)' },
      gridAreas: [
        '2 / 2 / 4 / 4', // ä¸­é—´å¤§å›¾ 2x2
        // å‘¨å›´ç¯ç»•12å¼ 
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4', '1 / 4 / 2 / 5',
        '2 / 1 / 3 / 2', '2 / 4 / 3 / 5',
        '3 / 1 / 4 / 2', '3 / 4 / 4 / 5',
        '4 / 1 / 5 / 2', '4 / 2 / 5 / 3', '4 / 3 / 5 / 4', '4 / 4 / 5 / 5'
      ]
    }
  ],
  14: [
    {
      id: '14-1',
      label: '5-5-4å¸ƒå±€',
      wrapStyle: { 'grid-template-columns': 'repeat(20, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: [
        // Row 1 (5å¼ ): 20/5 = 4
        '1/1/2/5', '1/5/2/9', '1/9/2/13', '1/13/2/17', '1/17/2/21',
        // Row 2 (5å¼ )
        '2/1/3/5', '2/5/3/9', '2/9/3/13', '2/13/3/17', '2/17/3/21',
        // Row 3 (4å¼ ): 20/4 = 5
        '3/1/4/6', '3/6/4/11', '3/11/4/16', '3/16/4/21'
      ]
    },
    {
      id: '14-2',
      label: 'å¯¹ç§°åŒå¤§å›¾',
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': 'repeat(4, 1fr)' },
      gridAreas: [
        '1 / 1 / 2 / 3', // å·¦ä¸Šå¤§å›¾ 2x1 (æ¨ªå‘)
        '1 / 3 / 2 / 5', // å³ä¸Šå¤§å›¾ 2x1 (æ¨ªå‘)
        '1 / 1 / 2 / 2', '1 / 2 / 2 / 3', '1 / 3 / 2 / 4', '1 / 4 / 2 / 5', // Row 1 (4)
        '2 / 1 / 3 / 2', '2 / 2 / 3 / 3', '2 / 3 / 3 / 4', '2 / 4 / 3 / 5', // Row 2 (4)
        '3 / 1 / 4 / 2', '3 / 2 / 4 / 3', '3 / 3 / 4 / 4', '3 / 4 / 4 / 5', // Row 3 (4)
        '4 / 1 / 5 / 3', // å·¦ä¸‹å¤§å›¾ 2x1
        '4 / 3 / 5 / 5'  // å³ä¸‹å¤§å›¾ 2x1
        // è¿™æ ·æ˜¯ 4+4+4+2 = 14å¼ ã€‚
      ]
    }
  ],
  15: [
    {
      id: '15-1',
      label: '3x5ç½‘æ ¼',
      wrapStyle: { 'grid-template-columns': 'repeat(3, 1fr)', 'grid-template-rows': 'repeat(5, 1fr)' },
      gridAreas: Array.from({ length: 15 }, (_, i) => {
        const r = Math.floor(i / 3) + 1;
        const c = (i % 3) + 1;
        return `${r} / ${c} / ${r + 1} / ${c + 1}`;
      })
    },
    {
      id: '15-2',
      label: '5x3ç½‘æ ¼',
      wrapStyle: { 'grid-template-columns': 'repeat(5, 1fr)', 'grid-template-rows': 'repeat(3, 1fr)' },
      gridAreas: Array.from({ length: 15 }, (_, i) => {
        const r = Math.floor(i / 5) + 1;
        const c = (i % 5) + 1;
        return `${r} / ${c} / ${r + 1} / ${c + 1}`;
      })
    }
  ],
  16: [
    {
      id: '16-1',
      label: '4x4æ ‡å‡†',
      wrapStyle: { 'grid-template-columns': 'repeat(4, 1fr)', 'grid-template-rows': 'repeat(4, 1fr)' },
      gridAreas: Array.from({ length: 16 }, (_, i) => {
        const r = Math.floor(i / 4) + 1;
        const c = (i % 4) + 1;
        return `${r} / ${c} / ${r + 1} / ${c + 1}`;
      })
    }
  ]
};

// 2. å›¾ç‰‡æ•°é‡ä¸‹æ‹‰ (æ‰©å±•è‡³16)
export const countOptions = [
  { value: 'all', label: 'å…¨éƒ¨' },
  ...Array.from({ length: 16 }, (_, i) => ({
    value: String(i + 1),
    label: `${i + 1}å¼ `
  }))
];

// =========================================================================
// 3. æ ¸å¿ƒå·¥å…·å‡½æ•°ï¼šç”Ÿæˆå’Œè§£æç½‘æ ¼
// =========================================================================

/**
 * åŠ¨æ€ç”Ÿæˆ NxM ç½‘æ ¼çš„å•å…ƒæ ¼æ•°æ®
 * @param {Number} rows è¡Œæ•°
 * @param {Number} cols åˆ—æ•°
 * @returns {Array} å•å…ƒæ ¼æ•°ç»„
 */
export const generateGridCells = (rows, cols) => {
  const cells = [];
  const w = 1 / cols;
  const h = 1 / rows;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      cells.push({
        index: r * cols + c,
        x: c * w,
        y: r * h,
        w: w,
        h: h
      });
    }
  }
  return cells;
};

/**
 * è§£æ CSS Grid Area æ¨¡æ¿ä¸ºç™¾åˆ†æ¯”åæ ‡
 * å…¼å®¹æ ¼å¼å¦‚: "1 / 1 / 2 / 2" (rowStart / colStart / rowEnd / colEnd)
 * @param {Object} tpl æ¨¡æ¿å¯¹è±¡
 */
export const parseTemplateToCells = (tpl) => {
  if (!tpl || !tpl.gridAreas) return [];

  let maxR = 1, maxC = 1;

  const getCountFromStyle = (styleStr) => {
    if (!styleStr) return 1;
    const repeatMatch = styleStr.match(/repeat\((\d+)/);
    if (repeatMatch) return parseInt(repeatMatch[1]);
    const spaceMatch = styleStr.trim().split(/\s+/);
    return spaceMatch.length;
  };

  if (tpl.wrapStyle) {
    maxC = Math.max(maxC, getCountFromStyle(tpl.wrapStyle['grid-template-columns']));
    maxR = Math.max(maxR, getCountFromStyle(tpl.wrapStyle['grid-template-rows']));
  }

  tpl.gridAreas.forEach(area => {
    const parts = area.split('/').map(s => parseInt(s.trim()));
    if (parts.length >= 4) {
      if (parts[2] - 1 > maxR) maxR = parts[2] - 1;
      if (parts[3] - 1 > maxC) maxC = parts[3] - 1;
    }
  });

  return tpl.gridAreas.map((area, index) => {
    const [r1, c1, r2, c2] = area.split('/').map(s => parseInt(s.trim()));
    const x = (c1 - 1) / maxC;
    const y = (r1 - 1) / maxR;
    const w = (c2 - c1) / maxC;
    const h = (r2 - r1) / maxR;

    return { index, x, y, w, h };
  });
};
</file>

<file path="src/main.js">
import { createApp } from 'vue'
import './style.css' // ç¡®ä¿è¿™é‡Œå¼•å…¥äº†æˆ‘ä»¬æ–°å†™çš„é€šç”¨ CSS (åŒ…å« .ie-btn ç­‰æ ·å¼)
import App from './App.vue'

// åœ¨çº¿è°ƒè¯•
import { useEditorState } from './composables/useEditorState'

window.useEditorState = useEditorState;


// 1. åˆ›å»º Vue å®ä¾‹
const app = createApp(App)

// 3. æŒ‚è½½
app.mount('#app')
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
# .vscode/*
# !.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
pnpm-lock.yaml
.vscode/settings.json
</file>

<file path="README.md">
## ä½¿ç”¨æ–¹æ³•

1. å®‰è£…
   npm install your-image-editor-pkg

2. å¼•å…¥æ ·å¼
   import 'your-image-editor-pkg/dist/style.css';

3. åœ¨ Vue ä¸­ä½¿ç”¨
   <template>
   <ImageEditor
   :image-url="currentImage"
   :config="{ aiBaseUrl: 'https://my-api.com' }"
   @save="onSave"
   />
   </template>

<script setup>
import { ImageEditor } from 'your-image-editor-pkg';

const onSave = (dataUrl) => {
  console.log('å›¾ç‰‡å·²ä¿å­˜', dataUrl);
}
</script>
</file>

<file path="src/components/modules/adjust/AdjustWhite.vue">
<template>
    <div class="tool-group">
        <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
            <div class="left">
                <svg width="18" height="18" viewBox="0 0 1024 1024" style="margin-right: 8px; fill: currentColor">
                    <path
                        d="M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32H96z m315.52-228.48l-68.928-114.88a32 32 0 0 0-54.784 0l-68.928 114.88L158.72 768h316.16l-60.16-100.48zM288 384a64 64 0 1 0 0-128 64 64 0 0 0 0 128z m261.12 216.96l-78.72-118.08a32 32 0 0 0-53.12 0l-78.72 118.08L483.2 697.6h126.72l-54.4-96.64z m208.64-106.88l-98.56-147.84a32 32 0 0 0-53.12 0l-98.56 147.84L652.8 697.6h209.92l-104.96-157.44z" />
                </svg>
                <span>å›¾ç‰‡è¡¥ç™½</span>
            </div>
            <div class="right-icon">
                <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="m9 18 6-6-6-6" />
                </svg>
            </div>
        </div>

        <div v-if="isExpanded" class="tool-content">

            <div class="preset-grid">
                <div class="preset-item custom-item" :class="{ active: isCustomMode }" @click="selectCustomMode">
                    <span>è‡ªå®šä¹‰</span>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="12" y1="8" x2="12" y2="16"></line>
                        <line x1="8" y1="12" x2="16" y2="12"></line>
                    </svg>
                </div>

                <div v-for="(preset, index) in presets" :key="index" class="preset-item"
                    :class="{ active: activePresetIndex === index }" @click="selectPreset(preset, index)">
                    <span class="preset-name">{{ preset.label }}</span>
                    <span class="preset-dim">{{ preset.w }}Ã—{{ preset.h }}</span>
                </div>
            </div>

            <div class="resize-input-box">
                <div class="input-controls">
                    <div class="input-wrapper">
                        <input type="number" v-model.number="width" class="ie-input" @change="onInputChanged('w')">
                        <span class="suffix">W</span>
                    </div>

                    <div class="link-icon-btn" @click="toggleAdaptive" :title="isAdaptive ? 'é”å®šæ¯”ä¾‹' : 'è‡ªç”±æ¯”ä¾‹'">
                        <svg v-if="isAdaptive" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#409eff"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                        </svg>
                        <svg v-else width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                            <line x1="4" y1="4" x2="20" y2="20" stroke="#999"></line>
                        </svg>
                    </div>

                    <div class="input-wrapper">
                        <input type="number" v-model.number="height" class="ie-input" @change="onInputChanged('h')">
                        <span class="suffix">H</span>
                    </div>
                </div>

                <div class="bg-color-section">
                    <div class="section-label">èƒŒæ™¯é¢œè‰²</div>
                    <div class="color-row">
                        <div class="color-item checkerboard" :class="{ active: currentBgColor === 'transparent' }"
                            @click="setBgColor('transparent')" title="é€æ˜"></div>
                        <div class="color-item" style="background: #ffffff; border: 1px solid #ddd;"
                            :class="{ active: currentBgColor === '#ffffff' }" @click="setBgColor('#ffffff')"></div>
                        <div class="color-item" style="background: #808080;"
                            :class="{ active: currentBgColor === '#808080' }" @click="setBgColor('#808080')"></div>
                        <div class="color-item" style="background: #000000;"
                            :class="{ active: currentBgColor === '#000000' }" @click="setBgColor('#000000')"></div>
                        <div class="color-item color-picker-wrap" :class="{ active: isCustomColor }">
                            <input type="color" v-model="customColorVal" @input="onCustomColorChange"
                                class="native-color-input" />
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path
                                    d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" />
                            </svg>
                        </div>
                    </div>
                </div>

            </div>

            <div class="action-buttons">
                <button class="ie-btn ie-primary full" @click="handleApply">åº”ç”¨ä¿®æ”¹</button>
                <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
            </div>

        </div>
    </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted, nextTick, computed } from 'vue';
// å¼•å…¥ä¿®æ”¹åçš„ useCanvasWhite
import { registerWhiteModule, getCurrentSize, applyWhitePadding, startPreview, updatePreview, stopPreview, zoomToPreview } from './useCanvasWhite';

const props = defineProps({
    isExpanded: { type: Boolean, default: false }
});

const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

// === çŠ¶æ€å®šä¹‰ ===
const width = ref(0);
const height = ref(0);
const isAdaptive = ref(false); // è¡¥ç™½æ¨¡å¼ä¸‹ï¼Œé»˜è®¤è‡ªç”±æ¯”ä¾‹
const originalRatio = ref(1);
const activePresetIndex = ref(-1);
const isInternalUpdate = ref(false);

// èƒŒæ™¯é¢œè‰²çŠ¶æ€
const currentBgColor = ref('#ffffff'); // é»˜è®¤ç™½è‰²
const customColorVal = ref('#ff0000');
const isCustomColor = computed(() => !['transparent', '#ffffff', '#808080', '#000000'].includes(currentBgColor.value));


// é¢„è®¾æ•°æ®
const presets = [
    { label: 'æ–¹å½¢ä¸»å›¾', w: 800, h: 800 },
    { label: 'Temuæœè£…å›¾', w: 1340, h: 1785 },
    { label: 'æ–¹å½¢ä¸»å›¾', w: 1000, h: 1000 },
    { label: 'ç«–å›¾ä¸»å›¾', w: 750, h: 1000 },
    { label: 'æ–¹å½¢ä¸»å›¾', w: 500, h: 500 },
    { label: 'ç«–å›¾ä¸»å›¾', w: 1000, h: 1200 },
    { label: 'Youtubeè§†é¢‘å°é¢', w: 1280, h: 720 },
    { label: 'Pinterestå¸–å­', w: 750, h: 1120 },
    { label: 'Facebookå°é¢', w: 851, h: 315 },
];

const isCustomMode = computed(() => activePresetIndex.value === -1);
const currentTargetRatio = computed(() => {
    if (activePresetIndex.value >= 0) {
        const p = presets[activePresetIndex.value];
        return p.h !== 0 ? (p.w / p.h) : 1;
    } else {
        return originalRatio.value;
    }
});

// === åˆå§‹åŒ– ===
const initSize = () => {
    if (canvasAPI && canvasAPI.canvas) {
        // ç¡®ä¿ä¼ å…¥äº† zoomToRect
        registerWhiteModule(canvasAPI.canvas, canvasAPI.saveHistory, canvasAPI.zoomToRect);

        const size = getCurrentSize();
        width.value = size.width;
        height.value = size.height;

        nextTick(() => {
            // ä»…å¼€å¯é¢„è§ˆæ¡†ï¼Œä¸ç§»åŠ¨ç›¸æœº
            startPreview(width.value, height.value, currentBgColor.value);
        });
    }
};


// === äº¤äº’é€»è¾‘ ===
const selectCustomMode = () => {
    activePresetIndex.value = -1;
    const size = getCurrentSize();
    width.value = size.width;
    height.value = size.height;
    updatePreviewBox();
};

const selectPreset = (preset, index) => {
    activePresetIndex.value = index;
    isInternalUpdate.value = true;
    width.value = preset.w;
    height.value = preset.h;

    nextTick(() => {
        isInternalUpdate.value = false;
        updatePreviewBox(); // å…ˆæ›´æ–°è“æ¡†å°ºå¯¸

        // âœ… è§¦å‘ç›¸æœºæ”¾å¤§ï¼šè®© 500*500 çš„æ¡†å æ®å½“åˆå›¾ç‰‡å æ®çš„å±å¹•èŒƒå›´
        zoomToPreview();
    });
};

const toggleAdaptive = () => {
    isAdaptive.value = !isAdaptive.value;
    if (isAdaptive.value && width.value > 0) {
        height.value = Math.round(width.value / currentTargetRatio.value);
        updatePreviewBox();
    }
};

// èƒŒæ™¯é¢œè‰²å¤„ç†
const setBgColor = (color) => {
    currentBgColor.value = color;
    updatePreviewBox();
};

const onCustomColorChange = (e) => {
    currentBgColor.value = e.target.value;
    updatePreviewBox();
};

// ç›‘å¬è¾“å…¥
watch([width, height], ([newW, newH]) => {
    if (isInternalUpdate.value) return;
    // å¦‚æœå¼€å¯äº†é”å®šæ¯”ä¾‹ (è¾“å…¥Wè‡ªåŠ¨ç®—H)
    if (isAdaptive.value) {
        // ç®€å•çš„é˜²æ­¢æ­»å¾ªç¯é€»è¾‘
        // å®é™…ä¸šåŠ¡ä¸­é€šå¸¸åªåœ¨ä¸€ä¸ªæ–¹å‘è¾“å…¥æ—¶è§¦å‘å¦ä¸€ä¸ªï¼Œè¿™é‡Œç®€åŒ–ä¸ºchangeè§¦å‘updatePreview
    }
    updatePreviewBox();
});

const onInputChanged = (type) => {
    // 1. å¦‚æœå¼€å¯äº†â€œé”å®šæ¯”ä¾‹â€ (isAdaptive) ä¸”æœ‰åŸå§‹æ¯”ä¾‹æ•°æ®
    if (isAdaptive.value && originalRatio.value) {

        // æ ‡è®°ä¸ºå†…éƒ¨æ›´æ–°ï¼Œé˜²æ­¢è§¦å‘ watch å¯¼è‡´æ­»å¾ªç¯æˆ–å¤šä½™è®¡ç®—
        isInternalUpdate.value = true;

        // æ ¹æ®è¾“å…¥çš„ç±»å‹è¿›è¡Œæ¢ç®—
        // originalRatio = å®½ / é«˜

        if (type === 'w' && width.value > 0) {
            // ç”¨æˆ·æ”¹äº†ã€å®½åº¦ã€‘ -> è‡ªåŠ¨ç®—ã€é«˜åº¦ã€‘
            // å…¬å¼: Height = Width / Ratio
            height.value = Math.round(width.value / originalRatio.value);

        } else if (type === 'h' && height.value > 0) {
            // ç”¨æˆ·æ”¹äº†ã€é«˜åº¦ã€‘ -> è‡ªåŠ¨ç®—ã€å®½åº¦ã€‘
            // å…¬å¼: Width = Height * Ratio
            width.value = Math.round(height.value * originalRatio.value);
        }

        // è®¡ç®—å¹¶èµ‹å€¼å®Œæˆåï¼Œåœ¨ä¸‹ä¸€ä¸ª tick é‡Šæ”¾é”
        nextTick(() => {
            isInternalUpdate.value = false;
        });
    }

    // 2. å®æ—¶æ›´æ–°ç”»å¸ƒä¸Šçš„é¢„è§ˆæ¡†
    updatePreviewBox();
};

const updatePreviewBox = () => {
    if (width.value > 0 && height.value > 0) {
        updatePreview(width.value, height.value, currentBgColor.value);
    } else {
        stopPreview();
    }
};

// ç›‘å¬é¢æ¿å±•å¼€
watch(() => props.isExpanded, (val) => {
    if (val) initSize();
    else stopPreview();
});

const handleApply = async () => {
    // 1. ç­‰å¾…å›¾ç‰‡å¤„ç†å®Œå…¨ç»“æŸ (æ–°å›¾ä¸Šå±ï¼ŒçŠ¶æ€é‡ç½®å®Œæˆ)
    await applyWhitePadding(width.value, height.value, currentBgColor.value);

    // 2. åªæœ‰å¤„ç†å®Œäº†ï¼Œæ‰é€šçŸ¥çˆ¶ç»„ä»¶å…³é—­é¢æ¿
    // æ­¤æ—¶ isExpanded å˜ false è§¦å‘ watcher é‡Œçš„ stopPreview
    // ä½†å› ä¸º originalTransform å·²ç»è¢«ç½®ç©ºï¼ŒstopPreview ä¸ä¼šäº§ç”Ÿä»»ä½•å‰¯ä½œç”¨
    emit('toggle');
};

const handleCancel = () => {
    stopPreview();
    emit('toggle');
}

const handleToggle = () => emit('toggle');

onMounted(() => {
    if (props.isExpanded) initSize();
});

onUnmounted(() => stopPreview());
</script>

<style scoped>
/* ç»§æ‰¿å¹¶å¤ç”¨äº†å¤§éƒ¨åˆ† AdjustResize çš„æ ·å¼ */
.preset-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 16px;
    max-height: 280px;
    overflow-y: auto;
}

.preset-item {
    background-color: #f5f7fa;
    padding: 10px;
    border-radius: 6px;
    font-size: 13px;
    color: #606266;
    cursor: pointer;
    border: 1px solid transparent;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    text-align: center;
    transition: all 0.2s;
}

.preset-item:hover {
    background-color: #e6f7ff;
    border-color: #c0c4cc;
}

.preset-item.active {
    background-color: #ecf5ff;
    color: #409eff;
    border-color: #409eff;
    font-weight: 500;
}

.custom-item {
    flex-direction: row;
    grid-column: span 2;
    background-color: #fff;
    border: 1px dashed #dcdfe6;
}

.custom-item.active {
    border-style: solid;
}

.preset-name {
    font-weight: 500;
    margin-bottom: 2px;
}

.preset-dim {
    font-size: 11px;
    color: #909399;
}

.resize-input-box {
    background-color: #fff;
    padding: 4px 0;
}

.input-controls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;
}

.input-wrapper {
    position: relative;
    width: 40%;
}

.ie-input {
    text-align: center;
    padding-right: 20px;
    font-weight: bold;
    color: #333;
    width: 100%;
    border: 1px solid #dcdfe6;
    border-radius: 4px;
    height: 32px;
    font-size: 13px;
}

.ie-input:focus {
    border-color: #409eff;
    outline: none;
}

.suffix {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    color: #c0c4cc;
    font-size: 11px;
    pointer-events: none;
}

.link-icon-btn {
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
}

.link-icon-btn:hover {
    background-color: #f0f0f0;
}

/* é¢œè‰²é€‰æ‹©å™¨æ ·å¼ */
.bg-color-section {
    margin-bottom: 16px;
}

.section-label {
    font-size: 12px;
    color: #606266;
    margin-bottom: 8px;
}

.color-row {
    display: flex;
    gap: 12px;
}

.color-item {
    width: 28px;
    height: 28px;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    border: 2px solid transparent;
    transition: all 0.2s;
}

.color-item.active {
    border-color: #409eff;
    transform: scale(1.1);
}

.checkerboard {
    background-image:
        linear-gradient(45deg, #ccc 25%, transparent 25%),
        linear-gradient(-45deg, #ccc 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #ccc 75%),
        linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 8px 8px;
    background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
    background-color: #fff;
}

.color-picker-wrap {
    background: linear-gradient(to bottom right, #ff0000, #00ff00, #0000ff);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    position: relative;
    overflow: hidden;
}

.native-color-input {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
}


.action-buttons {
    display: flex;
    gap: 10px;
}

.full {
    flex: 1;
}

.tool-item:hover .arrow {
    transform: translateX(2px);
    transition: transform 0.2s;
}

.tool-content {
    padding: 16px;
    border: 1px solid #eee;
    border-top: none;
}
</style>
</file>

<file path="src/components/modules/adjust/useCanvasWhite.js">
// [File: src/components/modules/adjust/useCanvasWhite.js]

import { ref, unref, shallowRef, toRaw } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let zoomToRectFn = null;
// === é¢„è§ˆç›¸å…³çŠ¶æ€ ===
const previewBgRect = shallowRef(null);
let originalSelectable = true;
let originalEvented = true;
let originalTransform = null;


export const registerWhiteModule = (canvas, saveHistory, zoomToRect) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
  zoomToRectFn = zoomToRect;
};


// æ–°å¢ï¼šæ‰‹åŠ¨è§¦å‘è§†è§’å¯¹é½çš„æ–¹æ³•
export const zoomToPreview = () => {
  const canvas = unref(canvasRef);
  // å¦‚æœ zoomToRectFn ä¸º nullï¼Œè¿™é‡Œå°±ä¼šç›´æ¥ returnï¼Œå¯¼è‡´æ²¡ååº”
  if (!canvas || !previewBgRect.value || !zoomToRectFn || !originalTransform) return;

  const rect = previewBgRect.value;

  // è®¡ç®—è¡¥ç™½æ¡†åœ¨ç”»å¸ƒä¸Šçš„é€»è¾‘çŸ©å½¢èŒƒå›´
  const logicRect = {
    left: rect.left - (rect.width * rect.scaleX) / 2,
    top: rect.top - (rect.height * rect.scaleY) / 2,
    width: rect.width * rect.scaleX,
    height: rect.height * rect.scaleY
  };

  // è°ƒç”¨ç›¸æœºç¼©æ”¾æ–¹æ³•
  zoomToRectFn(logicRect);
};





export const getCurrentSize = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return { width: 0, height: 0 };
  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (bgImage) {
    return {
      width: Math.round(bgImage.getScaledWidth()),
      height: Math.round(bgImage.getScaledHeight())
    };
  }
  return { width: canvas.width, height: canvas.height };
};

const restoreImageState = (bgImage) => {
  if (originalTransform && bgImage) {
    bgImage.set({
      scaleX: originalTransform.scaleX,
      scaleY: originalTransform.scaleY,
      left: originalTransform.left,
      top: originalTransform.top,
      width: originalTransform.width,
      height: originalTransform.height,
      angle: originalTransform.angle,
      originX: originalTransform.originX,
      originY: originalTransform.originY
    });
    bgImage.setCoords();
  }
};

export const startPreview = (targetW, targetH, bgColor = '#ffffff') => {
  const canvas = unref(canvasRef);
  if (!canvas || !targetW || !targetH) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  if (!originalTransform) {
    originalSelectable = bgImage.selectable;
    originalEvented = bgImage.evented;
    originalTransform = {
      scaleX: bgImage.scaleX,
      scaleY: bgImage.scaleY,
      left: bgImage.left,
      top: bgImage.top,
      width: bgImage.width,
      height: bgImage.height,
      angle: bgImage.angle,
      originX: bgImage.originX,
      originY: bgImage.originY
    };
  }

  if (previewBgRect.value) {
    canvas.remove(toRaw(previewBgRect.value));
    previewBgRect.value = null;
  }

  const imgW = originalTransform.width * originalTransform.scaleX;
  const imgH = originalTransform.height * originalTransform.scaleY;
  const scaleX = targetW / imgW;
  const scaleY = targetH / imgH;
  const fitScale = Math.min(scaleX, scaleY);

  // const canvasW = canvas.width;
  // const canvasH = canvas.height;
  // const center = canvas.getCenter();
  // const VIEW_FACTOR = 0.85;

  // const viewScale = Math.min(
  //   (canvasW * VIEW_FACTOR) / targetW,
  //   (canvasH * VIEW_FACTOR) / targetH
  // );
  const viewScale = 1;
  const center = canvas.getCenter();
  const rect = new fabric.Rect({
    width: targetW,
    height: targetH,
    left: center.left,
    top: center.top,
    originX: 'center',
    originY: 'center',
    fill: bgColor === 'transparent' ? 'transparent' : bgColor,
    stroke: '#409eff',
    strokeWidth: 2 / viewScale,
    selectable: false,
    evented: false,
    excludeFromExport: true,
    scaleX: viewScale,
    scaleY: viewScale
  });

  previewBgRect.value = rect;
  canvas.add(rect);
  canvas.sendToBack(rect);

  const finalScaleX = originalTransform.scaleX * fitScale * viewScale;
  const finalScaleY = originalTransform.scaleY * fitScale * viewScale;

  bgImage.set({
    scaleX: finalScaleX,
    scaleY: finalScaleY,
    left: center.left,
    top: center.top,
    originX: 'center',
    originY: 'center',
    selectable: false,
    evented: false
  });
  bgImage.setCoords();
  canvas.requestRenderAll();
};

export const updatePreview = (targetW, targetH, bgColor) => {
  startPreview(targetW, targetH, bgColor);
};

export const stopPreview = () => {
  const canvas = unref(canvasRef);
  if (canvas) {
    if (previewBgRect.value) {
      canvas.remove(toRaw(previewBgRect.value));
      previewBgRect.value = null;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (bgImage) {
      restoreImageState(bgImage);
      bgImage.selectable = originalSelectable;
      bgImage.evented = originalEvented;
    }
    canvas.discardActiveObject();
    originalTransform = null;
    canvas.requestRenderAll();
  }
};


// æ¯å¸¦é‡åˆ¶ (Source Remastering) åŸæ¸…æ™°åº¦
export const applyWhitePadding = (width, height, bgColor) => {
  return new Promise((resolve, reject) => {
    const canvas = unref(canvasRef);
    if (!canvas || !previewBgRect.value) {
      resolve();
      return;
    }

    const targetW = Math.round(width);
    const targetH = Math.round(height);
    if (targetW <= 0 || targetH <= 0) {
      resolve();
      return;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) {
      resolve();
      return;
    }

    // 1. è·å–åŸå›¾çš„åŸå§‹ Source URL (æœ€æ¸…æ™°çš„æ•°æ®æº)
    const originalSrc = bgImage.getSrc();

    // 2. æ•è·å½“å‰ç”»å¸ƒä¸Šçš„è§†è§‰çŠ¶æ€ (ç”¨äºæœ€åæ¢å¤è§†å›¾)
    const rect = previewBgRect.value;
    const targetVisualZoom = rect.scaleX;

    // 3. åœ¨å†…å­˜ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„ Fabric Image å¯¹è±¡ï¼ŒåŠ è½½åŸå§‹é«˜æ¸…å›¾
    fabric.Image.fromURL(originalSrc, (highResImg) => {

      // === æ ¸å¿ƒå·®å¼‚ï¼šåŸºäºåŸå§‹åˆ†è¾¨ç‡è®¡ç®— ===
      // highResImg.width / height æ˜¯å›¾ç‰‡æœ€åŸå§‹çš„åƒç´ å°ºå¯¸ (æ¯”å¦‚ 4000x3000)
      const originalW = highResImg.width;
      const originalH = highResImg.height;

      // è®¡ç®—é€‚åº”æ¯”ä¾‹ï¼šè®©åŸå›¾å®Œæ•´å¡è¿›ç›®æ ‡å°ºå¯¸ (Fit)
      // ä¾‹å¦‚ï¼šç›®æ ‡ 1000x222ï¼ŒåŸå›¾ 4000x3000
      // scale = min(1000/4000, 222/3000)
      const fitScale = Math.min(targetW / originalW, targetH / originalH);

      // 4. åˆ›å»ºé«˜æ¸…ç¦»å±ç”»å¸ƒ
      // è¿™é‡Œçš„ç­–ç•¥æ˜¯ï¼šå¦‚æœç›®æ ‡å°ºå¯¸å¾ˆå°(å¦‚1000px)ï¼Œæˆ‘ä»¬å¼ºåˆ¶æ”¾å¤§å¯¼å‡ºå°ºå¯¸ï¼Œä¿è¯Retinaå±æ¸…æ™°åº¦
      // è‡³å°‘ä¿è¯é•¿è¾¹æœ‰ 2500px ä»¥ä¸Šï¼Œæˆ–è€…æŒ‰ç›®æ ‡å°ºå¯¸çš„ 2-3 å€è¾“å‡º
      const outputMultiplier = Math.max(1, 3000 / Math.max(targetW, targetH)); // åŠ¨æ€è®¡ç®—å€ç‡

      const outputW = Math.round(targetW * outputMultiplier);
      const outputH = Math.round(targetH * outputMultiplier);

      const tempCanvas = new fabric.StaticCanvas(null, {
        width: outputW,
        height: outputH,
        backgroundColor: bgColor,
      });

      // 5. è®¾ç½®é«˜æ¸…å›¾åœ¨ç¦»å±ç”»å¸ƒä¸­çš„ä½ç½®
      highResImg.set({
        originX: 'center',
        originY: 'center',
        left: outputW / 2,
        top: outputH / 2,
        // å…³é”®ï¼šç¼©æ”¾ = é€‚åº”æ¯”ä¾‹ * è¾“å‡ºå€ç‡
        scaleX: fitScale * outputMultiplier,
        scaleY: fitScale * outputMultiplier,
        // ç»§æ‰¿åŸå›¾çš„è§’åº¦å’Œç¿»è½¬ï¼ˆå¦‚æœæœ‰ï¼‰
        angle: bgImage.angle,
        flipX: bgImage.flipX,
        flipY: bgImage.flipY
      });

      tempCanvas.add(highResImg);
      tempCanvas.renderAll();

      // 6. å¯¼å‡ºæœ€ç»ˆå›¾ç‰‡ (è¿™æ˜¯çœŸæ­£çš„é«˜æ¸…å›¾)
      const dataURL = tempCanvas.toDataURL({
        format: 'png',
        quality: 1
      });

      tempCanvas.dispose();

      // 7. åº”ç”¨å›ä¸»ç”»å¸ƒ
      bgImage.setSrc(dataURL, () => {
        // 1. æ¸…ç†é¢„è§ˆèµ„æº
        if (previewBgRect.value) {
          canvas.remove(toRaw(previewBgRect.value));
          previewBgRect.value = null;
        }
        originalTransform = null;

        // 2. æ¢å¤äº¤äº’çŠ¶æ€
        bgImage.selectable = originalSelectable;
        bgImage.evented = originalEvented;

        // === 3. æ ¸å¿ƒï¼šæ¸…æ™°åº¦è°ƒæ•´ (Source Remastering) ===
        // æ³¨æ„ï¼šè¿™æ®µé€»è¾‘ä¸èƒ½åˆ ã€‚é«˜æ¸…é‡åˆ¶å¯¼å‡ºäº†ç‰©ç†åƒç´ æé«˜çš„æ–°å›¾ (outputMultiplier)ï¼Œ
        // æˆ‘ä»¬éœ€è¦æŠŠå®ƒç¼©æ”¾åˆ°é€»è¾‘å°ºå¯¸ï¼Œå¦åˆ™å›¾ç‰‡ä¼šæ˜¾å¾—å¼‚å¸¸å·¨å¤§æˆ–æ¨¡ç³Šã€‚
        const displayScale = 1 / outputMultiplier;

        bgImage.set({
          scaleX: displayScale,
          scaleY: displayScale,
          angle: 0,
          flipX: false,
          flipY: false,
          originX: 'center',
          originY: 'center',
          left: 0,
          top: 0
        });

        // === 4. è§†å›¾å¤„ç† ===
        // æ ¹æ®ä½ çš„è¦æ±‚ï¼Œè¿™é‡Œæ³¨é‡Šæ‰äº†ä¼šå¼•èµ·è§†è§’è·³åŠ¨çš„é‡ç½®ä»£ç 
        // canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); // âŒ ä¸è¿›è¡Œè§†è§’å¤ä½

        // ä¹Ÿä¸ä½¿ç”¨ zoomToPoint è·³è½¬åˆ°é¢„è®¾è§†è·
        // canvas.zoomToPoint(new fabric.Point(canvas.width / 2, canvas.height / 2), targetVisualZoom); // âŒ ä¸æ”¹å˜å½“å‰ç¼©æ”¾æ¯”ä¾‹

        // 5. ä»…åœ¨å½“å‰è§†è§’ä¸‹å°†å›¾ç‰‡å±…ä¸­
        canvas.centerObject(bgImage);
        bgImage.setCoords();

        // 6. åˆ·æ–°ç”»å¸ƒå¹¶ä¿å­˜å†å²
        canvas.requestRenderAll();
        if (saveHistoryFn) saveHistoryFn();

        resolve();
      });
    }, { crossOrigin: 'anonymous' }); // ç¡®ä¿è·¨åŸŸå›¾ç‰‡èƒ½åŠ è½½
  });
};
</file>

<file path="src/components/panels/ToolPanel.vue">
<template>
  <div class="tool-panel">
    <component :is="currentModule" />

    <Modal v-model="showPuzzleConfirm" title="ä¿å­˜æ‹¼å›¾ä¿®æ”¹ï¼Ÿ" @confirm="handleConfirmExit(true)"
      @discard="handleConfirmExit(false)" @cancel="handleCancelExit">
      æ£€æµ‹åˆ°æ‚¨æ­£åœ¨æ‹¼å›¾æ¨¡å—ï¼Œç¦»å¼€å°†æ— æ³•å†æ¬¡è°ƒæ•´å½“å‰çš„æ ¼å­å¸ƒå±€ã€‚æ˜¯å¦å°†å½“å‰æ‹¼å›¾ç»“æœä¿å­˜ä¸ºä¸€å¼ æ–°å›¾ç‰‡ï¼Ÿ
    </Modal>
  </div>
</template>

<script setup>
import { computed, defineAsyncComponent, ref, watch, inject } from 'vue';
import { useEditorState } from '../../composables/useEditorState';
import Modal from '../common/Modal.vue';
import { completeExitPuzzle } from '../modules/puzzle/useCanvasPuzzle';

const { state, setActiveTool } = useEditorState();

// å†…éƒ¨é©±åŠ¨ UI çš„å·¥å…·çŠ¶æ€
const localActiveTool = ref(state.activeTool);
const showPuzzleConfirm = ref(false);
let pendingTool = null; // è®°å½•ç”¨æˆ·ç‚¹å‡»çš„ç›®æ ‡å·¥å…·
let isInternalSwitch = false; // é˜²æ­¢ watch å¾ªç¯è§¦å‘

// åŠ¨æ€æ˜ å°„è¡¨ä¿æŒä¸å˜
const modules = {
  adjust: defineAsyncComponent(() => import('../modules/adjust/index.vue')),
  draw: defineAsyncComponent(() => import('../modules/draw/index.vue')),
  text: defineAsyncComponent(() => import('../modules/text/index.vue')),
  border: defineAsyncComponent(() => import('../modules/border/index.vue')),
  material: defineAsyncComponent(() => import('../modules/material/index.vue')),
  watermark: defineAsyncComponent(() => import('../modules/watermark/index.vue')),
  puzzle: defineAsyncComponent(() => import('../modules/puzzle/index.vue')),
  ai: defineAsyncComponent(() => import('../modules/ai/index.vue')),
};

const currentModule = computed(() => {
  return modules[localActiveTool.value] || modules['adjust'];
});

// === æ ¸å¿ƒé€»è¾‘ï¼šæ‹¦æˆªåˆ‡æ¢ ===
watch(() => state.activeTool, (newTool, oldTool) => {
  if (isInternalSwitch) {
    isInternalSwitch = false;
    return;
  }

  // å¦‚æœä»æ‹¼å›¾æ¨¡å—åˆ‡å¾€åˆ«çš„æ¨¡å—
  if (oldTool === 'puzzle' && newTool !== 'puzzle') {
    pendingTool = newTool; // è®°ä½æƒ³å»çš„åœ°æ–¹
    showPuzzleConfirm.value = true; // å¼¹å‡ºæç¤º

    // å¼ºåˆ¶å°†å…¨å±€çŠ¶æ€é‡ç½®å› puzzleï¼Œè®©ä¾§è¾¹æ é«˜äº®ä¿æŒåœ¨æ‹¼å›¾ä¸Š
    isInternalSwitch = true;
    setActiveTool('puzzle');
  } else {
    // æ™®é€šåˆ‡æ¢ç›´æ¥åŒæ­¥
    localActiveTool.value = newTool;
  }
});

// å¤„ç†å¼¹çª—ç‚¹å‡»
const handleConfirmExit = (isSave) => {
  // è°ƒç”¨ useCanvasPuzzle æä¾›çš„æœ€ç»ˆé€€å‡ºå‡½æ•°
  completeExitPuzzle(isSave ? 'save' : 'discard');

  showPuzzleConfirm.value = false;

  if (pendingTool) {
    // ç¡®è®¤åï¼Œæ‰§è¡ŒçœŸæ­£çš„å…¨å±€è·³è½¬
    isInternalSwitch = true;
    setActiveTool(pendingTool);
    localActiveTool.value = pendingTool;
    pendingTool = null;
  }
};

const handleCancelExit = () => {
  showPuzzleConfirm.value = false;
  pendingTool = null;
};
</script>

<style scoped>
.tool-panel {
  background: #fff;
  border-right: 1px solid #e4e7ed;
  height: 100%;
  overflow-y: auto;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustRembg.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" @click="handleRembg">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
          <circle cx="6" cy="6" r="3" />
          <path d="M8.12 8.12 12 12" />
          <path d="M20 4 8.12 15.88" />
          <circle cx="6" cy="18" r="3" />
          <path d="M14.8 14.8 20 20" />
        </svg>
        <span>ä¸€é”®æŠ å›¾</span>
      </div>

      <div class="right-icon">
        <svg v-if="loading" class="loading-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 12a9 9 0 1 1-6.219-8.56" />
        </svg>
        <svg v-else class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, inject } from 'vue'; // ç¡®ä¿å¼•å…¥ inject
import { aiApi } from '@/api/ai';
import { toast } from '@/utils/toast';

const canvasAPI = inject('canvasAPI');
const config = inject('editorConfig'); // 1. è·å–å…¨å±€é…ç½®
const loading = ref(false);

const handleRembg = async () => {
  const activeObj = canvasAPI?.canvas.value?.getActiveObject();
  if (!activeObj || activeObj.type !== 'image') return toast.warning('è¯·å…ˆé€‰ä¸­å›¾ç‰‡');

  loading.value = true;
  try {
    const src = activeObj.getSrc();
    const blob = await (await fetch(src)).blob();

    // 2. è°ƒç”¨ API æ—¶ä¼ å…¥é…ç½®ä¸­çš„ baseUrl
    // å¦‚æœ config ä¸ºç©ºï¼ˆå•ç‹¬ä½¿ç”¨ç»„ä»¶æ—¶ï¼‰ï¼Œapi å†…éƒ¨ä¼šä½¿ç”¨é»˜è®¤å€¼
    const newUrl = await aiApi.removeBackground(
      new File([blob], "img.png"),
      config?.aiBaseUrl
    );

    canvasAPI.replaceActiveImage(newUrl);
    toast.success('æŠ å›¾å®Œæˆ');
  } catch (e) {
    console.error(e);
    toast.error('æŠ å›¾å¤±è´¥');
  } finally {
    loading.value = false;
  }
};
</script>

<style scoped>
/* Loading æ—‹è½¬åŠ¨ç”» */
.loading-icon {
  animation: rotating 1s linear infinite;
  color: #409eff;
}

@keyframes rotating {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}

/* ç®€å•çš„ hover åŠ¨ç”» */
.tool-item:hover .arrow {
  transform: translateX(2px);
  transition: transform 0.2s;
}
</style>
</file>

<file path="src/composables/useEditorState.js">
import { reactive, readonly } from 'vue';

// å•ä¾‹çŠ¶æ€ (æ›¿ä»£ State)
const state = reactive({
    activeTool: 'adjust', // å½“å‰æ¿€æ´»çš„å·¥å…·æ¨¡å—
    isDrawing: false,     // æ˜¯å¦å¤„äºç»˜åˆ¶æ¨¡å¼
    canUndo: false,       // æ˜¯å¦å¯æ’¤é”€
    canRedo: false,        // æ˜¯å¦å¯é‡åš
    isLoading: false,
    loadingText: 'å¤„ç†ä¸­...'
});

export function useEditorState() {
    // æ›¿ä»£ Actions
    const setActiveTool = (tool) => {
        state.activeTool = tool;
        state.isDrawing = false; // åˆ‡æ¢å·¥å…·æ—¶é€€å‡ºç»˜åˆ¶æ¨¡å¼
    };

    const toggleDrawing = (status) => {
        state.isDrawing = status;
    };

    const setHistoryState = (canUndo, canRedo) => {
        state.canUndo = canUndo;
        state.canRedo = canRedo;
    };

    // === æ–°å¢: Loading æ§åˆ¶ ===
    const setLoading = (status, text = 'å¤„ç†ä¸­...') => {
        state.isLoading = status;
        state.loadingText = text;
    };

    return {
        state: readonly(state), // åªè¯»çŠ¶æ€å¯¼å‡ºï¼Œé˜²æ­¢ç›´æ¥ä¿®æ”¹
        setActiveTool,
        toggleDrawing,
        setHistoryState,
        setLoading // å¯¼å‡º Action
    };
}

// å…¨å±€èšç„¦ç³»æ•°
export const ZOOM_PADDING = 0.921;
</file>

<file path="vite.config.js">
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import dts from 'vite-plugin-dts'
import { fileURLToPath, URL } from 'node:url'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    vue(),
    // 2. é…ç½®æ’ä»¶
    dts({
      outDir: 'dist',
      // ç¡®ä¿åªä¸ºæºç ç”Ÿæˆç±»å‹
      include: ['src/**/*.js', 'src/**/*.vue'],
      // è‡ªåŠ¨å°è¯•ç”Ÿæˆ vue æ–‡ä»¶çš„ç±»å‹å®šä¹‰
      // ç¡®ä¿ç”Ÿæˆçš„ .d.ts æ–‡ä»¶è·¯å¾„æ¸…æ™°
      insertTypesEntry: true,
    })
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  build: {
    lib: {
      entry: resolve(__dirname, 'src/index.js'),
      name: 'ImageEditor',
      fileName: 'image-editor'
    },
    rollupOptions: {
      external: ['vue'],
      output: {
        globals: {
          vue: 'Vue'
        },
        assetFileNames: (assetInfo) => {
          if (assetInfo.name === 'style.css') return 'index.css';
          return assetInfo.name;
        },
        exports: 'named'
      }
    },
    cssCodeSplit: false
  }
})
</file>

<file path="src/components/modules/adjust/AdjustInpaint.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34"></path>
          <polygon points="18 2 22 6 12 16 8 16 8 12 18 2"></polygon>
        </svg>
        <span>æ™ºèƒ½æ¶ˆé™¤ç¬”</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">
      
      <div class="mode-row">
        <div 
          class="mode-btn" 
          :class="{ active: drawMode === 'brush' }" 
          @click="drawMode = 'brush'" 
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 13.29C18 16.54 15.6 19 12 19s-6-2.46-6-5.71c0-2.83 2-6.29 6-9.29 4 3 6 6.46 6 9.29z"></path>
            <path d="M12 19v2"></path>
          </svg>
          <span class="mode-label">æ¶‚æŠ¹</span>
        </div>
        
        <div 
          class="mode-btn" 
          :class="{ active: drawMode === 'rect' }" 
          @click="drawMode = 'rect'" 
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          </svg>
          <span class="mode-label">æ¡†é€‰</span>
        </div>
      </div>

      <div class="control-section">
        <div v-if="drawMode === 'brush'">
          <div class="label-row">
            <span>ç”»ç¬”å¤§å°</span>
            <input 
              type="number" 
              v-model.number="brushSize" 
              class="ie-input-number"
              min="5"
              max="100"
            >
          </div>
          <input 
            type="range" 
            v-model.number="brushSize" 
            min="5" 
            max="100" 
            class="ie-slider"
          >
          <div class="auto-tip">
             ğŸ’¡ æ¶‚æŠ¹ç»“æŸ 1ç§’åè‡ªåŠ¨æ¶ˆé™¤
          </div>
        </div>

        <div v-else class="tips-box">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:4px; min-width:14px">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          </svg>
          <span>æ‹–æ‹½æ¡†é€‰ï¼Œæ¾æ‰‹åè‡ªåŠ¨æ¶ˆé™¤åŒºåŸŸå†…å®¹ã€‚</span>
        </div>
      </div>

      <div class="action-buttons">
        <button class="ie-btn full" @click="handleRestoreOriginal">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:6px">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
            <path d="M3 3v5h5"></path>
          </svg>
          æ¢å¤åŸå›¾
        </button>
      </div>

    </div>
  </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted } from 'vue';
import { 
  registerInpaintModule, 
  enterInpaintMode, 
  exitInpaintMode, 
  handleRestoreOriginal,
  brushSize, 
  drawMode 
} from './useCanvasInpaint';

const props = defineProps({
  isExpanded: Boolean
});

const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

onMounted(() => {
  if (canvasAPI?.canvas) {
    registerInpaintModule(canvasAPI.canvas, canvasAPI.saveHistory);
  }
});

watch(() => props.isExpanded, (expanded) => {
  if (expanded) {
    enterInpaintMode();
  } else {
    exitInpaintMode();
  }
});

onUnmounted(() => {
  exitInpaintMode();
});
</script>

<style scoped>
.mode-row { 
  display: flex; 
  gap: 12px; 
  margin-bottom: 20px; 
}

.mode-btn { 
  flex: 1; 
  height: 60px;
  display: flex; 
  flex-direction: column;
  align-items: center; 
  justify-content: center; 
  border-radius: 6px; 
  background: #f5f7fa; 
  cursor: pointer; 
  border: 1px solid transparent; 
  transition: all 0.2s; 
  color: #606266;
}

.mode-btn:hover {
  background: #eef1f6;
  color: #333;
}

.mode-btn.active { 
  background: #ecf5ff; 
  border-color: var(--ie-primary-color); 
  color: var(--ie-primary-color); 
  font-weight: 500;
}

.mode-label {
  font-size: 12px;
  margin-top: 4px;
}

.control-section {
  margin-bottom: 24px;
  min-height: 50px; 
}

.label-row { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; /* ç¡®ä¿å‚ç›´å¯¹é½ */
  font-size: 12px; 
  color: #606266; 
  margin-bottom: 8px; 
}

.tips-box {
  display: flex;
  align-items: flex-start;
  padding: 10px;
  background-color: #f4f4f5;
  border: 1px solid #e9e9eb;
  border-radius: 4px;
  font-size: 12px;
  color: #909399;
  line-height: 1.4;
}

.auto-tip {
  margin-top: 8px;
  font-size: 12px;
  color: var(--ie-primary-color); 
  text-align: center;
  background: #ecf5ff;
  padding: 4px;
  border-radius: 4px;
}

.action-buttons { 
  display: flex; 
  margin-top: auto;
}

.full { 
  flex: 1; 
  height: 36px;
}

.tool-content {
  padding: 16px;
}

/* === å¼ºåˆ¶ä¿®æ­£æ»‘å—ä¸»é¢˜è‰² === */
.ie-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--ie-primary-color);
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  margin-top: -6px;
}

.ie-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border: 2px solid white;
  border-radius: 50%;
  background: var(--ie-primary-color);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ie-slider::-webkit-slider-runnable-track {
  height: 4px;
  background: #e4e7ed;
  border-radius: 2px;
}
</style>
</file>

<file path="src/components/modules/puzzle/useCanvasPuzzle.js">
// src/components/modules/puzzle/useCanvasPuzzle.js
import { unref, reactive } from "vue";
import { fabric } from "fabric";
import { parseTemplateToCells, generateGridCells } from "./config";

// ã€å¼•å…¥é€šç”¨è§„èŒƒã€‘
import { constrainObjectToRect, animateRebound, getLogicRect } from '@/composables/useConstraint';

// === å†…éƒ¨å˜é‡ ===
let canvasRef = null;
let saveHistoryFn = null;
let uiCallbacks = { onCellClick: null };
let prePuzzleSnapshot = null;
// äº¤äº’çŠ¶æ€
let isDragging = false;
let dragOriginPoint = null;
let dragLastPoint = { x: 0, y: 0 };
let dragProxy = null;
let dragOriginCellIndex = -1;
let dragOffset = { x: 0, y: 0 };
let isCreatingProxy = false;

// é»˜è®¤é…ç½®
const DEFAULTS = {
  padding: 20,
  spacing: 10,
  radius: 0,
  width: 1000,
  height: 1000,
  bgColor: '#ffffff',
  rows: 1,
  cols: 1
};

const puzzleState = reactive({
  isActive: false,
  cells: [],
  padding: DEFAULTS.padding,
  spacing: DEFAULTS.spacing,
  radius: DEFAULTS.radius,
  width: DEFAULTS.width,
  height: DEFAULTS.height,
  bgColor: DEFAULTS.bgColor,
  startX: 0, // æ–°å¢ï¼šæ‹¼å›¾åŒºåŸŸçš„å·¦ä¸Šè§’é€»è¾‘åæ ‡
  startY: 0  // æ–°å¢
});

export const registerPuzzleModule = (canvas, saveHistory, callbacks = {}) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
  uiCallbacks = { ...uiCallbacks, ...callbacks };
};

export const initPuzzleMode = (initialTemplate = null) => {
  const canvas = unref(canvasRef);
  if (!canvas) return;
  prePuzzleSnapshot = JSON.stringify(canvas.toJSON(["id", "selectable", "name"]));
  if (puzzleState.savedHistoryData && puzzleState.savedHistoryData.length > 0) {
    restorePuzzleData();
    bindEvents();
    return;
  }

  puzzleState.isActive = true;

  // ã€ä¼˜åŒ–ã€‘è®¡ç®—æ‹¼å›¾åŒºåŸŸçš„ä½ç½®ï¼šä½¿å…¶ä¸åŸå›¾ä½ç½®é‡åˆæˆ–åœ¨ç”»å¸ƒä¸­å¿ƒ
  const activeImg = canvas.getObjects().find(o => o.type === 'image');
  if (activeImg) {
    const rect = activeImg.getBoundingRect();
    puzzleState.width = rect.width;
    puzzleState.height = rect.height;
    puzzleState.startX = rect.left;
    puzzleState.startY = rect.top;
  } else {
    // å¦‚æœæ²¡æœ‰åŸå›¾ï¼Œåˆ™åœ¨ç”»å¸ƒä¸­å¿ƒå¼€å¯ 1000x1000 çš„åŒºåŸŸ
    const center = canvas.getCenter();
    puzzleState.width = 1000;
    puzzleState.height = 1000;
    puzzleState.startX = center.left - 500;
    puzzleState.startY = center.top - 500;
  }

  bindEvents();

  const cells = initialTemplate ? parseTemplateToCells(initialTemplate) : generateGridCells(DEFAULTS.rows, DEFAULTS.cols);
  updateLayout(cells);

};

/**
 * å”¯ä¸€çš„ä¸šåŠ¡å‡ºå£å‡½æ•°
 * @param {string} action 'save' | 'discard'
 */
export const completeExitPuzzle = (action = 'save') => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  // è®°å½•è§†è§’ï¼Œé˜²æ­¢åˆ‡æ¢æ¨¡å—åç”»é¢â€œç¬ç§»â€
  const savedVpt = canvas.viewportTransform ? [...canvas.viewportTransform] : [1, 0, 0, 1, 0, 0];

  // å…ˆæ‰§è¡Œä¸€æ¬¡é€šç”¨é€€å‡ºæ¸…ç†
  exitPuzzleMode();

  if (action === 'save') {
    // --- ä¿å­˜é€»è¾‘ï¼šç”Ÿæˆå¹¶å›ºåŒ–å›¾ç‰‡ ---
    const auxObjs = canvas.getObjects().filter(o =>
      o.isPuzzleController || o.isDeleteBtn || o.isPlaceholder || o.isGhost
    );
    auxObjs.forEach(o => o.visible = false);

    canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
    canvas.renderAll();

    const dataURL = canvas.toDataURL({
      format: 'png', quality: 1, multiplier: 2,
      left: puzzleState.startX, top: puzzleState.startY,
      width: puzzleState.width, height: puzzleState.height
    });

    const allPuzzleObjs = canvas.getObjects().filter(o => o.isPuzzleItem);
    canvas.remove(...allPuzzleObjs);

    fabric.Image.fromURL(dataURL, (img) => {
      img.set({
        left: puzzleState.startX, top: puzzleState.startY,
        originX: 'left', originY: 'top',
        selectable: true
      });
      img.scaleToWidth(puzzleState.width);
      canvas.add(img);
      canvas.setViewportTransform(savedVpt);
      if (saveHistoryFn) saveHistoryFn();
      canvas.requestRenderAll();
    }, { crossOrigin: 'anonymous' });

  } else {
    // --- ã€ä¸ä¿å­˜é€»è¾‘ã€‘ç›´æ¥é€šè¿‡å¿«ç…§è¿˜åŸ ---
    if (prePuzzleSnapshot) {
      // loadFromJSON ä¼šè‡ªåŠ¨è°ƒç”¨ clear() æ¸…ç©ºå½“å‰æ‰€æœ‰ï¼ˆæ‹¼å›¾åçš„ï¼‰å›¾ç‰‡
      canvas.loadFromJSON(prePuzzleSnapshot, () => {
        canvas.setViewportTransform(savedVpt);
        canvas.requestRenderAll();
      });
    }
  }
};

// === æ¨¡å—çº§é‡ç½® ===
export const resetPuzzle = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  puzzleState.padding = DEFAULTS.padding;
  puzzleState.spacing = DEFAULTS.spacing;
  puzzleState.radius = DEFAULTS.radius;
  puzzleState.bgColor = DEFAULTS.bgColor;

  const defaultCells = generateGridCells(DEFAULTS.rows, DEFAULTS.cols);
  updateLayout(defaultCells);

  if (saveHistoryFn) saveHistoryFn();
};

// === é€€å‡ºé€»è¾‘ (æ ¸å¿ƒä¿®å¤ï¼šåªå¯¼å‡ºæœ‰æ•ˆåŒºåŸŸ) ===

export const exitPuzzleMode = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  puzzleState.isActive = false;
  unbindEvents(); // ä»…æ‰§è¡Œè§£ç»‘ï¼Œä¸æ“ä½œç”»å¸ƒå¯¹è±¡
};

// === ä¿®æ”¹åçš„è¾…åŠ©å‡½æ•°ï¼šæ™ºèƒ½é€‚é…å±å¹• ===
const fitPuzzleToScreen = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  const { width: puzzleW, height: puzzleH } = puzzleState;
  // æ³¨æ„ï¼šè¿™é‡Œç”¨ width / zoom æ¢ç®—å›é€»è¾‘åƒç´ ï¼Œç¡®ä¿å¯¹æ¯”å•ä½ä¸€è‡´
  const canvasW = canvas.width / canvas.getRetinaScaling();
  const canvasH = canvas.height / canvas.getRetinaScaling();

  // 1. è®¡ç®—æœ€ä½³é€‚é… Zoom (ç•™å‡º 10% è¾¹è·)
  const paddingFactor = 0.9;
  const zoomX = (canvasW * paddingFactor) / puzzleW;
  const zoomY = (canvasH * paddingFactor) / puzzleH;

  // ç®—å‡ºâ€œèƒ½å®Œå…¨æ”¾ä¸‹æ‹¼å›¾â€çš„ç¼©æ”¾å€¼
  let targetZoom = Math.min(zoomX, zoomY);

  // 2. ã€æ ¸å¿ƒä¿®æ”¹ã€‘æ™ºèƒ½é˜ˆå€¼å¤„ç†
  // å¦‚æœè®¡ç®—å‡ºçš„ç¼©æ”¾æ¯”ä¾‹å¤§äº 0.9 (è¯´æ˜å›¾ç‰‡å…¶å®è·Ÿå±å¹•å·®ä¸å¤šå¤§ï¼Œæˆ–è€…æ¯”å±å¹•å°)
  // æˆ‘ä»¬å°±å¼ºåˆ¶è®¾ä¸º 1 (100%)ï¼Œä¿è¯ç”»è´¨æ¸…æ™°åº¦ï¼Œåªæœ‰å›¾ç‰¹åˆ«å¤§æ—¶æ‰ç¼©å°
  if (targetZoom > 0.9) {
    targetZoom = 1;
  }

  // 3. åº”ç”¨ç¼©æ”¾
  canvas.setZoom(targetZoom);

  // 4. è®¡ç®— Pan (è®©æ‹¼å›¾ä¸­å¿ƒ å¯¹é½ è§†å£ä¸­å¿ƒ)
  const puzzleCenterX = puzzleW / 2;
  const puzzleCenterY = puzzleH / 2;

  // è§†å£åœ¨å½“å‰ç¼©æ”¾ä¸‹çš„é€»è¾‘ä¸€åŠå®½é«˜
  const viewportHalfW = canvasW / (2 * targetZoom);
  const viewportHalfH = canvasH / (2 * targetZoom);

  const panX = puzzleCenterX - viewportHalfW;
  const panY = puzzleCenterY - viewportHalfH;

  canvas.absolutePan({ x: panX, y: panY });
  canvas.requestRenderAll();

  // åŒæ­¥å¤–éƒ¨ UI æ˜¾ç¤º
  canvas.fire('zoom:change', { zoom: targetZoom });
};


// å½“ç”¨æˆ·ç‚¹å‡»â€œå†æ¬¡ç¼–è¾‘â€æˆ–åˆ‡æ¢å›æ‹¼å›¾æ¨¡å—æ—¶è°ƒç”¨
export const restorePuzzleData = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  // 1. æ¸…ç†é¢„è§ˆå›¾
  const previewImg = canvas.getObjects().find(o => o.isPreviewSnapshot);
  if (previewImg) {
    canvas.remove(previewImg);
  }

  // 2. è·å–å­˜æ¡£æ•°æ®
  const historyData = puzzleState.savedHistoryData;
  // ã€æ–°å¢ã€‘æ¢å¤ä¹‹å‰çš„æ‹¼å›¾å°ºå¯¸è®¾ç½®
  const savedSettings = puzzleState.savedSettings;

  if (!historyData || historyData.length === 0) return;

  // ã€æ–°å¢ã€‘æ¢å¤å°ºå¯¸çŠ¶æ€
  if (savedSettings) {
    puzzleState.width = savedSettings.width;
    puzzleState.height = savedSettings.height;
    puzzleState.padding = savedSettings.padding;
    puzzleState.spacing = savedSettings.spacing;
    puzzleState.radius = savedSettings.radius;
    if (savedSettings.bgColor) {
      puzzleState.bgColor = savedSettings.bgColor;
      canvas.setBackgroundColor(savedSettings.bgColor, () => { });
    }
  }

  // 3. å¼‚æ­¥æ¢å¤å›¾ç‰‡
  let loadedCount = 0;
  // æ ‡è®° loading çŠ¶æ€ï¼ˆå¦‚æœä½ çš„ UI æœ‰ loading é®ç½©å¯ä»¥åœ¨è¿™å¼€å¯ï¼‰

  historyData.forEach(item => {
    fabric.Image.fromURL(item.src, (img) => {
      loadedCount++;

      img.set({
        id: item.id,
        left: item.left,
        top: item.top,
        scaleX: item.scaleX,
        scaleY: item.scaleY,
        angle: item.angle,
        flipX: item.flipX,
        flipY: item.flipY,
        cropX: item.cropX,
        cropY: item.cropY,
        originX: item.originX || 'center', // ç¡®ä¿é”šç‚¹æ­£ç¡®
        originY: item.originY || 'center',
        cellIndex: item.cellIndex,
        isPuzzleItem: true,
        isPuzzleImage: true,
        originalSrc: item.src,
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
      });

      canvas.add(img);

      // å½“æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæ¯•æ—¶
      if (loadedCount === historyData.length) {
        puzzleState.isActive = true;
        refreshPuzzleObjects(false);

        // ã€å…³é”®ä¿®å¤ã€‘æ‰€æœ‰å…ƒç´ å°±ä½åï¼Œæ‰§è¡Œä¸€æ¬¡é•œå¤´å¯¹é½ï¼
        // fitPuzzleToScreen();

        canvas.requestRenderAll();
      }
    }, { crossOrigin: 'anonymous' });
  });
};
// =========================================================================
// æ ¸å¿ƒé€»è¾‘ï¼šä½ç½®è®¡ç®— (ä¿ç•™ç”¨äºåˆå§‹é€‚é…)
// æ³¨æ„ï¼šè™½ç„¶ animateRebound èƒ½å¤„ç†å›å¼¹ï¼Œä½†â€œåˆå§‹æ”¾å…¥â€æ—¶çš„å±…ä¸­é€»è¾‘è¿˜æ˜¯éœ€è¦çš„
// =========================================================================
const calculateFitPosition = (img, cell) => {
  // è¿™é‡Œçš„é€»è¾‘æ˜¯â€œCoverâ€æ¨¡å¼ï¼šç¡®ä¿å›¾ç‰‡å¡«æ»¡æ ¼å­ä¸”å±…ä¸­
  const minScaleX = cell.width / img.width;
  const minScaleY = cell.height / img.height;
  const minScale = Math.max(minScaleX, minScaleY) + 0.0001;
  return {
    scaleX: minScale,
    scaleY: minScale,
    left: cell.left + cell.width / 2,
    top: cell.top + cell.height / 2
  };
};

// === äº‹ä»¶ç»‘å®š ===
const bindEvents = () => {
  const canvas = unref(canvasRef);
  canvas.on('mouse:down', onMouseDown);
  canvas.on('mouse:move', onMouseMove);
  canvas.on('mouse:up', onMouseUp);
  canvas.on('mouse:wheel', onMouseWheel);
};

const unbindEvents = () => {
  const canvas = unref(canvasRef);
  canvas.off('mouse:down', onMouseDown);
  canvas.off('mouse:move', onMouseMove);
  canvas.off('mouse:up', onMouseUp);
  canvas.off('mouse:wheel', onMouseWheel);
};

const onMouseDown = (opt) => {
  if (!puzzleState.isActive) return;
  const canvas = unref(canvasRef);
  const target = opt.target;

  dragOriginPoint = opt.absolutePointer;
  const pointer = canvas.getPointer(opt.e);
  dragLastPoint = { x: pointer.x, y: pointer.y };

  if (target && target.isDeleteBtn) {
    deleteImageFromCell(target.cellIndex);
    isDragging = false;
    dragOriginCellIndex = -1;
    dragOriginPoint = null;
    return;
  }

  if (target && target.isPuzzleController) {
    isDragging = true;
    dragOriginCellIndex = target.cellIndex;
    canvas.setActiveObject(target);

    const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === target.cellIndex);
    if (img) {
      dragOffset = {
        x: img.left - pointer.x,
        y: img.top - pointer.y
      };
    } else {
      dragOffset = { x: 0, y: 0 };
    }

  } else {
    isDragging = false;
    dragOriginCellIndex = -1;
  }
};

const onMouseMove = (opt) => {
  if (!puzzleState.isActive || !isDragging || dragOriginCellIndex === -1) return;
  const canvas = unref(canvasRef);
  const pointer = canvas.getPointer(opt.e);
  const distFromStart = Math.sqrt(
    Math.pow(pointer.x - (dragOriginPoint?.x || 0), 2) +
    Math.pow(pointer.y - (dragOriginPoint?.y || 0), 2)
  );

  if (distFromStart < 5) return;

  const cell = puzzleState.cells.find(c => c.index === dragOriginCellIndex);
  if (!cell) return;

  const isInsideCell =
    pointer.x >= cell.left && pointer.x <= cell.left + cell.width &&
    pointer.y >= cell.top && pointer.y <= cell.top + cell.height;

  if (isInsideCell) {
    // åœºæ™¯Aï¼šåœ¨æ ¼å­å†…éƒ¨å¾®è°ƒï¼ˆPanï¼‰
    if (dragProxy) {
      canvas.remove(dragProxy);
      dragProxy = null;
      isCreatingProxy = false;
      const originImg = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === dragOriginCellIndex);
      if (originImg) originImg.set('opacity', 1);
    }
    const deltaX = pointer.x - dragLastPoint.x;
    const deltaY = pointer.y - dragLastPoint.y;
    const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === dragOriginCellIndex);
    if (img) {
      // è‡ªç”±æ‹–åŠ¨ï¼Œä¸åšå®æ—¶çº¦æŸï¼Œæ¾æ‰‹æ—¶å†å›å¼¹
      img.set({ left: img.left + deltaX, top: img.top + deltaY });
      img.setCoords();
    }
  } else {
    // åœºæ™¯Bï¼šæ‹–å‡ºæ ¼å­ï¼ˆå‡†å¤‡äº¤æ¢ï¼‰
    if (!dragProxy && !isCreatingProxy) {
      isCreatingProxy = true;
      createDragProxy(dragOriginCellIndex, pointer);
    }

    if (dragProxy) {
      dragProxy.set({
        left: pointer.x + dragOffset.x,
        top: pointer.y + dragOffset.y
      });
      dragProxy.setCoords();
    }
  }
  dragLastPoint = { x: pointer.x, y: pointer.y };
  canvas.requestRenderAll();
};

const createDragProxy = (cellIndex, pointer) => {
  const canvas = unref(canvasRef);
  const cell = puzzleState.cells.find(c => c.index === cellIndex);
  const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === cellIndex);

  if (!cell || !img) {
    isCreatingProxy = false;
    return;
  }

  img.set('opacity', 0.4);

  img.clone((cloned) => {
    dragProxy = cloned;

    if (pointer) {
      dragOffset = {
        x: img.left - pointer.x,
        y: img.top - pointer.y
      };
    }

    dragProxy.set({
      opacity: 0.8, evented: false, selectable: false,
      originX: 'center', originY: 'center',
      left: pointer ? pointer.x + dragOffset.x : img.left,
      top: pointer ? pointer.y + dragOffset.y : img.top,
      hasControls: false, hasBorders: false,
      stroke: '#409eff', strokeWidth: 2,
      isPuzzleImage: true,
      isGhost: true
    });

    // ä¿æŒè£å‰ªæ ·å¼
    const cellCenterX = cell.left + cell.width / 2;
    const cellCenterY = cell.top + cell.height / 2;
    const offsetX = (cellCenterX - img.left) / img.scaleX;
    const offsetY = (cellCenterY - img.top) / img.scaleY;

    const clipRect = new fabric.Rect({
      left: offsetX, top: offsetY,
      width: cell.width / img.scaleX, height: cell.height / img.scaleY,
      originX: 'center', originY: 'center',
      absolutePositioned: false
    });
    dragProxy.clipPath = clipRect;

    canvas.add(dragProxy);
    canvas.bringToFront(dragProxy);
    isCreatingProxy = false;
  });
};

const onMouseUp = (opt) => {
  if (!puzzleState.isActive) return;
  const canvas = unref(canvasRef);
  const pointer = canvas.getPointer(opt.e);
  isDragging = false;
  isCreatingProxy = false;

  if (dragProxy) {
    // å¤„ç†äº¤æ¢é€»è¾‘
    const dropCell = getCellFromPoint(pointer.x, pointer.y);
    const originCellIndex = dragOriginCellIndex;
    canvas.remove(dragProxy);
    dragProxy = null;
    const originImg = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === originCellIndex);
    if (originImg) originImg.set('opacity', 1);

    if (dropCell && dropCell.index !== originCellIndex) {
      animateSwap(originCellIndex, dropCell.index);
    } else {
      // æ²¡äº¤æ¢æˆåŠŸï¼Œå¼¹å›å»
      animateSnapBack(originCellIndex);
    }
  } else if (dragOriginPoint) {
    // å¤„ç†ç‚¹å‡»æˆ–å†…éƒ¨æ‹–æ‹½ç»“æŸ
    const dist = Math.sqrt(
      Math.pow(pointer.x - dragOriginPoint.x, 2) +
      Math.pow(pointer.y - dragOriginPoint.y, 2)
    );

    if (dist < 5) {
      // ç‚¹å‡»äº‹ä»¶
      const clickedCell = getCellFromPoint(pointer.x, pointer.y);
      if (clickedCell) {
        const target = opt.target;
        if (target && target.isDeleteBtn) return;

        const hasImg = canvas.getObjects().some(o => o.isPuzzleImage && o.cellIndex === clickedCell.index);

        if (!hasImg && uiCallbacks.onCellClick) {
          uiCallbacks.onCellClick(clickedCell.index);
          canvas.discardActiveObject();
        } else if (hasImg) {
          const controller = canvas.getObjects().find(o => o.isPuzzleController && o.cellIndex === clickedCell.index);
          if (controller) canvas.setActiveObject(controller);
        }
      }
    } else {
      // å†…éƒ¨æ‹–æ‹½ç»“æŸï¼Œè§¦å‘å›å¼¹
      if (dragOriginCellIndex !== -1) animateSnapBack(dragOriginCellIndex);
    }
  }
  dragOriginCellIndex = -1;
  dragOriginPoint = null;
  canvas.requestRenderAll();
};

// ã€æ ¸å¿ƒä¿®æ”¹ã€‘æ›¿æ¢åŸæœ‰çš„ animateSnapBack å®ç°
const animateSnapBack = (cellIndex) => {
  const canvas = unref(canvasRef);
  const cell = puzzleState.cells.find(c => c.index === cellIndex);
  const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === cellIndex);

  if (img && cell) {
    // æ„é€ å®¹å™¨çŸ©å½¢ (Cell)
    // æ³¨æ„ï¼šanimateRebound æ¥å—çš„æ˜¯ {left, top, width, height} å¯¹è±¡
    const containerRect = {
      left: cell.left,
      top: cell.top,
      width: cell.width,
      height: cell.height
    };

    // ç›´æ¥è°ƒç”¨é€šç”¨ç‰©ç†å›å¼¹å¼•æ“ï¼
    // è¿™æ ·æ‹¼å›¾çš„å›å¼¹æ‰‹æ„Ÿå°±å’Œ Crop/Resize å®Œå…¨ä¸€æ ·äº†
    animateRebound(img, containerRect, canvas);
  }
};

const animateSwap = (idxA, idxB) => {
  const canvas = unref(canvasRef);
  const imgA = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === idxA);
  const imgB = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === idxB);
  const cellA = puzzleState.cells.find(c => c.index === idxA);
  const cellB = puzzleState.cells.find(c => c.index === idxB);
  const animations = [];
  const duration = 300;
  const easing = fabric.util.ease.easeOutQuart;

  const createSyncAnimation = (img, targetCell) => {
    if (!img || !targetCell) return;

    // äº¤æ¢æ—¶ï¼Œæˆ‘ä»¬éœ€è¦é‡æ–°è®¡ç®—â€œCoverâ€çŠ¶æ€ä¸‹çš„æœ€ä½³ä½ç½®
    const targetImgState = calculateFitPosition(img, targetCell);

    animations.push(new Promise(resolve => {
      img.animate({
        left: targetImgState.left,
        top: targetImgState.top,
        scaleX: targetImgState.scaleX,
        scaleY: targetImgState.scaleY
      }, {
        duration, easing,
        onChange: canvas.requestRenderAll.bind(canvas),
        onComplete: resolve
      });
    }));

    if (img.clipPath) {
      animations.push(new Promise(resolve => {
        img.clipPath.animate({
          left: targetCell.left,
          top: targetCell.top,
          width: targetCell.width,
          height: targetCell.height,
          rx: puzzleState.radius,
          ry: puzzleState.radius
        }, {
          duration, easing,
          onComplete: resolve
        });
      }));
    }
  };

  createSyncAnimation(imgA, cellB);
  createSyncAnimation(imgB, cellA);

  Promise.all(animations).then(() => {
    if (imgA) imgA.cellIndex = idxB;
    if (imgB) imgB.cellIndex = idxA;
    const ctrlA = canvas.getObjects().find(o => o.isPuzzleController && o.cellIndex === idxA);
    const ctrlB = canvas.getObjects().find(o => o.isPuzzleController && o.cellIndex === idxB);
    if (ctrlA) ctrlA.cellIndex = idxB;
    if (ctrlB) ctrlB.cellIndex = idxA;
    refreshPuzzleObjects();
    if (saveHistoryFn) saveHistoryFn();
  });
};

const onMouseWheel = (opt) => {
  const canvas = unref(canvasRef);
  const target = canvas.getActiveObject();
  if (!target || !target.isPuzzleController) return;
  opt.e.preventDefault(); opt.e.stopPropagation();
  const cell = puzzleState.cells.find(c => c.index === target.cellIndex);
  const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === target.cellIndex);
  if (!cell || !img) return;

  // ç¼©æ”¾é€»è¾‘
  let zoom = img.scaleX;
  zoom *= 0.999 ** opt.e.deltaY;

  // é™åˆ¶ç¼©æ”¾èŒƒå›´
  const minScale = Math.max(cell.width / img.width, cell.height / img.height);
  const maxScale = minScale * 5;
  if (zoom < minScale) zoom = minScale;
  if (zoom > maxScale) zoom = maxScale;

  img.set({ scaleX: zoom, scaleY: zoom });

  // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ä½¿ç”¨é€šç”¨ç¡¬çº¦æŸï¼Œå®æ—¶ä¿®æ­£ä½ç½®ï¼Œé˜²æ­¢ç¼©æ”¾éœ²å‡ºé»‘è¾¹
  const containerRect = {
    left: cell.left, top: cell.top, width: cell.width, height: cell.height
  };
  constrainObjectToRect(img, containerRect, canvas);

  canvas.requestRenderAll();
};

export const updateLayout = (cellDefinitions = null, config = {}) => {
  const canvas = unref(canvasRef);
  if (!canvas) return;
  if (config.padding !== undefined) puzzleState.padding = config.padding;
  if (config.spacing !== undefined) puzzleState.spacing = config.spacing;
  if (config.radius !== undefined) puzzleState.radius = config.radius;
  if (config.bgColor) {
    puzzleState.bgColor = config.bgColor;
    canvas.setBackgroundColor(config.bgColor, () => canvas.requestRenderAll());
  }
  const isTemplateChange = !!cellDefinitions;
  if (cellDefinitions) puzzleState.rawCells = cellDefinitions;
  const { width, height, padding, spacing, startX, startY } = puzzleState;
  const availW = width - (padding * 2);
  const availH = height - (padding * 2);

  puzzleState.cells = puzzleState.rawCells.map(cell => ({
    index: cell.index,
    left: startX + padding + cell.x * availW + spacing / 2,
    top: startY + padding + cell.y * availH + spacing / 2,
    width: cell.w * availW - spacing,
    height: cell.h * availH - spacing
  }));
  refreshPuzzleObjects(isTemplateChange);
  if (saveHistoryFn) saveHistoryFn();
};

// === åˆ·æ–°å¯¹è±¡ (é˜²é‡å  + è‡ªåŠ¨å¸å…¥) ===
const refreshPuzzleObjects = (shouldResetImages = false) => {
  const canvas = unref(canvasRef);
  const { radius } = puzzleState;

  const toRemove = canvas.getObjects().filter(o => o.isPlaceholder || o.isPuzzleController || o.isDeleteBtn);
  canvas.remove(...toRemove);

  const existingPuzzleImages = canvas.getObjects()
    .filter(o => o.isPuzzleImage && !o.isGhost && o !== dragProxy)
    .sort((a, b) => a.cellIndex - b.cellIndex);

  // 1. è‡ªåŠ¨å¸å…¥æ™®é€šå›¾ç‰‡ (ä¿®å¤ï¼šä¸ä¼  scaleï¼Œå¼ºåˆ¶é‡æ–°è®¡ç®— Cover)
  if (shouldResetImages && existingPuzzleImages.length === 0) {
    const rawImages = canvas.getObjects().filter(o => o.type === 'image' && !o.isPuzzleItem);
    if (rawImages.length > 0) {
      const rawImg = rawImages[0];
      const src = rawImg.getSrc();
      // è¿™é‡Œåˆ é™¤äº† currentScale çš„è·å–
      canvas.remove(rawImg);

      // ä¸ä¼  targetScaleï¼Œå¼ºåˆ¶ä½¿ç”¨ addImageToCell å†…éƒ¨çš„è‡ªåŠ¨å±…ä¸­é€»è¾‘
      addImageToCell(src, 0);

      puzzleState.cells.forEach(cell => drawPlaceholder(canvas, cell));
      canvas.requestRenderAll();
      return;
    }
  }

  puzzleState.cells.forEach((cell, index) => {
    let img = null;
    if (shouldResetImages) {
      if (index < existingPuzzleImages.length) {
        img = existingPuzzleImages[index];
        img.cellIndex = cell.index;
        img.set({ opacity: 1, visible: true });
        // æ¨¡æ¿åˆ‡æ¢ï¼šå¼ºåˆ¶å±…ä¸­
        const fitState = calculateFitPosition(img, cell);
        img.set({ scaleX: fitState.scaleX, scaleY: fitState.scaleY, left: fitState.left, top: fitState.top });
        img.setCoords();
      }
    } else {
      img = existingPuzzleImages.find(o => o.cellIndex === cell.index);
      if (img) {
        // å¸ƒå±€å˜åŠ¨ï¼ˆå¦‚è°ƒæ•´ Paddingï¼‰ï¼šæ£€æŸ¥æ˜¯å¦å¡«æ»¡ï¼Œä¸å¤Ÿåˆ™æ”¾å¤§
        const minScale = Math.max(cell.width / img.width, cell.height / img.height);
        if (img.scaleX < minScale - 0.001) {
          img.set({ scaleX: minScale, scaleY: minScale });
        }
        // ç¡¬çº¦æŸé˜²æ­¢è·‘å
        const containerRect = { left: cell.left, top: cell.top, width: cell.width, height: cell.height };
        constrainObjectToRect(img, containerRect, canvas);
      }
    }

    if (img) {
      const clipRect = new fabric.Rect({
        left: cell.left, top: cell.top, width: cell.width, height: cell.height,
        rx: radius, ry: radius, absolutePositioned: true
      });
      img.set({ clipPath: clipRect, opacity: 1 });
      img.setCoords();

      const controller = new fabric.Rect({
        left: cell.left, top: cell.top, width: cell.width, height: cell.height,
        fill: 'transparent', noScaleCache: false,
        transparentCorners: false, cornerSize: 8, borderOpacityWhenMoving: 0.5,
        selectable: true, evented: true, hasControls: true, hasBorders: true,
        lockMovementX: true, lockMovementY: true,
        lockRotation: true, lockScalingX: true, lockScalingY: true,
        isPuzzleItem: true, isPuzzleController: true, cellIndex: cell.index
      });
      canvas.add(controller);
      drawDeleteBtn(canvas, cell);
    } else {
      drawPlaceholder(canvas, cell);
    }
  });

  if (shouldResetImages && existingPuzzleImages.length > puzzleState.cells.length) {
    const extras = existingPuzzleImages.slice(puzzleState.cells.length);
    canvas.remove(...extras);
  }
  canvas.requestRenderAll();
};

const deleteImageFromCell = (cellIndex) => {
  const canvas = unref(canvasRef);
  const objs = canvas.getObjects().filter(o =>
    (o.isPuzzleImage || o.isPuzzleController || o.isDeleteBtn) && o.cellIndex === cellIndex
  );
  canvas.remove(...objs);
  refreshPuzzleObjects();
  if (saveHistoryFn) saveHistoryFn();
};

const drawDeleteBtn = (canvas, cell) => {
  const btnRadius = 9;
  const padding = 6;

  const circle = new fabric.Circle({
    radius: btnRadius,
    fill: 'rgba(0, 0, 0, 0.6)',
    originX: 'center', originY: 'center'
  });

  const text = new fabric.Text('Ã—', {
    fill: '#fff',
    fontSize: 18,
    fontFamily: 'Arial',
    originX: 'center', originY: 'center',
    top: -1
  });

  const group = new fabric.Group([circle, text], {
    left: cell.left + cell.width - btnRadius - padding,
    top: cell.top + btnRadius + padding,
    originX: 'center', originY: 'center',
    selectable: false,
    hoverCursor: 'pointer',
    isPuzzleItem: true,
    isDeleteBtn: true,
    cellIndex: cell.index
  });

  canvas.add(group);
  canvas.bringToFront(group);
};

const drawPlaceholder = (canvas, cell) => {
  const rect = new fabric.Rect({
    left: cell.left, top: cell.top, width: cell.width, height: cell.height,
    fill: '#f5f7fa', stroke: '#dcdfe6', strokeWidth: 1, strokeDashArray: [4, 4],
    rx: puzzleState.radius, ry: puzzleState.radius,
    selectable: false, evented: false, isPuzzleItem: true, isPlaceholder: true
  });
  const plus = new fabric.Text('+', {
    left: cell.left + cell.width / 2, top: cell.top + cell.height / 2,
    fontSize: 30, fill: '#909399', originX: 'center', originY: 'center',
    selectable: false, evented: false, isPuzzleItem: true, isPlaceholder: true
  });
  canvas.add(rect, plus);
  canvas.sendToBack(rect);
};

const getCellFromPoint = (x, y) => {
  return puzzleState.cells.find(cell =>
    x >= cell.left && x <= cell.left + cell.width &&
    y >= cell.top && y <= cell.top + cell.height
  );
};

// === æ·»åŠ å›¾ç‰‡çš„ç»ˆæä¿®å¤ (å¼ºåˆ¶å±…ä¸­) ===
export const addImageToCell = (url, cellIndex, options = {}) => {
  const canvas = unref(canvasRef);
  const oldObjs = canvas.getObjects().filter(o => (o.isPuzzleImage || o.isPuzzleController || o.isDeleteBtn) && o.cellIndex === cellIndex);
  canvas.remove(...oldObjs);

  fabric.Image.fromURL(url, (img) => {
    const cell = puzzleState.cells.find(c => c.index === cellIndex);
    if (!cell) return;

    let scale;
    // é€»è¾‘ï¼šå¦‚æœæœ‰ targetScale å°±ç”¨ï¼Œæ²¡æœ‰å°±è‡ªåŠ¨ Cover
    if (options.targetScale) {
      scale = options.targetScale;
    } else {
      scale = Math.max(cell.width / img.width, cell.height / img.height) + 0.001;
    }

    // ã€å…³é”®ã€‘è®¾ç½®å±…ä¸­
    img.set({
      // 1. è®¾ç½®ä¸­å¿ƒç‚¹åæ ‡
      left: cell.left + cell.width / 2,
      top: cell.top + cell.height / 2,
      // 2. è®¾ç½® origin ä¸ºä¸­å¿ƒ
      originX: 'center',
      originY: 'center',
      scaleX: scale,
      scaleY: scale,
      selectable: false, evented: false, hasControls: false, hasBorders: false,
      isPuzzleItem: true, isPuzzleImage: true, cellIndex: cellIndex,
    });

    // 3. ç«‹å³æ›´æ–°åæ ‡ï¼Œé˜²æ­¢åç»­è®¡ç®—å‡ºé”™
    img.setCoords();

    const controller = new fabric.Rect({
      left: cell.left, top: cell.top, width: cell.width, height: cell.height,
      fill: 'transparent', noScaleCache: false,
      transparentCorners: false, cornerSize: 8, borderOpacityWhenMoving: 0.5,
      selectable: true, evented: true, hasControls: true, hasBorders: true,
      lockMovementX: true, lockMovementY: true,
      lockRotation: true, lockScalingX: true, lockScalingY: true,
      isPuzzleItem: true, isPuzzleController: true, cellIndex: cellIndex,
    });

    canvas.add(img);
    canvas.add(controller);
    canvas.setActiveObject(controller);

    refreshPuzzleObjects(); // è¿™é‡Œä¼šå†æ¬¡è§¦å‘ constrain checkï¼Œä½†å› ä¸ºå·²ç»å±…ä¸­ä¸”è¶³å¤Ÿå¤§ï¼Œä¸ä¼šæœ‰å‰¯ä½œç”¨
    if (saveHistoryFn) saveHistoryFn();
  }, { crossOrigin: 'anonymous' });
};
</file>

<file path="package.json">
{
  "name": "image-editor-sdk",
  "version": "1.0.0",
  "type": "module",
  "types": "./dist/index.d.ts",
  "main": "./dist/image-editor.umd.cjs",
  "module": "./dist/image-editor.js",
  "files": ["dist"],
  "exports": {
    ".": {
      "import": "./dist/image-editor.js",
      "require": "./dist/image-editor.umd.cjs"
    },
    "./style.css": "./dist/index.css"
  },
  "scripts": {
    "dev": "vite --host 0.0.0.0",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "fabric": "^5.3.0",
    "file-saver": "^2.0.5"
  },
  "peerDependencies": {
    "vue": "^3.3.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.1",
    "vite": "^7.2.4",
    "vite-plugin-dts": "^4.5.4"
  }
}
</file>

<file path="src/components/modules/puzzle/index.vue">
<template>
  <div class="puzzle-panel">
    <div class="main-tabs">
      <div class="tab-item" :class="{ active: mode === 'grid' }" @click="mode = 'grid'">
        ç½‘æ ¼å¸ƒå±€
      </div>
      <div class="tab-item disabled">
        é•¿å›¾æ‹¼æ¥
      </div>
    </div>

    <div v-if="mode === 'grid'" class="panel-content">
      <div class="sub-tabs">
        <div class="sub-item" :class="{ active: subTab === 'tpl' }" @click="subTab = 'tpl'">æ¨¡æ¿åº“</div>
        <div class="sub-item" :class="{ active: subTab === 'style' }" @click="subTab = 'style'">æ ·å¼è°ƒæ•´</div>
      </div>

      <div v-show="subTab === 'tpl'" class="tab-pane fade-in">

        <div class="filter-section">
          <div class="filter-label">å›¾ç‰‡æ•°é‡</div>
          <div class="filter-scroll-wrapper hide-scrollbar">
            <div v-for="opt in countOptions" :key="opt.value" class="filter-tag"
              :class="{ active: selectedCount === opt.value }" @click="selectedCount = opt.value">
              {{ opt.label }}
            </div>
          </div>
        </div>

        <div class="template-section">
          <div class="section-header">
            <span class="title">å¸ƒå±€åˆ—è¡¨</span>
            <span class="count-badge" v-if="filteredTemplates.length">{{ filteredTemplates.length }}</span>
          </div>

          <div v-if="filteredTemplates.length === 0" class="empty-state">
            æš‚æ— æ­¤ç±»æ¨¡æ¿
          </div>

          <div class="template-grid-container" v-else>
            <div v-for="tpl in filteredTemplates" :key="tpl.id" class="tpl-card" @click="applyTemplate(tpl)">
              <div class="mini-grid-preview" :style="tpl.wrapStyle">
                <div v-for="(area, idx) in tpl.gridAreas" :key="idx" :style="{ gridArea: area }"></div>
              </div>
              <div class="card-overlay">{{ tpl.label || 'æ¨¡æ¿' }}</div>
            </div>
          </div>
        </div>

        <div class="custom-grid-section">
          <div class="section-header small">è‡ªå®šä¹‰è¡Œåˆ—</div>
          <div class="custom-input-group">
            <div class="input-item">
              <span class="label">è¡Œ</span>
              <input type="number" class="ie-input" v-model.number="customRows" min="1" max="6" @change="applyCustom">
            </div>
            <div class="divider"></div>
            <div class="input-item">
              <span class="label">åˆ—</span>
              <input type="number" class="ie-input" v-model.number="customCols" min="1" max="6" @change="applyCustom">
            </div>
          </div>
        </div>

      </div>

      <div v-show="subTab === 'style'" class="tab-pane fade-in">
        <div class="ie-group">
          <div class="group-header">é—´è·ä¸åœ†è§’</div>
          <div class="control-list">
            <div class="slider-item">
              <span class="label">å¤–è¾¹è·</span>
              <input type="range" class="ie-range" v-model.number="style.padding" max="60" @input="updateStyle">
              <span class="val">{{ style.padding }}</span>
            </div>
            <div class="slider-item">
              <span class="label">é—´éš™</span>
              <input type="range" class="ie-range" v-model.number="style.spacing" max="40" @input="updateStyle">
              <span class="val">{{ style.spacing }}</span>
            </div>
            <div class="slider-item">
              <span class="label">åœ†è§’</span>
              <input type="range" class="ie-range" v-model.number="style.radius" max="100" @input="updateStyle">
              <span class="val">{{ style.radius }}</span>
            </div>
          </div>
        </div>

        <div class="ie-group">
          <div class="group-header">ç”»å¸ƒèƒŒæ™¯</div>
          <div class="color-selector">
            <div class="color-preview" :style="{ backgroundColor: style.bgColor }">
              <input type="color" v-model="style.bgColor" @input="updateStyle" class="color-input-hidden">
            </div>
            <span class="color-value">{{ style.bgColor }}</span>
          </div>
        </div>
      </div>
    </div>

    <input type="file" ref="fileInput" accept="image/png, image/jpeg, image/jpg" style="display:none"
      @change="onFileSelected">
  </div>
</template>

<script setup>
import { ref, reactive, inject, onMounted, onUnmounted, computed } from 'vue';
import { toast } from '@/utils/toast';
import {
  registerPuzzleModule,
  initPuzzleMode,
  exitPuzzleMode,
  updateLayout,
  addImageToCell,
} from './useCanvasPuzzle';
import {
  generateGridCells,
  gridTemplates,
  countOptions,
  parseTemplateToCells
} from './config';

const canvasAPI = inject('canvasAPI');
const fileInput = ref(null);
const mode = ref('grid');
const subTab = ref('tpl');

const selectedCount = ref('all');
let pendingCellIndex = -1;

const customRows = ref(2);
const customCols = ref(2);

const style = reactive({
  padding: 20,
  spacing: 10,
  radius: 0,
  bgColor: '#ffffff'
});

const filteredTemplates = computed(() => {
  if (selectedCount.value === 'all') {
    return Object.values(gridTemplates).flat();
  }
  return gridTemplates[selectedCount.value] || [];
});

onMounted(() => {
  if (canvasAPI) {
    registerPuzzleModule(canvasAPI.canvas, canvasAPI.saveHistory, {
      onCellClick: (index) => {
        pendingCellIndex = index;
        if (fileInput.value) {
          fileInput.value.value = '';
          fileInput.value.click();
        }
      }
    });
    initPuzzleMode();
  }
});

onUnmounted(() => {
  exitPuzzleMode();
});

const applyCustom = () => {
  const cells = generateGridCells(customRows.value, customCols.value);
  updateLayout(cells, style);
};

const applyTemplate = (tpl) => {
  const cells = parseTemplateToCells(tpl);
  updateLayout(cells, style);
};

const updateStyle = () => {
  updateLayout(null, style);
};

const onFileSelected = (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
    toast.error('ä»…æ”¯æŒ JPG/PNG å›¾ç‰‡æ ¼å¼');
    return;
  }
  if (pendingCellIndex >= 0) {
    const url = URL.createObjectURL(file);
    addImageToCell(url, pendingCellIndex);
    pendingCellIndex = -1;
  }
};
</script>

<style scoped>
/* === å…¨å±€å˜é‡ (Design Token) === */
.puzzle-panel {
  --primary: #409eff;
  --primary-soft: #ecf5ff;
  --text-main: #2c3e50;
  --text-sub: #606266;
  --text-light: #909399;
  --bg-page: #ffffff;
  --bg-block: #f7f8fa;
  /* æµ…ç°å—èƒŒæ™¯ */
  --border: #eef0f4;
  --radius-md: 8px;
  --radius-pill: 20px;

  height: 100%;
  display: flex;
  flex-direction: column;
  background: var(--bg-page);
  color: var(--text-main);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  overflow: hidden;
}

/* === é¡¶éƒ¨ Tabs === */
.main-tabs {
  display: flex;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  gap: 10px;
  background: var(--bg-page);
}

.tab-item {
  flex: 1;
  text-align: center;
  padding: 8px 0;
  font-size: 14px;
  border-radius: var(--radius-md);
  color: var(--text-sub);
  cursor: pointer;
  transition: all 0.2s;
  background: var(--bg-block);
  font-weight: 500;
  border: 1px solid transparent;
}

.tab-item:hover:not(.disabled) {
  background: #fff;
  border-color: var(--border);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
}

.tab-item.active {
  background: var(--primary-soft);
  color: var(--primary);
  border-color: transparent;
}

.tab-item.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* === å†…å®¹åŒº === */
.panel-content {
  flex: 1;
  overflow-y: auto;
  /* çºµå‘æ»šåŠ¨ */
  padding: 0;
  display: flex;
  flex-direction: column;
}


/* äºŒçº§ Tabs */
.sub-tabs {
  display: flex;
  padding: 0 16px;
  border-bottom: 1px solid var(--border);
  background: var(--bg-page);
  position: sticky;
  top: 0;
  z-index: 10;
}

.sub-item {
  flex: 1;
  text-align: center;
  padding: 12px 0;
  font-size: 13px;
  color: var(--text-sub);
  cursor: pointer;
  position: relative;
  transition: color 0.2s;
}

.sub-item.active {
  color: var(--primary);
  font-weight: 600;
}

.sub-item.active::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 20px;
  height: 2px;
  background: var(--primary);
  border-radius: 2px 2px 0 0;
}

.tab-pane {
  padding: 16px;
}

/* === 1. ç­›é€‰å™¨ (æ¨ªå‘æ»šåŠ¨ + èƒ¶å›Š) === */
.filter-section {
  margin-bottom: 24px;
}

.filter-label {
  font-size: 12px;
  color: var(--text-light);
  margin-bottom: 8px;
  padding-left: 2px;
}

.filter-scroll-wrapper {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding-bottom: 4px;
  justify-content: space-between;
}

.filter-scroll-wrapper::-webkit-scrollbar {
  display: none;
}

.filter-scroll-wrapper:active {
  cursor: grabbing;
}

.filter-tag {
  width: 58px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  /* åœ†è§’æ›´ç²¾è‡´ */
  font-size: 14px;
  color: #606266;
  background: #ffffff;
  border: 1px solid #e5e8eb;
  /* åŸºç¡€é˜´å½± - æå‡å±‚æ¬¡æ„Ÿ */
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
  /* è¿‡æ¸¡åŠ¨ç”» - äº¤äº’æ›´ä¸æ»‘ */
  transition: all 0.2s ease;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

/* æ¿€æ´»æ€ï¼ˆå…¨éƒ¨æŒ‰é’®ï¼‰æ ·å¼ */
.filter-tag.active {
  color: #ffffff;
  /* æ¸å˜èƒŒæ™¯ - æå‡è´¨æ„Ÿ */
  background: linear-gradient(135deg, #2596ff 0%, #0078ff 100%);
  border-color: #0078ff;
  /* å¢å¼ºé˜´å½± - çªå‡ºé€‰ä¸­çŠ¶æ€ */
  box-shadow: 0 4px 8px rgba(0, 120, 255, 0.25);
}

/* æ‚¬æµ®æ€æ ·å¼ */
.filter-tag:not(.active):hover {
  border-color: #ccd0d6;
  background: #f8f9fa;
  /* æ‚¬æµ®é˜´å½±æå‡ */
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
  transform: translateY(-1px);
  /* è½»å¾®ä¸Šæµ® - è§¦æ„Ÿåé¦ˆ */
}

/* ç‚¹å‡»æŒ‰å‹æ€ */
.filter-tag:not(.active):active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
  background: #f0f2f5;
}

/* æ¿€æ´»æ€ä¼ªå…ƒç´  - å¢åŠ ç»†èŠ‚è´¨æ„Ÿ */
.filter-tag.active::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0) 100%);
  pointer-events: none;
}

/* === 2. æ¨¡æ¿åˆ—è¡¨ (å¡ç‰‡é£æ ¼) === */
.section-header {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-main);
  margin-bottom: 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-left: 2px;
}

.count-badge {
  font-size: 12px;
  color: var(--text-light);
  background: var(--bg-block);
  padding: 2px 6px;
  border-radius: 4px;
}

.template-grid-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
}

.tpl-card {
  position: relative;
  aspect-ratio: 1;
  background: #fff;
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  padding: 5px;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
  overflow: hidden;
}

.tpl-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  border-color: var(--primary-soft);
}

/* é¢„è§ˆå›¾å®¹å™¨ */
.mini-grid-preview {
  width: 100%;
  height: 100%;
  display: grid;
  gap: 2px;
  border-radius: 4px;
  overflow: hidden;
}

.mini-grid-preview>div {
  background: #e6e8eb;
  /* é»˜è®¤ç°è‰² */
  transition: background 0.2s;
}

.tpl-card:hover .mini-grid-preview>div {
  background: #d4d7dc;
  /* æ‚¬æµ®åŠ æ·± */
}

/* åº•éƒ¨æ–‡å­—é®ç½© (åªåœ¨hoveræ˜¾ç¤º) */
.card-overlay {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.6);
  /* åŠé€æ˜é»‘åº• */
  padding: 4px;
  text-align: center;
  font-size: 10px;
  color: #fff;
  transform: translateY(100%);
  transition: transform 0.2s ease;
  backdrop-filter: blur(2px);
}

.tpl-card:hover .card-overlay {
  transform: translateY(0);
}

/* === 3. è‡ªå®šä¹‰è¡Œåˆ— (æ•´åˆè¾“å…¥æ¡†) === */
.custom-grid-section {
  margin-top: 24px;
  padding-top: 20px;
  border-top: 1px dashed var(--border);
}

.section-header.small {
  font-size: 12px;
  color: var(--text-light);
  margin-bottom: 10px;
}

.custom-input-group {
  display: flex;
  align-items: center;
  background: var(--bg-block);
  border-radius: var(--radius-md);
  padding: 6px;
  border: 1px solid transparent;
  transition: border-color 0.2s;
}

.custom-input-group:focus-within {
  border-color: var(--primary);
  background: #fff;
  box-shadow: 0 0 0 2px var(--primary-soft);
}

.input-item {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}

.input-item .label {
  font-size: 12px;
  color: var(--text-sub);
  margin-right: 8px;
}

.ie-input {
  width: 40px;
  border: none;
  background: transparent;
  font-size: 14px;
  color: var(--text-main);
  text-align: center;
  outline: none;
}

.divider {
  width: 1px;
  height: 16px;
  background: #ddd;
  margin: 0 8px;
}

/* === æ ·å¼è°ƒæ•´ Tab === */
.ie-group {
  margin-bottom: 24px;
}

.group-header {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-main);
  margin-bottom: 12px;
}

.slider-item {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
}

.slider-item .label {
  width: 48px;
  font-size: 13px;
  color: var(--text-sub);
}

.ie-range {
  flex: 1;
  margin: 0 12px;
  height: 4px;
  background: #e4e7ed;
  border-radius: 2px;
  -webkit-appearance: none;
  cursor: pointer;
}

.ie-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px;
  height: 12px;
  background: var(--primary);
  border: 2px solid #fff;
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  transition: transform 0.1s;
}

.ie-range::-webkit-slider-thumb:hover {
  transform: scale(1.2);
}

.slider-item .val {
  width: 24px;
  text-align: right;
  font-size: 12px;
  color: var(--text-light);
  font-family: monospace;
}

.color-selector {
  display: flex;
  align-items: center;
  gap: 10px;
  background: var(--bg-block);
  padding: 8px;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all 0.2s;
}

.color-selector:hover {
  background: #eef1f6;
}

.color-preview {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 1px solid rgba(0, 0, 0, 0.1);
  position: relative;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.color-input-hidden {
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  opacity: 0;
  cursor: pointer;
}

.color-value {
  font-size: 13px;
  color: var(--text-sub);
  font-family: monospace;
}

.empty-state {
  text-align: center;
  color: var(--text-light);
  font-size: 13px;
  padding: 40px 0;
  background: var(--bg-block);
  border-radius: var(--radius-md);
}

.fade-in {
  animation: fadeIn 0.3s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(4px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}
</style>
</file>

<file path="src/components/modules/adjust/index.vue">
<template>
  <div class="panel-adjust">
    <div class="tool-list">

      <AdjustCrop :is-expanded="activeCollapse === 'crop'" @toggle="toggle('crop')" />

      <AdjustResize :is-expanded="activeCollapse === 'resize'" @toggle="toggle('resize')" />

      <AdjustInpaint :is-expanded="activeCollapse === 'inpaint'" @toggle="toggle('inpaint')" />

      <AdjustRembg :is-expanded="activeCollapse === 'rembg'" @toggle="toggle('rembg')" />

      <AdjustRuler :is-expanded="activeCollapse === 'ruler'" @toggle="toggle('ruler')" />

      <AdjustWhite :is-expanded="activeCollapse === 'white'" @toggle="toggle('white')" />

      <AdjustColor :is-expanded="activeCollapse === 'color'" @toggle="toggle('color')" />

      <AdjustColorOverlay :is-expanded="activeCollapse === 'overlay'" @toggle="toggle('overlay')" />

      <AdjustFilters :is-expanded="activeCollapse === 'filters'" @toggle="toggle('filters')" />

      <AdjustMosaic :is-expanded="activeCollapse === 'mosaic'" @toggle="toggle('mosaic')" />

    </div>
  </div>
</template>

<script setup>
import { ref, defineAsyncComponent } from 'vue';
import { toast } from '@/utils/toast';

// å¼‚æ­¥ç»„ä»¶å¼•å…¥
const AdjustCrop = defineAsyncComponent(() => import('./AdjustCrop.vue'));
const AdjustResize = defineAsyncComponent(() => import('./AdjustResize.vue'));
const AdjustInpaint = defineAsyncComponent(() => import('./AdjustInpaint.vue'));
const AdjustRembg = defineAsyncComponent(() => import('./AdjustRembg.vue'));
const AdjustWhite = defineAsyncComponent(() => import('./AdjustWhite.vue'));
const AdjustColor = defineAsyncComponent(() => import('./AdjustColor.vue'));
const AdjustFilters = defineAsyncComponent(() => import('./AdjustFilters.vue'));
const AdjustColorOverlay = defineAsyncComponent(() => import('./AdjustColorOverlay.vue'));
const AdjustMosaic = defineAsyncComponent(() => import('./AdjustMosaic.vue'));
const AdjustRuler = defineAsyncComponent(() => import('./AdjustRuler.vue'));

const activeCollapse = ref('');

const toggle = (id) => {
  activeCollapse.value = activeCollapse.value === id ? '' : id;
};

const notImplemented = () => {
  toast.info('åŠŸèƒ½å¼€å‘ä¸­');
};
</script>

<style scoped>
.panel-adjust {
  padding: 16px;
  height: 100%;
  overflow-y: auto;
  background-color: #fff;
  box-sizing: border-box;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustCrop.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
          <path d="M6 2v14a2 2 0 0 0 2 2h14" />
          <path d="M18 22V8a2 2 0 0 0-2-2H2" />
        </svg>
        <span>è£å‰ª/æ—‹è½¬</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">

      <div class="ratio-grid">
        <div class="ratio-item" @click="handleSetRatio(null, true)">
          <div class="icon-box">
            <svg width="16" height="16" viewBox="0 0 24 24" style="fill: currentColor">
              <path
                d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
            </svg>
          </div>
          <span>åˆå§‹åŒ–</span>
        </div>

        <div class="ratio-item" :class="{ active: currentRatio === 'original' }" @click="handleSetRatio('original')">
          <div class="shape-rect" style="width: 14px; height: 14px; border:1px solid #666"></div>
          <span>åŸæ¯”ä¾‹</span>
        </div>

        <div class="ratio-item" :class="{ active: currentRatio === 'free' }" @click="handleSetRatio(null)">
          <div class="shape-rect dashed"></div>
          <span>è‡ªç”±æ¯”ä¾‹</span>
        </div>

        <div class="ratio-item" :class="{ active: isManualActive }" @click="handleManualSelect">
          <div class="icon-box">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path stroke-dasharray="4 4" d="M4 4h16v16H4z" />
              <path fill="currentColor" stroke="none" d="M14 14l3.5 8 1.5-3.5 3.5-1.5-8-3.5z" />
            </svg>
          </div>
          <span>æ‰‹åŠ¨é€‰åŒº</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(1) }" @click="handleSetRatio(1)">
          <div class="shape-rect square"></div>
          <span>1:1</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(3 / 2) }" @click="handleSetRatio(3 / 2)">
          <div class="shape-rect" style="width: 12px; height: 8px;"></div>
          <span>3:2</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(2 / 3) }" @click="handleSetRatio(2 / 3)">
          <div class="shape-rect" style="width: 8px; height: 12px;"></div>
          <span>2:3</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(4 / 3) }" @click="handleSetRatio(4 / 3)">
          <div class="shape-rect" style="width: 16px; height: 12px;"></div>
          <span>4:3</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(3 / 4) }" @click="handleSetRatio(3 / 4)">
          <div class="shape-rect" style="width: 12px; height: 16px;"></div>
          <span>3:4</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(16 / 9) }" @click="handleSetRatio(16 / 9)">
          <div class="shape-rect" style="width: 16px; height: 9px;"></div>
          <span>16:9</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(9 / 16) }" @click="handleSetRatio(9 / 16)">
          <div class="shape-rect" style="width: 9px; height: 16px;"></div>
          <span>9:16</span>
        </div>
      </div>

      <div class="custom-input-box">
        <div class="input-header">
          <span>è‡ªå®šä¹‰</span>
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round" style="cursor: pointer">
            <circle cx="12" cy="12" r="3"></circle>
            <path
              d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
            </path>
          </svg>
        </div>

        <div class="input-controls">
          <div class="input-wrapper">
            <input type="number" v-model.number="cropW" class="ie-input" @change="onWidthChange">
            <span class="suffix">W</span>
          </div>

          <div class="link-icon" @click="toggleRatioLock">
            <svg v-if="isRatioLocked" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#409eff"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
            </svg>
            <svg v-else width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#909399" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
              <line x1="4" y1="4" x2="20" y2="20" stroke="#909399" />
            </svg>
          </div>

          <div class="input-wrapper">
            <input type="number" v-model.number="cropH" class="ie-input" @change="onHeightChange">
            <span class="suffix">H</span>
          </div>
        </div>
      </div>

      <div class="rotate-actions">
        <div class="action-btn" title="å‘å·¦æ—‹è½¬90Â°" @click="rotate(-90)">
          <svg width="20" height="20" viewBox="-1 -1 26 26" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
            <path d="M3 3v5h5" />
          </svg>
        </div>
        <div class="action-btn" title="å‘å³æ—‹è½¬90Â°" @click="rotate(90)">
          <svg width="20" height="20" viewBox="-1 -1 26 26" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12a9 9 0 1 1-9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
            <path d="M21 3v5h-5" />
          </svg>
        </div>
        <div class="divider"></div>
        <div class="action-btn" title="æ°´å¹³ç¿»è½¬" @click="flip('X')">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 5v14" />
            <path d="M8 9l-3 3 3 3" />
            <path d="M16 9l3 3-3 3" />
          </svg>
        </div>
        <div class="action-btn" title="å‚ç›´ç¿»è½¬" @click="flip('Y')">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M5 12h14" />
            <path d="M9 8l3-3 3 3" />
            <path d="M9 16l3 3 3-3" />
          </svg>
        </div>
      </div>

      <div class="confirm-row">
        <button class="ie-btn ie-primary full-btn" @click="handleApply">åº”ç”¨</button>
        <button class="ie-btn full-btn" @click="handleCancel">å–æ¶ˆ</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, onMounted, onUnmounted, computed, nextTick } from 'vue';
import { fabric } from 'fabric';

import {
  startCrop,
  confirmCrop,
  setCropRatio,
  currentSelectionDims,
  isRatioLocked,
  currentAspectRatio, // ç¡®ä¿å¼•å…¥äº†æ­¤å˜é‡
  setCropBoxSize,
  rotateActive,
  flipActive,
  startManualSelection,
  isManualCropping,
  cropObject,
  openCropPanel,
  closeCropPanel,
} from './useCanvasCrop';

const props = defineProps({
  isExpanded: {
    type: Boolean,
    default: false
  }
});
const emit = defineEmits(['toggle']);

const currentRatio = ref('free');
const cropW = ref(0);
const cropH = ref(0);

// ç›‘å¬æ¥è‡ªé€»è¾‘å±‚çš„å°ºå¯¸å˜åŒ–
watch(currentSelectionDims, (newVal) => {
  if (newVal && (newVal.width !== 0 || newVal.height !== 0)) {
    cropW.value = newVal.width;
    cropH.value = newVal.height;
  }
});

watch(() => props.isExpanded, (val) => {
  if (val) {
    nextTick(() => {
      startCrop(null);
      updateInputFromCanvas();
    });
  } else {
    closeCropPanel();
  }
});

const handleToggle = () => {
  emit('toggle');
};

const handleCancel = () => {
  emit('toggle');
};

const handleApply = () => {
  confirmCrop();
  emit('toggle');
};

const isRatioMatch = (r) => {
  if (currentRatio.value === 'original') return false;
  if (!currentAspectRatio.value) return false;
  return Math.abs(currentAspectRatio.value - r) < 0.01;
};

const handleSetRatio = (ratio, isReset = false) => {
  if (isReset) {
    currentRatio.value = 'free';
    startCrop(null);
  } else if (ratio === 'original') {
    currentRatio.value = 'original';
    const activeObj = cropObject.value?.canvas?.getObjects().find(o => o.type === 'image');
    if (activeObj) {
      setCropRatio(activeObj.width / activeObj.height);
    }
  } else if (ratio === null) {
    currentRatio.value = 'free';
    setCropRatio(null);
  } else {
    currentRatio.value = ratio;
    setCropRatio(ratio);
  }
  nextTick(() => {
    updateInputFromCanvas();
  });
};

// ============================================
// æ–°å¢/ä¿®æ”¹ï¼šè¾“å…¥æ¡†è”åŠ¨è®¡ç®—é€»è¾‘
// ============================================

// è·å–å½“å‰æœ‰æ•ˆçš„è®¡ç®—æ¯”ä¾‹
const getActiveRatio = () => {
  // 1. å¦‚æœå½“å‰é€‰ä¸­çš„æ˜¯æ•°å­—æ¯”ä¾‹ (å¦‚ 1.5, 0.75 ç­‰)ï¼Œç›´æ¥è¿”å›
  if (typeof currentRatio.value === 'number') {
    return currentRatio.value;
  }
  // 2. å¦‚æœå½“å‰é€‰ä¸­çš„æ˜¯ 'original'ï¼Œåˆ™ä½¿ç”¨é€»è¾‘å±‚è®¡ç®—å‡ºçš„çœŸå®æ¯”ä¾‹
  if (currentRatio.value === 'original' && currentAspectRatio.value) {
    return currentAspectRatio.value;
  }
  // 3. è‡ªç”±æ¯”ä¾‹è¿”å› null
  return null;
};

// å®½åº¦å˜åŒ–æ—¶
const onWidthChange = () => {
  const ratio = getActiveRatio();
  // å¦‚æœæœ‰é”å®šæ¯”ä¾‹ï¼Œä¸”å®½åº¦æœ‰æ•ˆ
  if (ratio && cropW.value > 0) {
    // å®½ = é«˜ * æ¯”ä¾‹  =>  é«˜ = å®½ / æ¯”ä¾‹
    cropH.value = Math.round(cropW.value / ratio);
  }
  // åº”ç”¨åˆ°ç”»å¸ƒ
  applyInputSize();
};

// é«˜åº¦å˜åŒ–æ—¶
const onHeightChange = () => {
  const ratio = getActiveRatio();
  // å¦‚æœæœ‰é”å®šæ¯”ä¾‹ï¼Œä¸”é«˜åº¦æœ‰æ•ˆ
  if (ratio && cropH.value > 0) {
    // å®½ = é«˜ * æ¯”ä¾‹
    cropW.value = Math.round(cropH.value * ratio);
  }
  // åº”ç”¨åˆ°ç”»å¸ƒ
  applyInputSize();
};

// å°†è¾“å…¥æ¡†çš„å€¼åº”ç”¨åˆ° Canvas é€‰åŒº
const applyInputSize = () => {
  if (cropW.value > 0 && cropH.value > 0) {
    setCropBoxSize(cropW.value, cropH.value);
  }
};

const toggleRatioLock = () => {
  if (isRatioLocked.value) {
    handleSetRatio(null);
  } else {
    // å¦‚æœæ˜¯ä»è‡ªç”±æ¯”ä¾‹ç‚¹å‡»é”å®šï¼Œåˆ™é”å®šå½“å‰è¾“å…¥çš„æ¯”ä¾‹
    if (cropW.value && cropH.value) {
      const currentR = cropW.value / cropH.value;
      currentRatio.value = currentR;
      setCropRatio(currentR);
    }
  }
};

// ============================================

const isManualActive = computed(() => isManualCropping.value);

const updateInputFromCanvas = () => {
  if (cropObject.value) {
    const w = Math.round(cropObject.value.getScaledWidth());
    const h = Math.round(cropObject.value.getScaledHeight());

    cropW.value = w;
    cropH.value = h;
    if (currentRatio.value !== 'free' && currentRatio.value !== 'original' && typeof currentRatio.value === 'number') {
      const currentRealRatio = w / h;
      const targetRatio = currentRatio.value;
      if (Math.abs(currentRealRatio - targetRatio) > 0.02) {
        currentRatio.value = 'free';
        setCropRatio(null);
      }
    }
  }
};

const handleManualSelect = () => {
  currentRatio.value = 'manual'; // 1. å°† UI çŠ¶æ€è®¾ä¸º manualï¼Œæ¸…é™¤â€œåŸæ¯”ä¾‹â€å’Œâ€œè‡ªç”±æ¯”ä¾‹â€çš„é«˜äº®
  setCropRatio(null);            // 2. æ ¸å¿ƒä¿®å¤ï¼šè°ƒç”¨é€»è¾‘å±‚æ–¹æ³•ï¼Œå°†æ¯”ä¾‹é”å®šè®¾ä¸º nullï¼Œä»è€Œæ¸…é™¤ 1:1ã€3:2 ç­‰é¡¹çš„é«˜äº®
  startManualSelection()
};

const rotate = (angle) => {
  rotateActive(angle);
  setTimeout(updateInputFromCanvas, 50);
};
const flip = (axis) => flipActive(axis);

onMounted(() => {
  if (props.isExpanded) {
    openCropPanel();
    nextTick(() => {
      startCrop(null);
      updateInputFromCanvas();
    });
  }

  const checkCanvas = setInterval(() => {
    const canvasInstance = cropObject.value?.canvas;
    if (canvasInstance) {
      canvasInstance.on('object:scaling', updateInputFromCanvas);
      canvasInstance.on('object:modified', updateInputFromCanvas);
      canvasInstance.on('object:moving', updateInputFromCanvas);
      clearInterval(checkCanvas);
    }
  }, 100);
});

onUnmounted(() => {
  const canvasInstance = cropObject.value?.canvas;
  if (canvasInstance) {
    canvasInstance.off('object:scaling', updateInputFromCanvas);
    canvasInstance.off('object:modified', updateInputFromCanvas);
    canvasInstance.off('object:moving', updateInputFromCanvas);
  }

  if (props.isExpanded) {
    closeCropPanel();
  }
});
</script>

<style scoped>
/* ä¿æŒæ‰€æœ‰æ ·å¼ä¸å˜ */
.ratio-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin-bottom: 16px;
}

.ratio-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 10px 4px;
  border: 1px solid #f2f2f2;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  color: #666;
  background: #fff;
  transition: all 0.2s;
  height: 60px;
}

.ratio-item:hover {
  background-color: #f9f9f9;
  border-color: #dcdfe6;
}

.ratio-item.active {
  border-color: #409eff;
  color: #409eff;
  background-color: #ecf5ff;
}

.icon-box {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 6px;
}

.shape-rect {
  border: 1px solid currentColor;
  margin-bottom: 6px;
  box-sizing: border-box;
}

.shape-rect.dashed {
  border-style: dashed;
  width: 14px;
  height: 14px;
}

.shape-rect.square {
  width: 14px;
  height: 14px;
}

.custom-input-box {
  background-color: #f8f9fa;
  border: none;
  border-radius: 6px;
  padding: 10px;
  margin-bottom: 12px;
}

.input-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;
  color: #333;
  margin-bottom: 8px;
}

.input-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.input-wrapper {
  position: relative;
  width: 38%;
}

.ie-input {
  text-align: center;
  padding-right: 20px;
  font-weight: 500;
  color: #333;
}

.suffix {
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  color: #c0c4cc;
  font-size: 12px;
  pointer-events: none;
}

.link-icon {
  width: 24px;
  display: flex;
  justify-content: center;
  cursor: pointer;
}

.rotate-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 0 10px;
}

.action-btn {
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  cursor: pointer;
  color: #606266;
  font-size: 18px;
  background-color: #f5f7fa;
  transition: all 0.2s;
}

.action-btn:hover {
  background-color: #e6e8eb;
  color: #333;
}

.divider {
  width: 1px;
  height: 20px;
  background-color: #eee;
}

.confirm-row {
  display: flex;
  gap: 10px;
}

.full-btn {
  flex: 1;
}
</style>
</file>

<file path="src/components/modules/adjust/useCanvasResize.js">
// src/components/modules/adjust/useCanvasResize.js
import { ref, unref, shallowRef, toRaw } from "vue";
import { fabric } from "fabric";

// 1. å¼•å…¥é€šç”¨ç‰©ç†çº¦æŸä¸ç¦»å±æ¸²æŸ“å·¥å…·
import { constrainObjectToRect, animateRebound } from '@/composables/useConstraint';
import { renderHighResSnapshot } from '@/composables/useOffscreenHelper';

let canvasRef = null;
let saveHistoryFn = null;

const previewRect = shallowRef(null);
let isDraggingImage = false;
let dragLastX = 0;
let dragLastY = 0;

let originalSelectable = true;
let originalEvented = true;
let originalTransform = null;

export const registerResizeModule = (canvas, saveHistory) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
};

export const getCurrentSize = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return { width: 0, height: 0 };
  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (bgImage) {
    return {
      width: Math.round(bgImage.getScaledWidth()),
      height: Math.round(bgImage.getScaledHeight())
    };
  }
  return { width: canvas.width, height: canvas.height };
};

// --- äº¤äº’äº‹ä»¶å¤„ç† ---

const onPreviewMouseDown = (opt) => {
  if (!canvasRef?.value || !previewRect.value) return;
  // æ‹‰ä¼¸æ¨¡å¼ä¸‹ç¦æ­¢æ‹–æ‹½
  if (previewRect.value.data?.isStretch) return;

  const canvas = canvasRef.value;
  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  isDraggingImage = true;
  const pointer = canvas.getPointer(opt.e);
  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvas.defaultCursor = 'move';
};

const onPreviewMouseMove = (opt) => {
  if (!isDraggingImage || !canvasRef?.value) return;
  const canvas = canvasRef.value;
  const pointer = canvas.getPointer(opt.e);
  const deltaX = pointer.x - dragLastX;
  const deltaY = pointer.y - dragLastY;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (bgImage) {
    // è‡ªç”±æ‹–æ‹½ï¼Œæš‚ä¸çº¦æŸï¼Œä¾é  mouseUp æ—¶çš„å›å¼¹
    bgImage.left += deltaX;
    bgImage.top += deltaY;
    bgImage.setCoords();
  }
  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvas.requestRenderAll();
};

const onPreviewMouseUp = () => {
  if (isDraggingImage) {
    if (canvasRef?.value && previewRect.value) {
      const bgImage = canvasRef.value.getObjects().find(o => o.type === 'image');
      if (bgImage) {
        // ã€æ ¸å¿ƒå‡çº§ã€‘ä½¿ç”¨å¸¦åŠ¨ç”»çš„å¼¹æ€§å›å¼¹
        animateRebound(bgImage, previewRect.value, canvasRef.value);
      }
    }
    isDraggingImage = false;
    if (canvasRef?.value) canvasRef.value.defaultCursor = 'default';
  }
};

// --- è¾…åŠ©å‡½æ•° ---

const restoreImageState = (bgImage) => {
  if (originalTransform && bgImage) {
    bgImage.set({
      scaleX: originalTransform.scaleX,
      scaleY: originalTransform.scaleY,
      left: originalTransform.left,
      top: originalTransform.top,
      width: originalTransform.width,
      height: originalTransform.height,
      angle: originalTransform.angle,
      originX: originalTransform.originX,
      originY: originalTransform.originY
    });
    bgImage.setCoords();
  }
};

// --- é¢„è§ˆé€»è¾‘ ---

export const startPreview = (targetW, targetH, isStretch = false) => {
  const canvas = unref(canvasRef);
  if (!canvas || !targetW || !targetH) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  const currentImgCenter = bgImage.getCenterPoint();

  // ç¬¬ä¸€æ¬¡è¿›å…¥æ—¶å¤‡ä»½çŠ¶æ€
  if (!originalTransform) {
    originalSelectable = bgImage.selectable;
    originalEvented = bgImage.evented;
    originalTransform = {
      scaleX: bgImage.scaleX,
      scaleY: bgImage.scaleY,
      left: bgImage.left,
      top: bgImage.top,
      width: bgImage.width,
      height: bgImage.height,
      angle: bgImage.angle,
      originX: bgImage.originX,
      originY: bgImage.originY,
      centerX: currentImgCenter.x,
      centerY: currentImgCenter.y
    };
  }

  // æ¸…é™¤æ—§çš„é¢„è§ˆæ¡†
  if (previewRect.value) {
    canvas.remove(toRaw(previewRect.value));
    previewRect.value = null;
  }

  const targetCenter = { x: originalTransform.centerX, y: originalTransform.centerY };

  if (!isStretch) {
    restoreImageState(bgImage);
  } else {
    // æ‹‰ä¼¸æ¨¡å¼ä¸‹ç¦ç”¨å›¾ç‰‡äº¤äº’
    bgImage.selectable = false;
    bgImage.evented = false;
  }

  // è®¡ç®—é¢„è§ˆæ¡†å°ºå¯¸ï¼ˆä¿æŒå®½é«˜æ¯”ï¼‰
  const imgW = originalTransform.width * originalTransform.scaleX;
  const imgH = originalTransform.height * originalTransform.scaleY;
  const targetRatio = targetW / targetH;
  const imgRatio = imgW / imgH;

  let previewW, previewH;
  // é€»è¾‘ï¼šé¢„è§ˆæ¡†æ˜¯â€œé€‰åŒºâ€ï¼Œé€šå¸¸æœ€å¤§ä¸è¶…è¿‡å›¾ç‰‡åŸå°ºå¯¸ï¼Œæˆ–è€…æ ¹æ®æ¯”ä¾‹é€‚é…
  if (targetRatio > imgRatio) {
    previewW = imgW;
    previewH = imgW / targetRatio;
  } else {
    previewH = imgH;
    previewW = imgH * targetRatio;
  }

  // åˆ›å»ºé¢„è§ˆæ¡†
  const rect = new fabric.Rect({
    width: previewW,
    height: previewH,
    left: targetCenter.x,
    top: targetCenter.y,
    originX: 'center',
    originY: 'center',
    fill: 'transparent',
    stroke: '#409eff',
    strokeWidth: 2,
    strokeDashArray: [6, 6],
    selectable: false,
    evented: false,
    excludeFromExport: true,
    data: { isStretch }
  });

  previewRect.value = rect;
  canvas.add(rect);
  canvas.bringToFront(rect);

  if (!isStretch) {
    // ã€æ ¸å¿ƒå‡çº§ã€‘åˆå§‹çº¦æŸï¼šç¡®ä¿å›¾ç‰‡ä¸ç•™ç™½ï¼ˆä½¿ç”¨é€šç”¨ç¡¬çº¦æŸï¼‰
    constrainObjectToRect(bgImage, rect, canvas);

    // ç»‘å®šæ‹–æ‹½äº‹ä»¶
    canvas.on('mouse:down', onPreviewMouseDown);
    canvas.on('mouse:move', onPreviewMouseMove);
    canvas.on('mouse:up', onPreviewMouseUp);
  } else {
    // æ‹‰ä¼¸æ¨¡å¼ï¼šç›´æ¥è®©å›¾ç‰‡å¡«æ»¡é¢„è§ˆæ¡†ï¼ˆè§†è§‰é¢„è§ˆï¼‰
    bgImage.set({
      scaleX: previewW / originalTransform.width,
      scaleY: previewH / originalTransform.height,
      left: targetCenter.x,
      top: targetCenter.y,
      originX: 'center',
      originY: 'center'
    });
    // è§£ç»‘äº‹ä»¶
    canvas.off('mouse:down', onPreviewMouseDown);
    canvas.off('mouse:move', onPreviewMouseMove);
    canvas.off('mouse:up', onPreviewMouseUp);
  }

  bgImage.setCoords();
  canvas.requestRenderAll();
};

export const updatePreview = (targetW, targetH, isStretch = false) => {
  startPreview(targetW, targetH, isStretch);
};

export const stopPreview = () => {
  const canvas = unref(canvasRef);
  if (canvas) {
    canvas.off('mouse:down', onPreviewMouseDown);
    canvas.off('mouse:move', onPreviewMouseMove);
    canvas.off('mouse:up', onPreviewMouseUp);

    if (previewRect.value) {
      canvas.remove(toRaw(previewRect.value));
      previewRect.value = null;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (bgImage) {
      restoreImageState(bgImage);
      bgImage.selectable = originalSelectable;
      bgImage.evented = originalEvented;
    }

    canvas.discardActiveObject();
    originalTransform = null;
    canvas.requestRenderAll();
  }
};

// --- æ ¸å¿ƒåº”ç”¨é€»è¾‘ (é«˜æ¸…é‡åˆ¶) ---

export const applyResize = async (width, height, isStretch = false) => {
  const canvas = unref(canvasRef);
  if (!canvas || !previewRect.value) return;

  const targetW = Math.round(width);
  const targetH = Math.round(height);
  if (targetW <= 0 || targetH <= 0) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  // 1. é”å®šç°åœº
  const rect = previewRect.value;
  const prevVpt = [...canvas.viewportTransform];
  const prevZoom = canvas.getZoom();

  const rectCenterLogic = rect.getCenterPoint();
  // è®¡ç®—é¢„è§ˆæ¡†ä¸­å¿ƒåœ¨å½“å‰å±å¹•ä¸Šçš„ç»å¯¹ä½ç½®
  const rectCenterScreen = {
    x: rectCenterLogic.x * prevVpt[0] + prevVpt[4],
    y: rectCenterLogic.y * prevVpt[3] + prevVpt[5]
  };

  const finalPos = {
    logicalW: rect.width * rect.scaleX,
    logicalH: rect.height * rect.scaleY
  };

  originalTransform = null;

  // 2. ã€æ ¸å¿ƒå‡çº§ã€‘ä½¿ç”¨é€šç”¨ç¦»å±å·¥å…·ç”Ÿæˆé«˜æ¸…å›¾
  const dataURL = await renderHighResSnapshot(bgImage, targetW, targetH, (highResImg, tempCanvas) => {
    const multiplier = targetW / finalPos.logicalW;

    if (isStretch) {
      // æ‹‰ä¼¸æ¨¡å¼
      highResImg.set({
        originX: 'center', originY: 'center',
        left: targetW / 2, top: targetH / 2,
        scaleX: targetW / highResImg.width,
        scaleY: targetH / highResImg.height
      });
    } else {
      // ä¿æŒç›¸å¯¹ä½ç½®æ¨¡å¼
      const imgCenter = bgImage.getCenterPoint();
      const relCenterX = imgCenter.x - rectCenterLogic.x;
      const relCenterY = imgCenter.y - rectCenterLogic.y;

      highResImg.set({
        originX: 'center', originY: 'center',
        left: (targetW / 2) + (relCenterX * multiplier),
        top: (targetH / 2) + (relCenterY * multiplier),
        scaleX: bgImage.scaleX * multiplier,
        scaleY: bgImage.scaleY * multiplier,
        angle: bgImage.angle,
        flipX: bgImage.flipX,
        flipY: bgImage.flipY
      });
    }
  });

  // 3. åº”ç”¨å›ä¸»ç”»å¸ƒå¹¶ä¿®æ­£è§†å£
  bgImage.setSrc(dataURL, () => {
    // è®¡ç®—è§†å£ç¼©æ”¾è¡¥å¿
    const multiplier = targetW / finalPos.logicalW;
    const newZoom = prevZoom / multiplier;

    // ç‰©ç†é‡ç½®å›¾ç‰‡åˆ°ç”»å¸ƒä¸­å¿ƒ
    bgImage.set({
      originX: "center", originY: "center",
      angle: 0, flipX: false, flipY: false,
      scaleX: 1, scaleY: 1,
      left: canvas.width / 2,
      top: canvas.height / 2,
    });

    bgImage.setCoords();
    canvas.centerObject(bgImage);

    // è§†å£è¡¥å¿ï¼šå¯¹é½è§†è§‰ä¸­å¿ƒ
    const newCenterLogic = { x: canvas.width / 2, y: canvas.height / 2 };
    const newPanX = rectCenterScreen.x - newCenterLogic.x * newZoom;
    const newPanY = rectCenterScreen.y - newCenterLogic.y * newZoom;

    canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);

    stopPreview();
    canvas.requestRenderAll();
    canvas.fire('zoom:change', { from: 'resize-apply' });

    if (saveHistoryFn) saveHistoryFn();
  });
};
</file>

<file path="src/components/Workspace.vue">
<template>
  <div class="workspace-container">
    <div class="canvas-center" ref="canvasContainer" @contextmenu.prevent="handleRightClick">
      <canvas id="c"></canvas>
    </div>

    <FloatingObjectMenu />

    <CanvasContextMenu :visible="showContextMenu" :position="contextMenuPos" @close="closeContextMenu"
      @paste="handleMenuPaste" />

    <ShortcutsPanel :visible="showShortcuts" @close="showShortcuts = false" />

    <div class="zoom-controls">
      <button class="ie-btn ie-btn-circle" title="å¿«æ·é”®åˆ—è¡¨" @click="showShortcuts = true">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <rect x="2" y="4" width="20" height="16" rx="2" ry="2"></rect>
          <path d="M6 8h.01"></path>
          <path d="M10 8h.01"></path>
          <path d="M14 8h.01"></path>
          <path d="M18 8h.01"></path>
          <path d="M6 12h.01"></path>
          <path d="M18 12h.01"></path>
          <path d="M7 16h10"></path>
          <path d="M12 12v-1"></path>
        </svg>

      </button>

      <div class="divider"></div>

      <button class="ie-btn ie-btn-circle" title="ç¼©å°" @click="handleZoomOut">
        <svg viewBox="0 0 1024 1024" width="16" height="16">
          <path d="M128 544h768a32 32 0 1 0 0-64H128a32 32 0 1 0 0 64z" fill="currentColor" />
        </svg>
      </button>

      <span class="zoom-text" @click="handleReset" title="ç‚¹å‡»é‡ç½®ä¸º100%">
        {{ zoomPercentage }}%
      </span>

      <button class="ie-btn ie-btn-circle" title="æ”¾å¤§" @click="handleZoomIn">
        <svg viewBox="0 0 1024 1024" width="16" height="16">
          <path
            d="M480 480H160a32 32 0 0 0 0 64h320v320a32 32 0 0 0 64 0V544h320a32 32 0 0 0 0-64H544V160a32 32 0 0 0-64 0v320z"
            fill="currentColor" />
        </svg>
      </button>
    </div>
  </div>
</template>

<script setup>
import { onMounted, inject, ref, computed, onUnmounted, unref } from 'vue';
import FloatingObjectMenu from "./common/FloatingObjectMenu.vue";
import CanvasContextMenu from "./common/CanvasContextMenu.vue";
import { useObjectActions } from "@/composables/useObjectActions";
import { useKeyboardShortcuts } from "@/composables/useKeyboardShortcuts";
import ShortcutsPanel from "@/components/common/ShortcutsPanel.vue";

const props = defineProps({
  imageUrl: {
    type: String,
    default: ''
  },
});

const canvasAPI = inject('canvasAPI');
const canvasContainer = ref(null);
const pastePosition = ref(null);
const showShortcuts = ref(false);

// è®¡ç®—å±æ€§
const zoomPercentage = computed(() => {
  return canvasAPI?.zoom?.value ? Math.round(canvasAPI.zoom.value * 100) : 100;
});

// æ“ä½œå¤„ç†
const handleZoomIn = () => canvasAPI?.zoomIn && canvasAPI.zoomIn();
const handleZoomOut = () => canvasAPI?.zoomOut && canvasAPI.zoomOut();
const handleReset = () => canvasAPI?.zoomReset && canvasAPI.zoomReset();

const updateZoomState = () => {
  const fabricCanvas = canvasAPI?.canvas?.value;
  if (fabricCanvas && canvasAPI.zoom) {
    canvasAPI.zoom.value = fabricCanvas.getZoom();
  }
};

// === å³é”®èœå•é€»è¾‘ ===
const actions = useObjectActions();
useKeyboardShortcuts(actions);
const showContextMenu = ref(false);
const contextMenuPos = ref({ x: 0, y: 0 });

const closeContextMenu = () => {
  showContextMenu.value = false;
};

const onGlobalClick = () => {
  if (showContextMenu.value) closeContextMenu();
};

const handleRightClick = (e) => {
  if (e.target.closest('.floating-wrapper')) return;

  contextMenuPos.value = { x: e.clientX, y: e.clientY };

  const canvas = unref(canvasAPI.canvas);
  if (canvas) {
    const pointer = canvas.getPointer(e);
    pastePosition.value = pointer;
  }

  showContextMenu.value = true;
};

const handleMenuPaste = () => {
  actions.pasteActive(pastePosition.value);
};

onMounted(() => {
  window.addEventListener('click', onGlobalClick);
  if (canvasAPI && canvasAPI.init) {
    const width = canvasContainer.value.clientWidth || 1900;
    const height = canvasContainer.value.clientHeight || 1000;
    canvasAPI.init('c', width, height);

    const fabricCanvas = canvasAPI.canvas.value;
    if (fabricCanvas) {
      fabricCanvas.on('zoom:change', updateZoomState);
      fabricCanvas.on('mouse:wheel', updateZoomState);
    }
  } else {
    console.error('CanvasAPI not found.');
  }
});

onUnmounted(() => {
  const fabricCanvas = canvasAPI?.canvas?.value;
  if (fabricCanvas) {
    fabricCanvas.off('zoom:change', updateZoomState);
    fabricCanvas.off('mouse:wheel', updateZoomState);
  }
  window.removeEventListener('click', onGlobalClick);
});
</script>

<style scoped>
.workspace-container {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  background-color: #f0f2f5;
  overflow: hidden;
}

.canvas-center {
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
  width: 95%;
  height: 95%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.zoom-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background: white;
  padding: 8px 12px;
  border-radius: 24px;
  display: flex;
  align-items: center;
  gap: 8px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
  z-index: 100;
}

.zoom-text {
  font-size: 13px;
  color: #606266;
  min-width: 45px;
  text-align: center;
  user-select: none;
  font-variant-numeric: tabular-nums;
  cursor: pointer;
  transition: color 0.2s;
}

.zoom-text:hover {
  color: #409eff;
}

/* âœ… ä¿®å¤3: å¿…é¡»æ·»åŠ æŒ‰é’®æ ·å¼ï¼Œå¦åˆ™æŒ‰é’®æ˜¯é€æ˜çš„æˆ–è€…çœ‹ä¸åˆ° */
.ie-btn {
  border: none;
  background: transparent;
  cursor: pointer;
  color: #606266;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
}

.ie-btn:hover {
  color: #409eff;
  /* æˆ–è€…æ‚¨çš„ä¸»é¢˜è‰² */
  background-color: #ecf5ff;
}

.ie-btn-circle {
  width: 32px;
  height: 32px;
  border-radius: 50%;
}

.zoom-controls .divider {
  width: 1px;
  height: 16px;
  background: #ebeef5;
  margin: 0 4px;
}
</style>
</file>

<file path="src/style.css">
/* 1. ç§»é™¤å…¨å±€çš„ @import './reset.css'; é˜²æ­¢æ±¡æŸ“å®¿ä¸»ç¯å¢ƒ */
/* @import './reset.css'; */

/* 2. å°†åŸå…ˆ :root é‡Œçš„å˜é‡ç§»åˆ°å®¹å™¨å†…ï¼Œå˜æˆå±€éƒ¨å˜é‡ */
.image-editor-sdk-container {
  /* å®šä¹‰å±€éƒ¨å˜é‡ */
  --ie-font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  --ie-bg-color: #242424;
  --ie-text-color: rgba(255, 255, 255, 0.87);
  --ie-primary-color: #409eff;
  --ie-border-color: #dcdfe6;

  /* === æ ¸å¿ƒé‡ç½® (æ›¿ä»£ reset.css) === */
  /* å¼ºåˆ¶åœ¨è¿™ä¸ªå®¹å™¨å†…ä½¿ç”¨ border-boxï¼Œä¸ä¾èµ–å®¿ä¸»ç¯å¢ƒ */
  box-sizing: border-box;
  font-family: var(--ie-font-family);
  line-height: 1.5;
  font-weight: 400;
  color-scheme: light dark;
  color: var(--ie-text-color);
  background-color: var(--ie-bg-color);
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: left;
  /* è¦†ç›–å¯èƒ½å±…ä¸­çš„ body æ ·å¼ */

  /* ç¡®ä¿å®¹å™¨å†…çš„æ‰€æœ‰å…ƒç´ ç»§æ‰¿ box-sizing */
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    scrollbar-width: thin;
    scrollbar-color: rgba(144, 147, 153, 0.3) transparent;
  }

  /* === é“¾æ¥æ ·å¼ (Scope åŒ–) === */
  a {
    font-weight: 500;
    color: #646cff;
    text-decoration: inherit;
  }

  a:hover {
    color: #535bf2;
  }

  /* === æ ‡é¢˜æ ·å¼ === */
  h1 {
    font-size: 3.2em;
    line-height: 1.1;
    margin: 0;
    /* ç§»é™¤é»˜è®¤è¾¹è· */
  }

  /* === æŒ‰é’®æ ·å¼ (Scope åŒ–ï¼Œåªå½±å“ç¼–è¾‘å™¨å†…çš„ button) === */
  button {
    border-radius: 8px;
    border: 1px solid transparent;
    padding: 0.6em 1.2em;
    font-size: 1em;
    font-weight: 500;
    font-family: inherit;
    background-color: #1a1a1a;
    cursor: pointer;
    transition: border-color 0.25s;
    outline: none;
    margin: 0;
    /* ç§»é™¤é»˜è®¤è¾¹è· */
  }

  button:hover {
    border-color: #646cff;
  }

  /* é’ˆå¯¹äº®è‰²æ¨¡å¼çš„é€‚é… (å¦‚æœå®¿ä¸»æ˜¯äº®è‰²) */
  @media (prefers-color-scheme: light) {
    --ie-text-color: #213547;
    --ie-bg-color: #ffffff;

    a:hover {
      color: #747bff;
    }

    button {
      background-color: #f9f9f9;
    }
  }

  /* === IE UI Kit (ç»„ä»¶åº“æ ·å¼) === */
  .ie-actions {
    display: flex;

  }

  /* 1. æŒ‰é’®å¢å¼º */
  .ie-btn {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    height: 28px;
    padding: 0 12px;
    font-size: 13px;
    border-radius: 4px;
    border: 1px solid var(--ie-border-color);
    background-color: #fff;
    color: #606266;
    cursor: pointer;
    transition: .2s;
    outline: none;
  }

  .ie-btn:hover {
    color: var(--ie-primary-color);
    border-color: #c6e2ff;
    background-color: #ecf5ff;
  }

  .ie-btn:disabled {
    color: #c0c4cc;
    cursor: not-allowed;
    background-color: #fff;
    border-color: #ebeef5;
  }

  .ie-btn.ie-primary {
    color: #fff;
    background-color: var(--ie-primary-color);
    border-color: var(--ie-primary-color);
  }

  .ie-btn.ie-primary:hover {
    background-color: #66b1ff;
    border-color: #66b1ff;
  }

  .ie-btn-circle {
    width: 32px;
    padding: 0;
    border-radius: 50%;
  }

  /* 2. è¾“å…¥æ¡† */
  .ie-input {
    height: 32px;
    line-height: 32px;
    padding: 0 8px;
    border: 1px solid var(--ie-border-color);
    border-radius: 4px;
    color: #606266;
    background-color: #ffffff;
    width: 100%;
    box-sizing: border-box;
    appearance: textfield;
    font-size: 13px;
    /* ç»Ÿä¸€å­—ä½“ */
  }

  /* éšè—åŸç”Ÿæ—‹è½¬æŒ‰é’® */
  .ie-input::-webkit-outer-spin-button,
  .ie-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  /* Firefox */
  .ie-input[type=number] {
    -moz-appearance: textfield;
  }

  .ie-input:focus {
    border-color: var(--ie-primary-color);
    outline: none;
  }

  /* 3. åˆ†å‰²çº¿ */
  .ie-divider {
    width: 1px;
    height: 1em;
    margin: 6px 8px;
    background: var(--ie-border-color);
    display: inline-block;
    vertical-align: middle;
  }

  /* === å·¥å…·æ å¸ƒå±€æ ·å¼ === */

  .tool-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .tool-group {
    display: flex;
    flex-direction: column;
  }

  .tool-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    height: 50px;
    background-color: #f5f7fa;
    border-radius: 8px;
    cursor: pointer;
    color: #333;
    font-size: 14px;
    transition: all 0.2s ease;
    user-select: none;
  }

  .tool-item:hover {
    background-color: #e6e8eb;
    transform: translateY(-1px);
  }

  .tool-item.is-expanded {
    background-color: #ecf5ff;
    color: var(--ie-primary-color);
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
  }

  .tool-item .left {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .tool-item .right-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 20px;
  }

  .tool-item .arrow {
    font-size: 14px;
    color: #909399;
    transition: transform 0.3s;
  }

  .tool-item.is-expanded .arrow {
    transform: rotate(90deg);
    color: var(--ie-primary-color);
  }

  .tool-content {
    background-color: #fff;
    padding: 16px;
    border: 1px solid #eee;
    border-top: none;
    border-bottom-left-radius: 8px;
    border-bottom-right-radius: 8px;
    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.05);
    animation: slideDown 0.2s ease-out;
    color: #333;
    /* ç¡®ä¿æ–‡å­—é¢œè‰²æ­£ç¡® */
  }

  /* åŠ¨ç”» */
  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-5px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .status-dot {
    width: 8px;
    height: 8px;
    background-color: var(--ie-primary-color);
    border-radius: 50%;
  }

  .is-loading {
    animation: rotating 2s linear infinite;
    color: var(--ie-primary-color);
  }

  @keyframes rotating {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }
}

/* === toast æç¤º (å®ƒé€šå¸¸æŒ‚è½½åœ¨ body ä¸Šï¼Œæ‰€ä»¥æ”¾åœ¨å®¹å™¨å¤–é¢) === */
/* å¦‚æœ toast é€»è¾‘æ”¹ä¸ºæŒ‚è½½åˆ°å®¹å™¨å†…ï¼Œä¹Ÿå¯ä»¥ç§»è¿›å» */
.ie-toast {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 14px;
  z-index: 9999;
  animation: ie-fade-in 0.3s;
  pointer-events: none;
  /* é˜²æ­¢é®æŒ¡ç‚¹å‡» */
}

@keyframes ie-fade-in {
  from {
    opacity: 0;
    transform: translate(-50%, -10px);
  }

  to {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}

/* === å…¨å±€æ»šåŠ¨æ¡æ ·å¼ (Global Scrollbar) === */

/* 1. è®¾ç½®æ»šåŠ¨æ¡æ•´ä½“å®½é«˜ */
::-webkit-scrollbar {
  width: 6px;
  /* çºµå‘æ»šåŠ¨æ¡å®½åº¦ */
  height: 6px;
  /* æ¨ªå‘æ»šåŠ¨æ¡é«˜åº¦ */
}

/* 2. æ»šåŠ¨æ¡è½¨é“ (å¯é€‰ï¼Œé€šå¸¸è®¾ä¸ºé€æ˜) */
::-webkit-scrollbar-track {
  background: transparent;
}

/* 3. æ»šåŠ¨æ¡æ»‘å— */
::-webkit-scrollbar-thumb {
  background: rgba(144, 147, 153, 0.3);
  /* é»˜è®¤é¢œè‰²ï¼ŒåŠé€æ˜ç°è‰² */
  border-radius: 4px;
  /* åœ†è§’ */
  transition: background 0.3s;
}

/* 4. æ»‘å—æ‚¬åœçŠ¶æ€ (äº¤äº’åé¦ˆ) */
::-webkit-scrollbar-thumb:hover {
  background: rgba(144, 147, 153, 0.5);
  /* æ‚¬åœæ—¶åŠ æ·± */
}

/* === å®šä¹‰ä¸€ä¸ªå·¥å…·ç±»ï¼šç”¨äºéšè—æ»šåŠ¨æ¡ä½†ä¿ç•™æ»šåŠ¨åŠŸèƒ½ === */
/* ä½¿ç”¨æ–¹æ³•ï¼šåœ¨æ ‡ç­¾ä¸ŠåŠ  class="hide-scrollbar" */
.hide-scrollbar {
  scrollbar-width: none;
  /* Firefox */
  -ms-overflow-style: none;
  /* IE 10+ */
}

.hide-scrollbar::-webkit-scrollbar {
  display: none;
  /* Chrome/Safari/Webkit */
}

.ie-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--ie-primary-color); /* å…³é”®ï¼šä½¿ç”¨ä¸»é¢˜è‰²å˜é‡ */
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  margin-top: -6px; /* è°ƒæ•´å‚ç›´å¯¹é½ */
}

/* Firefox æµè§ˆå™¨ */
.ie-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border: 2px solid white;
  border-radius: 50%;
  background: var(--ie-primary-color); /* å…³é”®ï¼šä½¿ç”¨ä¸»é¢˜è‰²å˜é‡ */
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

/* ä¿®æ­£æ»‘å—è½¨é“é¢œè‰² (å¯é€‰ï¼Œè§†å…¨å±€æ ·å¼è€Œå®š) */
.ie-slider::-webkit-slider-runnable-track {
  height: 4px;
  background: #e4e7ed; /* è½¨é“èƒŒæ™¯è‰² */
  border-radius: 2px;
}

/* ... åŸæœ‰å†…å®¹ä¿æŒä¸å˜ ... */

/* === é€šç”¨å°å·æ•°å­—è¾“å…¥æ¡† (ä¿®å¤èƒŒæ™¯è‰²ä¸éšè—ç®­å¤´) === */
.ie-small-input {
  background-color: #ffffff; /* 1. å¼ºåˆ¶ç™½è‰²èƒŒæ™¯ */
  color: #606266;            /* 2. æ ‡å‡†æ–‡å­—é¢œè‰² */
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  text-align: center;
  outline: none;
  transition: border-color 0.2s;
  width: 50px;
  /* Firefox ç§»é™¤ç®­å¤´ */
  -moz-appearance: textfield; 
}

.ie-small-input:focus {
  border-color: var(--ie-primary-color);
}

/* Chrome, Safari, Edge, Opera ç§»é™¤ç®­å¤´ */
.ie-small-input::-webkit-outer-spin-button,
.ie-small-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

/* === æ ‡å‡†åŒ–æ•°å€¼è¾“å…¥æ¡† (é…åˆ Slider ä½¿ç”¨) === */
  /* å®ªæ³• 6.2 è§„å®šï¼šå›ºå®šå®½ 50pxï¼Œé«˜ 28px */
  .ie-input-number {
    width: 50px;
    height: 28px;
    padding: 0;
    border: 1px solid var(--ie-border-color);
    border-radius: 4px;
    text-align: center;
    font-size: 12px;
    color: #606266;
    background-color: #ffffff;
    outline: none;
    transition: border-color 0.2s;
    appearance: textfield; /* æ ‡å‡†å±æ€§ */
    -moz-appearance: textfield; /* Firefox */
  }

  .ie-input-number:focus {
    border-color: var(--ie-primary-color);
  }

  /* ç§»é™¤ Webkit æµè§ˆå™¨çš„åŸç”Ÿç®­å¤´ */
  .ie-input-number::-webkit-outer-spin-button,
  .ie-input-number::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
</file>

<file path="src/components/layout/NavBar.vue">
<template>
  <div class="navbar">
    <div class="logo">
      <slot name="logo">{{ textMap.title }}</slot>
    </div>
    <div class="ie-actions">
      <input type="file" ref="fileInput" @change="onFileSelected" style="display:none" accept="image/*" />

      <button class="ie-btn" @click="handleUpload">
        <svg width="14" height="14" viewBox="0 0 1024 1024" style="margin-right:4px;fill:currentColor">
          <path
            d="M544 253.696V704h-64V247.296L237.248 490.048 192 444.8 512 128l320 316.8-45.248 45.248L544 253.696zM160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64z" />
        </svg>
        {{ textMap.upload }}
      </button>

      <span class="ie-divider"></span>

      <button 
        class="ie-btn ie-btn-icon" 
        style="margin-right:8px; padding: 0 8px;" 
        title="æ’¤é”€" 
        @click="handleUndo" 
        :disabled="!state.canUndo"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 14 4 9l5-5"/>
          <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/>
        </svg>
      </button>
      
      <button 
        class="ie-btn ie-btn-icon" 
        style="margin-right:8px; padding: 0 8px;" 
        title="é‡åš" 
        @click="handleRedo" 
        :disabled="!state.canRedo"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M15 14l5-5-5-5"/>
          <path d="M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13"/>
        </svg>
      </button>
      <button class="ie-btn" style="margin-right:8px;" @click="handleReset">è¿˜åŸ</button>
      <button class="ie-btn ie-primary" @click="handleSave">{{ textMap.save }}</button>
    </div>
  </div>
</template>

<script setup>
import { inject, ref } from 'vue';
import { useEditorState } from '@/composables/useEditorState'; 
import { toast } from '@/utils/toast'; 
 

const { state } = useEditorState();

const canvasAPI = inject('canvasAPI');
const fileInput = ref(null);

const props = defineProps({
  textMap: {
    type: Object,
    default: () => ({}),
  },
});

const handleUpload = () => {
  fileInput.value.click();
};

const onFileSelected = (e) => {
  const file = e.target.files?.[0];
  if (file) {
    // æ£€æŸ¥ inject çš„ API æ˜¯å¦å­˜åœ¨
    if (!canvasAPI || !canvasAPI.initImage) { 
      toast.error('ç”»å¸ƒå°šæœªåˆå§‹åŒ–');
      return;
    }
    const url = URL.createObjectURL(file);
    
    // è°ƒç”¨ canvasAPI ä¸­çš„æ–¹æ³•
    canvasAPI.initImage(url); 
    
    e.target.value = '';
  }
};

const handleSave = () => {
  if (canvasAPI && canvasAPI.save) {
    canvasAPI.save(); 
  } else {
    toast.error('å¯¼å‡ºåŠŸèƒ½æœªå®ç°');
  }
};

const handleUndo = () => {
  // è°ƒç”¨ canvasAPI ä¸­çš„æ–¹æ³•
  if (canvasAPI && canvasAPI.undo) {
    canvasAPI.undo();
  }
};

const handleRedo = () => {
  // è°ƒç”¨ canvasAPI ä¸­çš„æ–¹æ³•
  if (canvasAPI && canvasAPI.redo) {
    canvasAPI.redo();
  }
};

const handleReset = () => {
  // è°ƒç”¨ canvasAPI ä¸­çš„æ–¹æ³•
  if (canvasAPI && canvasAPI.reset) {
    canvasAPI.reset();
  }
};
</script>

<style scoped>
.navbar {
  background: #fff;
  border-bottom: 1px solid #e4e7ed;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 20px;
}

.logo {
  font-weight: bold;
  font-size: 16px;
  color: #333;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustResize.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
          <path d="M15 3h6v6" />
          <path d="M9 21H3v-6" />
          <path d="M21 3l-7 7" />
          <path d="M3 21l7-7" />
        </svg>
        <span>è°ƒæ•´å°ºå¯¸</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">
      
      <div class="preset-grid">
        <div 
          class="preset-item custom-item"
          :class="{ active: isCustomMode }" 
          @click="selectCustomMode"
        >
        <span>è‡ªå®šä¹‰</span>
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="12" y1="8" x2="12" y2="16"></line>
            <line x1="8" y1="12" x2="16" y2="12"></line>
          </svg>
          
        </div>

        <div 
          v-for="(preset, index) in presets" 
          :key="index" 
          class="preset-item"
          :class="{ active: activePresetIndex === index }" 
          @click="selectPreset(preset, index)"
        >
          <span class="preset-name">{{ preset.label }}</span>
          <span class="preset-dim">{{ preset.w }}Ã—{{ preset.h }}</span>
        </div>
      </div>

      <div class="resize-input-box">
        
        <div class="input-controls">
           <div class="input-wrapper">
             <input 
               type="number" 
               v-model.number="width" 
               class="ie-input" 
               @input="onInputChanged" 
             >
             <span class="suffix">W</span>
           </div>

           <div class="link-icon-btn" @click="toggleAdaptive" :title="isAdaptive ? 'é”å®šæ¯”ä¾‹' : 'è‡ªç”±æ¯”ä¾‹'">
              <svg v-if="isAdaptive" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#409eff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
              </svg>
              <svg v-else width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6">
                 <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                 <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                 <line x1="4" y1="4" x2="20" y2="20" stroke="#999"></line>
              </svg>
           </div>

           <div class="input-wrapper">
             <input 
               type="number" 
               v-model.number="height" 
               class="ie-input" 
               @input="onInputChanged"
             >
             <span class="suffix">H</span>
           </div>
        </div>

        <div class="switch-row">
          <div 
            class="ie-switch" 
            :class="{ 'is-checked': isAdaptive }" 
            @click="toggleAdaptive"
          >
            <span class="ie-switch-core"></span>
          </div>
          <span class="switch-label">é”å®šé•¿å®½æ¯” (ä¿çœŸæ¨¡å¼)</span>
        </div>

        <!-- <div class="reset-row">
           <span class="reset-link" @click="resetToOriginal">æ¢å¤åŸå›¾å°ºå¯¸</span>
        </div> -->

      </div>

      <div class="action-buttons">
        <button class="ie-btn ie-primary full" @click="handleApply">åº”ç”¨ä¿®æ”¹</button>
        <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
      </div>

    </div>
  </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted, nextTick, computed } from 'vue';
import { registerResizeModule, getCurrentSize, applyResize, startPreview, updatePreview, stopPreview } from './useCanvasResize';

const props = defineProps({
  isExpanded: { type: Boolean, default: false }
});

const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

// === çŠ¶æ€å®šä¹‰ ===
const width = ref(0);
const height = ref(0);
const isAdaptive = ref(true); 
const originalRatio = ref(1); 
const activePresetIndex = ref(-1); 
const isInternalUpdate = ref(false); // é˜²æ­¢å¾ªç¯æ›´æ–°

// é¢„è®¾æ•°æ® (å¯æ ¹æ®éœ€è¦æ‰©å±•)
const presets = [
  { label: 'æ–¹å½¢ä¸»å›¾', w: 800, h: 800 },
  { label: 'Temuæœè£…å›¾', w: 1340, h: 1785 },
  { label: 'æ–¹å½¢ä¸»å›¾', w: 1000, h: 1000 },
  { label: 'ç«–å›¾ä¸»å›¾', w: 750, h: 1000 },
   {label: 'æ–¹å½¢ä¸»å›¾', w: 500, h: 500 },
   { label: 'ç«–å›¾ä¸»å›¾', w: 1000, h: 1200 },
  { label: 'Youtubeè§†é¢‘å°é¢', w: 1280, h: 720 },
  { label: 'Pinterestå¸–å­', w: 750, h: 1120 },
  { label: 'Facebookå°é¢', w: 851, h: 315 },
];

const isCustomMode = computed(() => activePresetIndex.value === -1);

// === æ ¸å¿ƒé€»è¾‘ï¼šè·å–å½“å‰åº”éµå¾ªçš„æ¯”ä¾‹ ===
// å¯¹åº”è¡¨æ ¼é€»è¾‘ï¼šå¦‚æœæ˜¯é¢„è®¾ï¼Œç”¨é¢„è®¾æ¯”ä¾‹ï¼›å¦‚æœæ˜¯è‡ªå®šä¹‰ï¼Œç”¨åŸå›¾æ¯”ä¾‹
const currentTargetRatio = computed(() => {
  if (activePresetIndex.value >= 0) {
    const p = presets[activePresetIndex.value];
    return p.h !== 0 ? (p.w / p.h) : 1; 
  } else {
    return originalRatio.value;
  }
});

// === åˆå§‹åŒ– ===
const initSize = () => {
  if (canvasAPI && canvasAPI.canvas) {
    registerResizeModule(canvasAPI.canvas, canvasAPI.saveHistory);
    const size = getCurrentSize();
    
    if (size.height > 0) {
      originalRatio.value = size.width / size.height;
    }

    width.value = size.width;
    height.value = size.height;
    activePresetIndex.value = -1; // é»˜è®¤é€‰ä¸­è‡ªå®šä¹‰
    isAdaptive.value = true;      // é»˜è®¤å¼€å¯ä¿çœŸ
    
    // ç«‹å³å¯åŠ¨é¢„è§ˆ (æ˜¾ç¤ºè“è‰²è™šçº¿æ¡†)
    nextTick(() => {
      startPreview(width.value, height.value, !isAdaptive.value);
    });
  }
};

// === äº¤äº’é€»è¾‘ ===

const selectCustomMode = () => {
  activePresetIndex.value = -1;
  // åˆ‡æ¢åˆ°è‡ªå®šä¹‰æ—¶ï¼Œæ¢å¤åˆ°åŸå›¾å°ºå¯¸ï¼Œæˆ–è€…ä¿æŒå½“å‰è¾“å…¥ä½†åˆ‡æ¢æ¯”ä¾‹åŸºå‡†
  // è¿™é‡Œé€‰æ‹©ï¼šé‡ç½®å›åŸå›¾å°ºå¯¸ï¼Œç¬¦åˆç›´è§‰
  resetToOriginal(); 
};

const selectPreset = (preset, index) => {
  activePresetIndex.value = index;
  // é€‰ä¸­é¢„è®¾ -> ç«‹å³åº”ç”¨é¢„è®¾æ•°å€¼
  isInternalUpdate.value = true;
  width.value = preset.w;
  height.value = preset.h;
  // é€‰ä¸­é¢„è®¾é€šå¸¸æ„å‘³ç€ç”¨æˆ·å¸Œæœ›éµå¾ªè¯¥æ¯”ä¾‹ï¼Œæ‰€ä»¥è‡ªåŠ¨å¼€å¯ä¿çœŸ
  isAdaptive.value = true; 
  nextTick(() => { 
    isInternalUpdate.value = false; 
    updatePreviewBox(); // æ›´æ–°é¢„è§ˆ
  });
};

const toggleAdaptive = () => {
  isAdaptive.value = !isAdaptive.value;
  // æ‰“å¼€å¼€å…³ç¬é—´ï¼Œæ ¹æ®å½“å‰ Width å’Œ ç›®æ ‡æ¯”ä¾‹ ä¿®æ­£ Height
  if (isAdaptive.value && width.value > 0) {
    isInternalUpdate.value = true;
    height.value = Math.round(width.value / currentTargetRatio.value);
    nextTick(() => { 
      isInternalUpdate.value = false; 
      updatePreviewBox();
    });
  } else {
    // ä¿®æ”¹ç‚¹ 2ï¼šå¦‚æœæ˜¯å…³é—­ä¿çœŸï¼ˆè¿›å…¥æ‹‰ä¼¸æ¨¡å¼ï¼‰ï¼Œä¹Ÿç«‹å³åˆ·æ–°é¢„è§ˆï¼Œè§¦å‘å›¾ç‰‡æ‹‰ä¼¸æ•ˆæœ
    updatePreviewBox();
  }
};

const resetToOriginal = () => {
  const size = getCurrentSize();
  width.value = size.width;
  height.value = size.height;
  // æ¢å¤åŸå°ºå¯¸é¢„è§ˆ
  updatePreviewBox();
};

// === ç›‘å¬è¾“å…¥ (å®ç°è¡¨æ ¼çŸ©é˜µé€»è¾‘) ===

// ç›‘å¬å®½åº¦å˜åŒ–
watch(width, (newW) => {
  if (isInternalUpdate.value) return; 

  // è¡¨æ ¼é€»è¾‘ 1 & 3 & 5: ä¿çœŸå¼€å¯ -> è‡ªåŠ¨è®¡ç®—é«˜åº¦
  if (isAdaptive.value && newW > 0) {
    isInternalUpdate.value = true; 
    height.value = Math.round(newW / currentTargetRatio.value);
    nextTick(() => { isInternalUpdate.value = false; });
  }
  // è¡¨æ ¼é€»è¾‘ 2 & 4: ä¿çœŸå…³é—­ -> é«˜åº¦ä¸å˜ (å¯¼è‡´å˜å½¢)
});

// ç›‘å¬é«˜åº¦å˜åŒ–
watch(height, (newH) => {
  if (isInternalUpdate.value) return;

  if (isAdaptive.value && newH > 0) {
    isInternalUpdate.value = true;
    width.value = Math.round(newH * currentTargetRatio.value);
    nextTick(() => { isInternalUpdate.value = false; });
  }
});

// === é¢„è§ˆæ›´æ–° ===
// åªè¦è¾“å…¥å˜åŒ–ï¼Œå°±é€šçŸ¥ canvas æ›´æ–°è™šçº¿æ¡†
const onInputChanged = () => {
  updatePreviewBox();
};

const updatePreviewBox = () => {
  if (width.value > 0 && height.value > 0) {
    // ä¿®æ”¹ç‚¹ 3ï¼šä¼ å…¥æ‹‰ä¼¸çŠ¶æ€ (!isAdaptive.value)
    updatePreview(width.value, height.value, !isAdaptive.value);
  } else {
    stopPreview();
  }
};

// ç›‘å¬å±•å¼€çŠ¶æ€
watch(() => props.isExpanded, (val) => {
  if (val) initSize();
  else stopPreview();
});

// === åº”ç”¨ä¸å–æ¶ˆ ===
const handleApply = () => {
  // ä¿®æ”¹ç‚¹ 4ï¼šä¼ å…¥æ‹‰ä¼¸çŠ¶æ€
  applyResize(width.value, height.value, !isAdaptive.value);
  emit('toggle');
};

const handleCancel = () => {
  stopPreview(); 
  emit('toggle');
}

const handleToggle = () => {
  emit('toggle');
};

onMounted(() => {
  if (props.isExpanded) initSize();
});

onUnmounted(() => stopPreview());
</script>

<style scoped>
/* Grid å¸ƒå±€å®ç°çŸ©é˜µæ•ˆæœ */
.preset-grid {
  display: grid;
  grid-template-columns: 1fr 1fr; /* ä¸¤åˆ— */
  gap: 8px;
  margin-bottom: 16px;
  max-height: 280px;
  overflow-y: auto;
}

.preset-item {
  background-color: #f5f7fa;
  padding: 10px;
  border-radius: 6px;
  font-size: 13px;
  color: #606266;
  cursor: pointer;
  border: 1px solid transparent;
  display: flex;
  flex-direction: column; /* å‚ç›´æ’åˆ—æ–‡å­— */
  align-items: center;
  justify-content: space-between;
  text-align: center;
  transition: all 0.2s;
}

.preset-item:hover {
  background-color: #e6f7ff;
  border-color: #c0c4cc;
}

.preset-item.active {
  background-color: #ecf5ff;
  color: #409eff;
  border-color: #409eff;
  font-weight: 500;
}

/* è‡ªå®šä¹‰é¡¹ç‰¹æ®Šæ ·å¼ */
.custom-item {
  flex-direction: row; /* æ¨ªå‘ */
  grid-column: span 2; /* å æ»¡ä¸€è¡Œ */
  background-color: #fff;
  border: 1px dashed #dcdfe6;
}
.custom-item.active {
  border-style: solid;
}

.preset-name {
  font-weight: 500;
  margin-bottom: 2px;
}
.preset-dim {
  font-size: 11px;
  color: #909399;
}

/* è¾“å…¥æ¡†åŒºåŸŸæ ·å¼ä¼˜åŒ– */
.resize-input-box {
  background-color: #fff;
  padding: 4px 0;
}

.input-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.input-wrapper {
  position: relative;
  width: 40%;
}

.ie-input {
  text-align: center;
  padding-right: 20px;
  font-weight: bold;
  color: #333;
  width: 100%;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  height: 32px;
  font-size: 13px;
}
.ie-input:focus {
  border-color: #409eff;
  outline: none;
}

.suffix {
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  color: #c0c4cc;
  font-size: 11px;
  pointer-events: none;
}

.link-icon-btn {
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
}
.link-icon-btn:hover {
  background-color: #f0f0f0;
}

.switch-row {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 12px;
}
.switch-label {
  font-size: 12px;
  color: #606266;
  margin-left: 8px;
  cursor: pointer;
}

.ie-switch {
  position: relative;
  display: inline-flex;
  align-items: center;
  width: 32px;
  height: 16px;
  border-radius: 10px;
  background-color: #dcdfe6;
  cursor: pointer;
  transition: background-color 0.3s;
}
.ie-switch.is-checked {
  background-color: #409eff;
}
.ie-switch-core {
  position: absolute;
  top: 2px;
  left: 2px;
  border-radius: 100%;
  width: 12px;
  height: 12px;
  background-color: #fff;
  transition: all 0.3s;
}
.ie-switch.is-checked .ie-switch-core {
  left: 100%;
  margin-left: -14px;
}

.reset-row {
  text-align: center;
  margin-bottom: 10px;
}
.reset-link {
  font-size: 12px;
  color: #909399;
  cursor: pointer;
  text-decoration: underline;
}
.reset-link:hover {
  color: #409eff;
}

.action-buttons {
  display: flex;
  gap: 10px;
}
.full {
  flex: 1;
}

.tool-item:hover .arrow { transform: translateX(2px); transition: transform 0.2s; }
.tool-content { padding: 16px; border: 1px solid #eee; border-top: none; }
</style>
</file>

<file path="src/components/modules/adjust/useCanvasCrop.js">
// src/components/modules/adjust/useCanvasCrop.js
import { ref, shallowRef, toRaw } from "vue";
import { fabric } from "fabric";

// 1. å¼•å…¥é€šç”¨è§„èŒƒå·¥å…·
import { getLogicRect, animateRebound, constrainObjectToRect } from '@/composables/useConstraint';
import { renderHighResSnapshot } from '@/composables/useOffscreenHelper';

// === çŠ¶æ€å˜é‡ ===
const cropObject = shallowRef(null);
const isManualCropping = ref(false);
const isCropping = ref(false);
const isRatioLocked = ref(false);
const currentAspectRatio = ref(null);

// ç”¨äºå®æ—¶å‘ UI ä¼ é€’å½“å‰é€‰åŒº/è£å‰ªæ¡†çš„å®½é«˜
const currentSelectionDims = ref({ width: 0, height: 0 });

// å†…éƒ¨å¼•ç”¨
let canvasRef = null;
let saveHistoryFn = null;
let zoomToRectFn = null;

// å†…éƒ¨å˜é‡
let selectionRect = null;
let maskRect = null;
let selectionStartX = 0;
let selectionStartY = 0;
let aspectRatioValue = null;
let savedWheelListeners = [];

// æ‹–æ‹½å›¾ç‰‡ç›¸å…³å˜é‡
let isDraggingImage = false;
let dragLastX = 0;
let dragLastY = 0;

// æ ‡å¿—ä½ï¼šæ˜¯å¦æ­£åœ¨åº”ç”¨è£å‰ª
let isApplyingCrop = false;

export const registerCropModule = (canvas, saveHistory, zoomToRect) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
  zoomToRectFn = zoomToRect;
};

// =========================================================
// è¾…åŠ©å·¥å…·
// =========================================================

const updateCurrentDims = (obj) => {
  if (!obj || !canvasRef?.value) return;
  const rect = getLogicRect(obj, canvasRef.value);
  currentSelectionDims.value = {
    width: Math.round(rect.width),
    height: Math.round(rect.height)
  };
};

const preventZoomWheel = (opt) => {
  if (!opt || !opt.e) return;
  opt.e.preventDefault();
  opt.e.stopPropagation();
  if (opt.e.stopImmediatePropagation) opt.e.stopImmediatePropagation();
};

// =========================================================
// æ‹–åŠ¨å›¾ç‰‡çš„æ ¸å¿ƒé€»è¾‘ (é›†æˆé€šç”¨å›å¼¹)
// =========================================================
const onCropMouseDown = (opt) => {
  if (!canvasRef?.value || !cropObject.value) return;
  const target = opt.target;
  // å¿…é¡»ç‚¹å‡»åœ¨å‰ªè£æ¡†ä¸Šï¼ˆä½œä¸ºå®¹å™¨ï¼‰
  if (target !== cropObject.value) return;

  const activeObj = canvasRef.value.getActiveObject();
  if (activeObj && activeObj.__corner) return;

  // å¼€å§‹æ‹–åŠ¨å›¾ç‰‡
  isDraggingImage = true;
  const pointer = canvasRef.value.getPointer(opt.e);
  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvasRef.value.defaultCursor = 'move';
};

const onCropMouseMove = (opt) => {
  if (!isDraggingImage || !canvasRef?.value) return;
  const canvas = canvasRef.value;
  const pointer = canvas.getPointer(opt.e);
  const deltaX = pointer.x - dragLastX;
  const deltaY = pointer.y - dragLastY;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');

  if (bgImage) {
    // è‡ªç”±æ‹–æ‹½ï¼Œæš‚ä¸çº¦æŸï¼Œä¾é  mouseUp æ—¶çš„å›å¼¹
    bgImage.left += deltaX;
    bgImage.top += deltaY;
    bgImage.setCoords();
  }

  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvas.requestRenderAll();
};

const onCropMouseUp = () => {
  if (isDraggingImage) {
    if (canvasRef?.value && cropObject.value) {
      const bgImage = canvasRef.value.getObjects().find(o => o.type === 'image');
      if (bgImage) {
        // ã€æ ¸å¿ƒå‡çº§ã€‘ä½¿ç”¨é€šç”¨åŠ¨ç”»å›å¼¹ï¼Œç¡®ä¿å›¾ç‰‡å§‹ç»ˆå¡«æ»¡è£å‰ªæ¡†
        animateRebound(bgImage, cropObject.value, canvasRef.value);
      }
    }

    isDraggingImage = false;
    if (canvasRef?.value) canvasRef.value.defaultCursor = 'default';
  }
};

// =========================================================
// é¢æ¿å¼€å…³
// =========================================================
export const openCropPanel = () => {
  if (!canvasRef?.value) return;
  if (isCropping.value) return;

  isApplyingCrop = false;

  const canvas = canvasRef.value;
  canvas.fire('zoom:change', { from: 'crop-module' });

  if (canvas.__eventListeners && canvas.__eventListeners['mouse:wheel']) {
    savedWheelListeners = [...canvas.__eventListeners['mouse:wheel']];
    canvas.off('mouse:wheel');
  }
  canvas.on('mouse:wheel', preventZoomWheel);

  isCropping.value = true;
};

export const closeCropPanel = () => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;

  if (isApplyingCrop) {
    if (isManualCropping.value) endManualSelectionMode();
    isCropping.value = false;
    return;
  }

  if (isManualCropping.value) {
    endManualSelectionMode();
  }

  cancelCrop();
  isCropping.value = false;

  canvas.discardActiveObject();
  canvas.requestRenderAll();
  canvas.fire('zoom:change');
};

// =========================================================
// çº¦æŸè£å‰ªæ¡† (ä¿æŒåœ¨å›¾ç‰‡èŒƒå›´å†…)
// æ³¨æ„ï¼šè£å‰ªæ¡†çš„çº¦æŸé€»è¾‘ç‰¹æ®Šï¼ˆBox inside Imageï¼‰ï¼Œä¸ Resizeï¼ˆImage inside Boxï¼‰ç›¸å
// å› æ­¤ä¿ç•™äº†éƒ¨åˆ†ç‰¹å®šçš„å°ºå¯¸æ£€æŸ¥é€»è¾‘ï¼Œä½†ä½ç½®ä¿®æ­£å¯å¤ç”¨é€»è¾‘
// =========================================================
export const constrainCrop = (activeObj) => {
  if (!canvasRef?.value || !activeObj) return;
  const canvas = canvasRef.value;

  const bgImage = canvas.getObjects().find((o) => o.type === "image");
  if (!bgImage) return;

  const bgRect = getLogicRect(bgImage, canvas);
  const bgWidth = bgRect.width;
  const bgHeight = bgRect.height;
  const bgLeft = bgRect.left;
  const bgTop = bgRect.top;

  let currentScaleX = activeObj.scaleX;
  let currentScaleY = activeObj.scaleY;

  // 1. å°ºå¯¸çº¦æŸï¼šè£å‰ªæ¡†ä¸èƒ½æ¯”å›¾ç‰‡å¤§
  let cropCurrentWidth = activeObj.width * currentScaleX;
  let cropCurrentHeight = activeObj.height * currentScaleY;
  let sizeChanged = false;

  if (cropCurrentWidth > bgWidth + 0.5) {
    currentScaleX = bgWidth / activeObj.width;
    sizeChanged = true;
  }
  if (cropCurrentHeight > bgHeight + 0.5) {
    currentScaleY = bgHeight / activeObj.height;
    sizeChanged = true;
  }
  if (sizeChanged) {
    activeObj.set({ scaleX: currentScaleX, scaleY: currentScaleY });
    activeObj.setCoords();
  }

  // 2. ä½ç½®çº¦æŸï¼šè£å‰ªæ¡†å¿…é¡»åœ¨å›¾ç‰‡å†…éƒ¨
  // è®¡ç®—è¾¹ç•Œ
  const finalCropWidth = activeObj.getScaledWidth();
  const finalCropHeight = activeObj.getScaledHeight();

  // é™åˆ¶å·¦ä¸Šè§’åæ ‡
  const minLeft = bgLeft;
  const maxLeft = bgLeft + bgWidth - finalCropWidth;
  const minTop = bgTop;
  const maxTop = bgTop + bgHeight - finalCropHeight;

  let newLeft = Math.max(minLeft, Math.min(activeObj.left, maxLeft));
  let newTop = Math.max(minTop, Math.min(activeObj.top, maxTop));

  activeObj.set({ left: newLeft, top: newTop });
  activeObj.setCoords();

  updateCurrentDims(activeObj);
  canvas.requestRenderAll();
};

// =========================================================
// å–æ¶ˆè£å‰ª (æ¸…ç†)
// =========================================================
export const cancelCrop = (shouldRender = true) => {
  if (canvasRef?.value && cropObject.value) {
    const rawObj = toRaw(cropObject.value);

    // è§£ç»‘æ‹–æ‹½å›¾ç‰‡äº‹ä»¶
    canvasRef.value.off('mouse:down', onCropMouseDown);
    canvasRef.value.off('mouse:move', onCropMouseMove);
    canvasRef.value.off('mouse:up', onCropMouseUp);

    canvasRef.value.remove(rawObj);
    cropObject.value = null;
    isDraggingImage = false;

    if (shouldRender) {
      canvasRef.value.renderAll();
    }
  }
};

// ... (æ‰‹åŠ¨é€‰åŒºé€»è¾‘ä¿æŒä¸å˜) ...
export const endManualSelectionMode = () => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;
  canvas.defaultCursor = 'default';
  canvas.hoverCursor = 'move';
  canvas.selection = true;
  canvas.getObjects().forEach(o => {
    if (o !== maskRect && o !== selectionRect) {
      o.selectable = true;
      o.evented = true;
    }
  });
  canvas.off('mouse:down', onSelectionDown);
  canvas.off('mouse:move', onSelectionMove);
  canvas.off('mouse:up', onSelectionUp);
  if (selectionRect) { canvas.remove(selectionRect); selectionRect = null; }
  if (maskRect) { canvas.remove(maskRect); maskRect = null; }
  isManualCropping.value = false;
  canvas.requestRenderAll();
};

const onSelectionDown = (opt) => {
  const canvas = canvasRef.value;
  if (!canvas) return;
  const pointer = canvas.getPointer(opt.e);
  selectionStartX = pointer.x;
  selectionStartY = pointer.y;
  selectionRect = new fabric.Rect({
    left: selectionStartX, top: selectionStartY, width: 0, height: 0,
    fill: 'transparent', stroke: '#fff', strokeWidth: 2, strokeDashArray: [6, 6],
    selectable: false, evented: false
  });
  canvas.add(selectionRect);
  canvas.bringToFront(selectionRect);
};

const onSelectionMove = (opt) => {
  if (!selectionRect || !canvasRef.value) return;
  const pointer = canvasRef.value.getPointer(opt.e);
  let w = Math.abs(pointer.x - selectionStartX);
  let h = Math.abs(pointer.y - selectionStartY);
  let left = selectionStartX;
  let top = selectionStartY;
  if (pointer.x < selectionStartX) left = pointer.x;
  if (pointer.y < selectionStartY) top = pointer.y;
  selectionRect.set({ left, top, width: w, height: h });
  currentSelectionDims.value = { width: Math.round(w), height: Math.round(h) };
  canvasRef.value.requestRenderAll();
};

const onSelectionUp = () => {
  if (!selectionRect) {
    endManualSelectionMode();
    if (cropObject.value) cancelCrop();
    return;
  }
  const box = {
    left: selectionRect.left, top: selectionRect.top,
    width: selectionRect.width, height: selectionRect.height
  };
  endManualSelectionMode();
  if (box.width < 10 || box.height < 10) return;
  startCrop(null, box);
  if (zoomToRectFn) zoomToRectFn(box);
};

export const startManualSelection = () => {
  if (!canvasRef?.value) return;
  if (isManualCropping.value) endManualSelectionMode();
  const canvas = canvasRef.value;
  cancelCrop();
  canvas.getObjects().forEach(o => { o.selectable = false; o.evented = false; });
  maskRect = new fabric.Rect({
    left: -5000, top: -5000, width: 20000, height: 20000,
    fill: 'rgba(0, 0, 0, 0.45)', selectable: false, evented: false, excludeFromExport: true
  });
  canvas.add(maskRect);
  canvas.defaultCursor = 'crosshair';
  canvas.hoverCursor = 'crosshair';
  canvas.selection = false;
  isManualCropping.value = true;
  canvas.on('mouse:down', onSelectionDown);
  canvas.on('mouse:move', onSelectionMove);
  canvas.on('mouse:up', onSelectionUp);
  canvas.requestRenderAll();
};

// ... (setCropRatio ä¿æŒä¸å˜) ...
export const setCropRatio = (ratio) => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;
  if (ratio === null) {
    isRatioLocked.value = false;
    currentAspectRatio.value = null;
    if (cropObject.value) {
      cropObject.value.set({ lockUniScaling: false });
      canvas.requestRenderAll();
    }
    return;
  }
  isRatioLocked.value = true;
  currentAspectRatio.value = ratio;
  let baseW, baseH, left, top;
  const activeObj = canvas.getObjects().find((obj) => obj.type === "image");
  if (!activeObj) return;

  // ä½¿ç”¨ getLogicRect è·å–å‡†ç¡®çš„åŒ…å›´ç›’
  const rect = getLogicRect(activeObj, canvas);
  baseW = rect.width; baseH = rect.height; left = rect.left; top = rect.top;

  const currentRatio = baseW / baseH;
  let newW, newH;
  if (currentRatio > ratio) {
    newH = baseH; newW = newH * ratio; left += (baseW - newW) / 2;
  } else {
    newW = baseW; newH = newW / ratio; top += (baseH - newH) / 2;
  }
  if (cropObject.value) {
    cropObject.value.set({
      width: newW, height: newH, left: left, top: top,
      scaleX: 1, scaleY: 1, lockUniScaling: false
    });
    cropObject.value.setCoords();
    constrainCrop(cropObject.value);
    canvas.requestRenderAll();
  } else {
    startCrop(ratio, { left, top, width: newW, height: newH });
  }
};

// =========================================================
// startCrop
// =========================================================
export const startCrop = (aspectRatio = null, customBox = null) => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;
  if (isManualCropping.value) endManualSelectionMode();

  aspectRatioValue = aspectRatio || null;
  let activeObj = canvas.getObjects().find((obj) => obj.type === "image");
  if (!activeObj) return;

  cancelCrop();

  const rect = getLogicRect(activeObj, canvas);
  let width, height, left, top;

  if (customBox) {
    width = customBox.width; height = customBox.height; left = customBox.left; top = customBox.top;
  } else {
    const imgWidth = rect.width; const imgHeight = rect.height;
    width = imgWidth * 1; height = imgHeight * 1;
    if (aspectRatio) {
      height = width / aspectRatio;
      if (height > imgHeight) {
        height = imgHeight; width = height * aspectRatio;
      }
      isRatioLocked.value = true; currentAspectRatio.value = aspectRatio;
    } else {
      isRatioLocked.value = false; currentAspectRatio.value = null;
    }
    left = rect.left + (imgWidth - width) / 2;
    top = rect.top + (imgHeight - height) / 2;
  }

  const cropZone = new fabric.Rect({
    left: left, top: top, width: width, height: height,
    fill: "transparent", stroke: "#409eff", strokeWidth: 2,
    cornerColor: "white", cornerStrokeColor: "#409eff", cornerSize: 12,
    transparentCorners: false, lockRotation: true, hasRotatingPoint: false,
    lockUniScaling: false,
    lockMovementX: true,
    lockMovementY: true
  });
  if (aspectRatio) cropZone.set("height", width / aspectRatio);

  canvas.add(cropZone);
  canvas.setActiveObject(cropZone);
  cropObject.value = cropZone;
  canvas.renderAll();
  updateCurrentDims(cropZone);
  constrainCrop(cropZone);

  // ç»‘å®šæ‹–å›¾äº‹ä»¶
  canvas.on('mouse:down', onCropMouseDown);
  canvas.on('mouse:move', onCropMouseMove);
  canvas.on('mouse:up', onCropMouseUp);
};

// =========================================================
// ç¡®è®¤è£å‰ª (é«˜æ¸…é‡åˆ¶ç‰ˆ)
// =========================================================
export const confirmCrop = async () => {
  if (!canvasRef?.value || !cropObject.value) return Promise.resolve();
  const canvas = canvasRef.value;
  const cropRect = cropObject.value;
  const bgImage = canvas.getObjects().find((o) => o.type === "image");
  if (!bgImage) { cancelCrop(); return Promise.resolve(); }

  isApplyingCrop = true;

  // 1. è·å–è£å‰ªåŒºåŸŸçš„é€»è¾‘ä¿¡æ¯
  const cropLogicRect = getLogicRect(cropRect, canvas);
  const bgLogicRect = getLogicRect(bgImage, canvas);

  // 2. è®¡ç®—ç›®æ ‡å¯¼å‡ºå°ºå¯¸ (åŸºäºåŸå›¾åˆ†è¾¨ç‡)
  // å¦‚æœå›¾ç‰‡è¢«ç¼©æ”¾äº†(scale=0.5), æˆ‘ä»¬å¸Œæœ›è£å‰ªå‡ºæ¥çš„å›¾æ˜¯åŸºäºåŸå›¾å¤§å°çš„ï¼Œæ‰€ä»¥ç›®æ ‡å°ºå¯¸è¦é™¤ä»¥ scale
  const scaleFactor = bgImage.scaleX; // å‡è®¾å‡åŒ€ç¼©æ”¾
  const targetW = Math.round(cropLogicRect.width / scaleFactor);
  const targetH = Math.round(cropLogicRect.height / scaleFactor);

  if (targetW <= 0 || targetH <= 0) {
    cancelCrop();
    return Promise.resolve();
  }

  // ä¸´æ—¶éšè—è£å‰ªæ¡†ï¼Œé¿å…å¹²æ‰°
  cropRect.visible = false;

  // 3. ä½¿ç”¨ç¦»å±æ¸²æŸ“ç”Ÿæˆé«˜æ¸…è£å‰ªå›¾
  const croppedDataUrl = await renderHighResSnapshot(bgImage, targetW, targetH, (highResImg) => {
    // 3.1 è®¡ç®—ç›¸å¯¹ä½ç½®åç§» (ä½¿ç”¨ä¸­å¿ƒç‚¹å·®å€¼æ³•ï¼ŒæŠ—æ—‹è½¬å¹²æ‰°)
    const cropCenter = cropRect.getCenterPoint();
    const imgCenter = bgImage.getCenterPoint();

    // è®¡ç®—ä¸­å¿ƒç‚¹å·®è·ï¼ˆé€»è¾‘åƒç´ ï¼‰
    const diffX = imgCenter.x - cropCenter.x;
    const diffY = imgCenter.y - cropCenter.y;

    // æ˜ å°„åˆ°åŸå›¾å°ºåº¦
    const finalDiffX = diffX / scaleFactor;
    const finalDiffY = diffY / scaleFactor;

    // 3.2 è®¾ç½®é«˜åˆ†å›¾å±æ€§
    highResImg.set({
      originX: 'center', originY: 'center',
      left: targetW / 2 + finalDiffX,
      top: targetH / 2 + finalDiffY,
      scaleX: 1, // æ¢å¤åˆ°åŸå›¾æ¯”ä¾‹
      scaleY: 1,
      angle: bgImage.angle,
      flipX: bgImage.flipX,
      flipY: bgImage.flipY
    });
  });

  cropRect.visible = true;

  return new Promise((resolve) => {
    // 4. åº”ç”¨å›ä¸»ç”»å¸ƒ
    bgImage.setSrc(croppedDataUrl, () => {
      cancelCrop(false);

      // 5. ç‰©ç†é‡ç½®ï¼šå°†æ–°å›¾ç‰‡æ”¾å›ç”»å¸ƒä¸­å¿ƒ
      bgImage.set({
        originX: "center", originY: "center",
        left: canvas.width / 2, top: canvas.height / 2,
        scaleX: 1, scaleY: 1, // è£å‰ªåå°±æ˜¯ 1:1
        angle: 0, flipX: false, flipY: false,
      });
      bgImage.setCoords();
      canvas.centerObject(bgImage);

      // 6. è§†å£è‡ªé€‚åº” (Zoom to fit)
      // è®©è£å‰ªåçš„å›¾ç‰‡åœ¨å±å¹•ä¸Šæ˜¾ç¤ºå¤§å°åˆé€‚
      const paddingFactor = 0.85;
      const zoomToFit = Math.min(
        (canvas.width * paddingFactor) / targetW, // æ³¨æ„è¿™é‡Œç”¨ targetW å¯èƒ½ä¼šå¾ˆå¤§
        (canvas.height * paddingFactor) / targetH
      );

      // å› ä¸º targetW æ˜¯åŸå›¾å°ºå¯¸ï¼Œå¯èƒ½å‡ åƒåƒç´ ï¼Œæˆ‘ä»¬è¿™é‡Œè®¡ç®—çš„æ˜¯ Zoom Level
      // å®é™…ä¸Šå±•ç¤ºæ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒå æ®å±å¹•å¤§éƒ¨åˆ†
      // é‡æ–°è®¡ç®—ï¼šå›¾ç‰‡ç°åœ¨å°ºå¯¸æ˜¯ targetW * 1 * zoomToFit
      // æ‰€ä»¥ Zoom åº”è¯¥æ˜¯ canvasSize / targetSize

      // è®¾ç½®æ–°çš„è§†å£
      canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); // å…ˆé‡ç½®
      const newZoom = zoomToFit;
      const center = canvas.getCenter();
      canvas.zoomToPoint({ x: center.left, y: center.top }, newZoom);

      isApplyingCrop = false;
      isCropping.value = false;
      canvas.fire('zoom:change', { from: 'crop-confirm' });
      canvas.requestRenderAll();
      if (saveHistoryFn) saveHistoryFn();
      resolve();
    });
  });
};

export const setCropBoxSize = (width, height) => {
  if (!cropObject.value || !canvasRef?.value) return;
  const obj = cropObject.value;
  const oldRealWidth = obj.getScaledWidth();
  const oldRealHeight = obj.getScaledHeight();
  const centerX = obj.left + oldRealWidth / 2;
  const centerY = obj.top + oldRealHeight / 2;
  obj.set({ width: width, height: height, scaleX: 1, scaleY: 1 });
  const newLeft = centerX - width / 2;
  const newTop = centerY - height / 2;
  obj.set({ left: newLeft, top: newTop });
  obj.setCoords();
  constrainCrop(obj);
  canvasRef.value.requestRenderAll();
};

export const rotateActive = (angle) => {
  if (cropObject.value && canvasRef?.value) {
    const canvas = canvasRef.value;
    const bgImage = canvas.getObjects().find((o) => o.type === "image");
    if (bgImage) {
      bgImage.rotate((bgImage.angle || 0) + angle);
      canvas.centerObject(bgImage);
      bgImage.setCoords();
      canvas.renderAll();
      startCrop(aspectRatioValue);
    }
    return true;
  }
  return false;
};

export const flipActive = (axis) => {
  if (cropObject.value && canvasRef?.value) {
    const canvas = canvasRef.value;
    const bgImage = canvas.getObjects().find((o) => o.type === "image");
    if (bgImage) {
      if (axis === "X") bgImage.set("flipX", !bgImage.flipX);
      if (axis === "Y") bgImage.set("flipY", !bgImage.flipY);
      canvas.requestRenderAll();
    }
    return true;
  }
  return false;
};

export {
  cropObject,
  isManualCropping,
  isRatioLocked,
  currentAspectRatio,
  isCropping,
  currentSelectionDims
};
</file>

<file path="src/components/layout/EditorLayout.vue">
<template>
  <div class="image-editor-sdk-container">
    <NavBar :textMap="textMap" class="layout-header" />

    <div class="layout-body">
      <LeftSidebar class="layout-sidebar" />

      <ToolPanel class="layout-panel" />

      <Workspace :imageUrl="imageUrl" class="layout-workspace" />
    </div>
    <LoadingOverlay />
  </div>
</template>

<script setup>
import { provide, watch, defineProps, defineEmits } from 'vue';
import { useCanvas } from '../../composables/useCanvas';
import NavBar from './NavBar.vue';
import LeftSidebar from './LeftSidebar.vue';
import ToolPanel from '../panels/ToolPanel.vue';
import Workspace from '../Workspace.vue';
import LoadingOverlay from '@/components/common/LoadingOverlay.vue';
// === 1. å®šä¹‰ç»„ä»¶æ¥å£ (Props & Emits) ===
const props = defineProps({
  // åˆå§‹å›¾ç‰‡é“¾æ¥
  imageUrl: {
    type: String,
    default: 'https://wallpaperm.cmcm.com/21f96d39cffd296c2dd2f0cf9cf65c9b.jpg'
  },
  // æ–‡æœ¬æ˜ å°„è¡¨
  textMap: {
    type: Object,
    default: () => ({
      upload: 'æ‰“å¼€å›¾ç‰‡',
      save: 'ä¿å­˜',
      title: 'å¤§ç§˜ç¾å›¾'
    })
  },
  // å…¨å±€é…ç½®ï¼ˆå¦‚ AI åç«¯åœ°å€ï¼‰
  config: {
    type: Object,
    default: () => ({
      aiBaseUrl: 'http://localhost:3000/ai', // é»˜è®¤å€¼
    })
  }
});

const emit = defineEmits(['save']); // å®šä¹‰ä¿å­˜äº‹ä»¶

// === 2. Provide é…ç½®ç»™å­ç»„ä»¶ ===
// è¿™æ · AdjustRembg.vue ç­‰ç»„ä»¶å¯ä»¥é€šè¿‡ inject('editorConfig') è·å–é…ç½®
provide('editorConfig', props.config);

// === 3. åˆå§‹åŒ– Canvas é€»è¾‘ ===
const {
  init,
  initImage,
  addImage,
  toggleDrawing,
  exportMask,
  replaceActiveImage,
  canvas,
  zoom,
  zoomIn,
  zoomOut,
  zoomReset,
  zoomToRect,
  addText,
  rotateActive,
  flipActive,
  undo,
  redo,
  saveHistory
} = useCanvas();

// === 4. ç›‘å¬å›¾ç‰‡å˜åŒ– ===
watch(() => props.imageUrl, (newUrl) => {
  if (newUrl && canvas.value) {
    initImage(newUrl);
  }
});

// å°è£…åˆå§‹åŒ–æ–¹æ³•ï¼Œä»¥ä¾¿åœ¨ Canvas å‡†å¤‡å¥½ååŠ è½½åˆå§‹å›¾ç‰‡
const handleInit = (id, width, height) => {
  init(id, width, height); // è°ƒç”¨åŸå§‹ init

  // å¦‚æœæœ‰ä¼ å…¥å›¾ç‰‡ï¼Œå»¶è¿ŸåŠ è½½
  if (props.imageUrl) {
    setTimeout(() => {
      initImage(props.imageUrl);
    }, 100);
  }
};

// ã€æ–°å¢ã€‘è¿˜åŸåˆ°åˆå§‹çŠ¶æ€çš„æ–¹æ³•
const handleReset = () => {
  // ç¡®ä¿æœ‰åˆå§‹å›¾ç‰‡ URL ä¸” initImage æ–¹æ³•å¯ç”¨
  if (props.imageUrl && initImage) {
    // è°ƒç”¨ useCanvas çš„ initImage æ–¹æ³•ï¼Œä¼ å…¥åˆå§‹ URL
    // è¿™ä¼šæ¸…ç©ºç”»å¸ƒã€é‡ç½®å†å²è®°å½•å¹¶åŠ è½½åˆå§‹å›¾ç‰‡
    initImage(props.imageUrl);
  }
};

// ä¿å­˜å›¾ç‰‡
const handleExport = () => {
  // 1. å–æ¶ˆé€‰ä¸­çŠ¶æ€
  canvas.value?.discardActiveObject();
  canvas.value?.renderAll();

  // 2. è·å– Base64
  const dataURL = canvas.value?.toDataURL({ format: 'png' });

  // 3. æŠ›å‡ºäº‹ä»¶ç»™çˆ¶ç»„ä»¶
  emit('save', dataURL);
};

// === 5. ç»„è£… API å¯¹è±¡ ===
const api = {
  canvas,
  init: handleInit,
  zoom,
  zoomIn,
  zoomOut,
  zoomReset,
  zoomToRect,
  initImage,
  addImage,
  toggleDrawing,
  exportMask,
  replaceActiveImage,
  rotateActive,
  flipActive,
  undo,
  redo,
  saveHistory,
  addText: (text) => addText(text),
  exportImg: () => canvas.value?.toDataURL({ format: 'png' }),
  getActiveImgSrc: () => canvas.value?.getActiveObject()?.getSrc(),
  clearPaths: () => {
    const paths = canvas.value?.getObjects().filter(o => o.type === 'path');
    canvas.value?.remove(...paths);
  },
  save: handleExport,
  reset: handleReset
};

// === å‘ä¸‹åˆ†å‘ ===
provide('canvasAPI', api);
defineExpose({
  save: handleExport,
  undo,
  redo,
  canvas: canvas
})
</script>

<style scoped>
/* ä¿®æ”¹ç±»åï¼Œé¿å…è¿‡äºé€šç”¨çš„ layout-container */
.image-editor-sdk-container {
  display: flex;
  flex-direction: column;
  /* æ”¹ä¸º 100% ä»¥é€‚åº”çˆ¶å®¹å™¨ï¼Œè€Œä¸æ˜¯å¼ºåˆ¶å…¨å± */
  height: 100%;
  width: 100%;
  overflow: hidden;
  background-color: #fff;
  position: relative;
}

.layout-header {
  height: 50px;
  flex-shrink: 0;
  z-index: 20;
  border-bottom: 1px solid #e4e7ed;
  /* ç¡®ä¿æœ‰è¾¹ç•Œ */
}

.layout-body {
  display: flex;
  flex: 1;
  overflow: hidden;
  position: relative;
}

.layout-sidebar {
  width: 72px;
  flex-shrink: 0;
  z-index: 10;
}

.layout-panel {
  width: 300px;
  flex-shrink: 0;
  z-index: 10;
}

.layout-workspace {
  flex: 1;
  background-color: #f0f2f5;
  position: relative;
  min-width: 0;
}
</style>
</file>

<file path="src/composables/useCanvas.js">
// src/composables/useCanvas.js
import { ref, shallowRef, markRaw, toRaw } from "vue";
import { fabric } from "fabric";
import { useEditorState, ZOOM_PADDING } from "./useEditorState";

// å¼•å…¥å‰ªè£æ¨¡å—
import {
  registerCropModule,
  constrainCrop,
  cropObject,
  cancelCrop,
  rotateActive as rotateCrop,
  flipActive as flipCrop
} from "@/components/modules/adjust/useCanvasCrop";

export function useCanvas() {
  const canvas = shallowRef(null);
  const { setHistoryState } = useEditorState();
  const zoom = ref(1);

  // === å†å²è®°å½• ===
  const history = [];
  let historyIndex = -1;
  let historyProcessing = false;

  const saveHistory = () => {
    if (!canvas.value || historyProcessing) return;
    if (historyIndex < history.length - 1) {
      history.splice(historyIndex + 1);
    }
    const json = JSON.stringify(
      canvas.value.toJSON(["id", "selectable", "name"])
    );
    history.push(json);
    historyIndex++;
    if (history.length > 50) {
      history.shift();
      historyIndex--;
    }
    updateStoreHistory();
  };

  const updateStoreHistory = () => {
    // ã€ä¿®å¤ã€‘canRedo åº”è¯¥æ˜¯å½“å‰ç´¢å¼•å°äºå†å²è®°å½•æ€»é•¿åº¦å‡ 1
    setHistoryState(historyIndex > 0, historyIndex < history.length - 1);
  };

  // === æ’¤é”€ (Undo) ===
  const undo = () => {
    if (!canvas.value || historyIndex <= 0 || historyProcessing) return;

    if (cropObject.value) cancelCrop();

    historyProcessing = true;
    historyIndex--;
    const content = history[historyIndex];

    canvas.value?.loadFromJSON(content, () => {
      canvas.value?.renderAll();
      historyProcessing = false;
      updateStoreHistory();
    });
  };

  // === é‡åš (Redo) ===
  const redo = () => {
    if (!canvas.value || historyIndex >= history.length - 1 || historyProcessing) return;

    if (cropObject.value) cancelCrop();

    historyProcessing = true;
    historyIndex++;
    const content = history[historyIndex];

    canvas.value?.loadFromJSON(content, () => {
      canvas.value?.renderAll();
      historyProcessing = false;
      updateStoreHistory();
    });
  };

  const zoomToRect = (rect, minZoomLimit = 0.1) => {
    if (!canvas.value) return;
    const width = canvas.value.width;
    const height = canvas.value.height;

    let targetZoom = Math.min(width / rect.width, height / rect.height) * ZOOM_PADDING;

    // ã€çº¦æŸé€»è¾‘ã€‘ï¼šç¡®ä¿ç¼©æ”¾ä¸ä¼šå°äºæˆ‘ä»¬ä¼ å…¥çš„é™åˆ¶ï¼ˆæ¯”å¦‚åŸå›¾é€‚åº”æ¯”ä¾‹ï¼‰
    targetZoom = Math.max(minZoomLimit, Math.min(targetZoom, 50));

    const rectCenterX = rect.left + rect.width / 2;
    const rectCenterY = rect.top + rect.height / 2;

    const panX = (width / 2) - (rectCenterX * targetZoom);
    const panY = (height / 2) - (rectCenterY * targetZoom);

    canvas.value.setViewportTransform([targetZoom, 0, 0, targetZoom, panX, panY]);
    zoom.value = targetZoom;
    canvas.value.requestRenderAll();
  };

  // === åˆå§‹åŒ–ä¸äº‹ä»¶ ===
  const init = (id, width, height) => {
    console.log("init canvas", id, width, height);
    const c = new fabric.Canvas(id, {
      width: width,
      height: height,
      backgroundColor: "#f3f3f3",
      preserveObjectStacking: true,
      fireRightClick: true,  // å…è®¸ Fabric è¯†åˆ«å³é”®ç‚¹å‡»
      stopContextMenu: false // ç¦æ­¢ Fabric æ‹¦æˆªé»˜è®¤å³é”®èœå•
    });
    canvas.value = markRaw(c);

    registerCropModule(canvas, saveHistory, zoomToRect);

    const checkConstraint = () => {
      if (cropObject.value) {
        constrainCrop(toRaw(cropObject.value));
      }
    };
    c.on("object:modified", (e) => {
      checkConstraint();
      if (e.target && e.target.type !== "rect") saveHistory();
    });
    c.on("object:added", (e) => {
      if (e.target && e.target.type !== "rect") saveHistory();
    });
    c.on("object:removed", (e) => {
      if (e.target && e.target.type !== "rect") saveHistory();
    });

    // Zoom äº‹ä»¶
    const canvasEl = c.upperCanvasEl;
    canvasEl.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();
        e.stopPropagation();
        const delta = e.deltaY;
        let newZoom = c.getZoom();
        newZoom *= 0.999 ** delta;
        if (newZoom > 50) newZoom = 50;
        if (newZoom < 0.1) newZoom = 0.1;
        c.zoomToPoint({ x: e.offsetX, y: e.offsetY }, newZoom);
        zoom.value = newZoom;
      },
      { passive: false }
    );

    saveHistory();
  };

  // === é€šç”¨ API ===
  const addImage = (url) => {
    fabric.Image.fromURL(
      url,
      (img) => {
        const canvasWidth = canvas.value.width;
        const canvasHeight = canvas.value.height;
        if (img.width > canvasWidth || img.height > canvasHeight) {
          const scale = Math.min(canvasWidth / img.width, canvasHeight / img.height) * ZOOM_PADDING;
          img.scale(scale);
        }
        img.set({
          isMainImage: true,  // æ ‡è®°ä¸ºä¸»å›¾
          id: 'main-image'    // æ–¹ä¾¿åç»­æŸ¥æ‰¾
        });
        zoom.value = canvas.value.getZoom();
        historyProcessing = true;
        canvas.value?.add(img);
        canvas.value?.centerObject(img);
        canvas.value?.setActiveObject(img);
        historyProcessing = false;
        saveHistory();
        canvas.value.fire('image:updated');
      },
      { crossOrigin: "anonymous" }
    );
  };

  const setZoom = (value) => {
    if (!canvas.value) return;
    let newZoom = value;
    if (newZoom > 50) newZoom = 50;
    if (newZoom < 0.1) newZoom = 0.1;
    const center = canvas.value.getCenter();
    canvas.value.zoomToPoint({ x: center.left, y: center.top }, newZoom);
    zoom.value = newZoom;
  };

  const zoomIn = () => setZoom(zoom.value + 0.1);
  const zoomOut = () => setZoom(zoom.value - 0.1);
  const zoomReset = () => setZoom(1);

  const initImage = (url) => {
    if (!canvas.value) return;
    // é‡ç½®ç›¸æœºè§†è§’
    // canvas.value.setViewportTransform([1, 0, 0, 1, 0, 0]);
    // zoom.value = 1;
    historyProcessing = true;
    canvas.value.clear();
    canvas.value.setBackgroundColor("#f3f3f3", () => {
      canvas.value.renderAll();
    });
    historyProcessing = false;
    history.length = 0;
    historyIndex = -1;
    updateStoreHistory();
    addImage(url);
  };

  const rotateActive = (angle) => {
    const handled = rotateCrop(angle);
    if (!handled) {
      const activeObj = canvas.value?.getActiveObject();
      if (activeObj) {
        activeObj.rotate((activeObj.angle || 0) + angle);
        canvas.value.requestRenderAll();
        saveHistory();
      }
    }
  };

  const flipActive = (axis) => {
    const handled = flipCrop(axis);
    if (!handled) {
      const activeObj = canvas.value?.getActiveObject();
      if (activeObj) {
        if (axis === "X") activeObj.set("flipX", !activeObj.flipX);
        if (axis === "Y") activeObj.set("flipY", !activeObj.flipY);
        canvas.value.requestRenderAll();
      }
    }
  };

  const toggleDrawing = (enable) => {
    if (!canvas.value) return;
    canvas.value.isDrawingMode = enable;
    if (enable) {
      const brush = new fabric.PencilBrush(canvas.value);
      brush.color = "rgba(255, 0, 0, 0.5)";
      brush.width = 30;
      canvas.value.freeDrawingBrush = brush;
    }
  };

  const exportMask = () => {
    if (!canvas.value) return null;
    const originalBg = canvas.value.backgroundColor;
    const objects = canvas.value.getObjects();

    objects.forEach((obj) => {
      // å˜æ›´ç‚¹ï¼šä¸ä»…æ”¯æŒ pathï¼Œè¿˜æ”¯æŒæ ‡è®°äº† isMaskObject çš„å¯¹è±¡ (å¦‚æ¡†é€‰çŸ©å½¢)
      if (obj.type === "path" || obj.isMaskObject) {
        obj._originalStroke = obj.stroke;
        obj._originalFill = obj.fill; // å¤‡ä»½å¡«å……è‰²

        // ç»Ÿä¸€å˜æˆçº¯ç™½ï¼Œç”¨äºç”Ÿæˆé®ç½©
        obj.set({ stroke: "#ffffff", fill: "#ffffff" });
      } else {
        obj._originalOpacity = obj.opacity;
        obj.set({ opacity: 0 });
      }
    });

    canvas.value.setBackgroundColor("#000000", null);
    canvas.value.renderAll();

    // å¯¼å‡º
    const dataURL = canvas.value.toDataURL({ format: "png", multiplier: 1 });

    // æ¢å¤ç°åœº
    objects.forEach((obj) => {
      if (obj.type === "path" || obj.isMaskObject) {
        obj.set({
          stroke: obj._originalStroke,
          fill: obj._originalFill
        });
      } else {
        obj.set({ opacity: obj._originalOpacity ?? 1 });
      }
    });

    canvas.value.setBackgroundColor(originalBg, null);
    canvas.value.renderAll();

    return dataURL;
  };

  const replaceActiveImage = (newUrl) => {
    const activeObj = canvas.value?.getActiveObject();
    if (!activeObj || activeObj.type !== "image") return;
    activeObj.setSrc(
      newUrl,
      () => {
        canvas.value.renderAll();
        saveHistory();
        // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶ï¼Œé€šçŸ¥æ»¤é•œæ¨¡å—æ›´æ–°é¢„è§ˆå›¾
        canvas.value.fire('image:updated');
      },
      { crossOrigin: "anonymous" }
    );
  };

  const addText = (textStr = "åŒå‡»ç¼–è¾‘") => {
    if (!canvas.value) return;
    const text = new fabric.IText(textStr, {
      left: 100,
      top: 100,
      fontSize: 40,
      fill: "#333",
    });
    canvas.value.add(text);
    canvas.value.setActiveObject(text);
  };

  return {
    canvas,
    zoom,
    init,
    initImage,
    addImage,
    zoomIn,
    zoomOut,
    zoomReset,
    zoomToRect,
    setZoom,
    undo,
    redo,
    saveHistory,
    toggleDrawing,
    exportMask,
    replaceActiveImage,
    addText,
    rotateActive,
    flipActive
  };
}
</file>

</files>
