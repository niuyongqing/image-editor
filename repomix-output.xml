This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*, package.json, index.html, vite.config.js, src/config/theme.js, style.css, .spec/**/*
- Files matching these patterns are excluded: **/*.log, dist/**, public/**, src/assets/**, .spec/prompt.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.spec/active-context.md
.spec/project-charter.md
.spec/system-patterns.md
index.html
package.json
src/api/ai.js
src/App.vue
src/components/common/CanvasContextMenu.vue
src/components/common/FloatingObjectMenu.vue
src/components/common/LoadingOverlay.vue
src/components/common/Modal.vue
src/components/common/ShortcutsPanel.vue
src/components/layout/EditorLayout.vue
src/components/layout/LeftSidebar.vue
src/components/layout/NavBar.vue
src/components/modules/adjust/AdjustColor.vue
src/components/modules/adjust/AdjustColorOverlay.vue
src/components/modules/adjust/AdjustCrop.vue
src/components/modules/adjust/AdjustFilters.vue
src/components/modules/adjust/AdjustInpaint.vue
src/components/modules/adjust/AdjustMosaic.vue
src/components/modules/adjust/AdjustRembg.vue
src/components/modules/adjust/AdjustResize.vue
src/components/modules/adjust/AdjustRuler.vue
src/components/modules/adjust/AdjustWhite.vue
src/components/modules/adjust/index.vue
src/components/modules/adjust/useCanvasColor.js
src/components/modules/adjust/useCanvasColorOverlay.js
src/components/modules/adjust/useCanvasCrop.js
src/components/modules/adjust/useCanvasFilters.js
src/components/modules/adjust/useCanvasInpaint.js
src/components/modules/adjust/useCanvasMosaic.js
src/components/modules/adjust/useCanvasResize.js
src/components/modules/adjust/useCanvasRuler.js
src/components/modules/adjust/useCanvasWhite.js
src/components/modules/ai/AiExpand.vue
src/components/modules/ai/AiGenerate.vue
src/components/modules/ai/index.vue
src/components/modules/border/index.vue
src/components/modules/draw/DrawBrush.vue
src/components/modules/draw/DrawShape.vue
src/components/modules/draw/index.vue
src/components/modules/material/index.vue
src/components/modules/puzzle/config.js
src/components/modules/puzzle/index.vue
src/components/modules/puzzle/useCanvasPuzzle.js
src/components/modules/text/index.vue
src/components/modules/text/TextAdd.vue
src/components/modules/text/TextStyle.vue
src/components/modules/watermark/index.vue
src/components/panels/ToolPanel.vue
src/components/Workspace.vue
src/composables/useCanvas.js
src/composables/useCanvasLock.js
src/composables/useConstraint.js
src/composables/useEditorState.js
src/composables/useKeyboardShortcuts.js
src/composables/useObjectActions.js
src/composables/useOffscreenHelper.js
src/config/shortcuts.js
src/config/theme.js
src/index.js
src/main.js
src/style.css
src/utils/toast.js
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".spec/system-patterns.md">
"æ³¨æ„ï¼šåœ¨å¤§ç§˜ç¾å›¾ä¸­ï¼ŒFabric çš„ Canvas å¿…é¡»ç”¨ markRaw åŒ…è£…ï¼Œå¦åˆ™ä¼šå¯¼è‡´ Vue å“åº”å¼å¡æ­»ã€‚ä¹‹å‰åœ¨ 2024-12 é‡åˆ°è¿‡è¿™ä¸ªé—®é¢˜ã€‚"
</file>

<file path="src/components/common/CanvasContextMenu.vue">
<template>
  <div 
    v-show="visible" 
    class="context-menu"
    :style="{ left: position.x + 'px', top: position.y + 'px' }"
    @contextmenu.prevent 
  >
    <div 
      class="menu-item" 
      :class="{ disabled: !clipboardState.hasContent }"
      @click="handlePaste"
    >
      <span class="icon">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>
      </span>
      <span>ç²˜è´´</span>
      <span class="shortcut">Ctrl+V</span>
    </div>

    </div>
</template>

<script setup>
import { inject } from 'vue';
import { useObjectActions } from '@/composables/useObjectActions';

// æ¥æ”¶ Props æ§åˆ¶æ˜¾ç¤º
const props = defineProps({
  visible: Boolean,
  position: {
    type: Object,
    default: () => ({ x: 0, y: 0 })
  }
});

const emit = defineEmits(['close', 'paste']);

const actions = useObjectActions();
const clipboardState = actions.clipboardState;

const handlePaste = () => {
  if (!clipboardState.hasContent) return;
  emit('paste'); // é€šçŸ¥çˆ¶ç»„ä»¶è¿›è¡Œç²˜è´´
  emit('close'); // å…³é—­èœå•
};
</script>

<style scoped>
.context-menu {
  position: fixed; /* ä½¿ç”¨ fixed é¿å…å—çˆ¶å®¹å™¨ overflow å½±å“ */
  z-index: 3000;
  background: #ffffff;
  border: 1px solid #ebeef5;
  border-radius: 6px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
  padding: 4px 0;
  width: 140px;
  min-width: 120px;
}

.menu-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  font-size: 13px;
  color: #606266;
  cursor: pointer;
  transition: background 0.1s;
}

.menu-item:hover {
  background: #f5f7fa;
  color: var(--ie-primary-color);
}

.menu-item.disabled {
  color: #c0c4cc;
  cursor: not-allowed;
  background: transparent !important;
}

.icon {
  display: flex;
  align-items: center;
  margin-right: 8px;
  width: 16px;
}

.shortcut {
  margin-left: auto;
  font-size: 12px;
  color: #909399;
}
</style>
</file>

<file path="src/components/common/LoadingOverlay.vue">
<template>
    <div v-if="state.isLoading" class="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <p class="loading-text">{{ state.loadingText }}</p>
        </div>
    </div>
</template>

<script setup>
import { useEditorState } from '@/composables/useEditorState';

// ç›´æ¥è¿æ¥å…¨å±€çŠ¶æ€
const { state } = useEditorState();
</script>

<style scoped>
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.7);
    /* åŠé€æ˜é»‘è‰²èƒŒæ™¯ */
    z-index: 9999;
    /* ç¡®ä¿å±‚çº§æœ€é«˜ï¼Œé®æŒ¡æ‰€æœ‰æ“ä½œ */
    display: flex;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(2px);
    /* è½»å¾®æ¨¡ç³ŠèƒŒæ™¯ */
}

.loading-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #ffffff;
    animation: spin 1s ease-in-out infinite;
}

.loading-text {
    color: #ffffff;
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 0.5px;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
</style>
</file>

<file path="src/components/common/ShortcutsPanel.vue">
<template>
  <Teleport to="body">
    <Transition name="fade">
      <div v-if="visible" class="shortcut-overlay" @click="close"></div>
    </Transition>

    <Transition name="slide">
      <div v-if="visible" class="shortcut-drawer">
        <div class="drawer-header">
          <h3>å¿«æ·é”®åˆ—è¡¨</h3>
          <button class="close-btn" @click="close">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
          </button>
        </div>
        
        <div class="drawer-content">
          <div v-for="(group, index) in groups" :key="index" class="group-section">
            <h4 class="group-title">{{ group.title }}</h4>
            <div class="shortcut-list">
              <div v-for="(item, idx) in group.items" :key="idx" class="shortcut-item">
                <span class="label">{{ item.label }}</span>
                <div class="keys">
                  <span v-for="(key, kIdx) in item.keys" :key="kIdx" class="keycap">
                    {{ key }}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup>
import { defineProps, defineEmits } from 'vue';
import { SHORTCUT_GROUPS } from '@/config/shortcuts';

defineProps({
  visible: Boolean
});

const emit = defineEmits(['close']);
const groups = SHORTCUT_GROUPS;

const close = () => {
  emit('close');
};
</script>

<style scoped>
/* é®ç½©å±‚ */
.shortcut-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.4);
  z-index: 3000;
  backdrop-filter: blur(2px);
}

/* æŠ½å±‰é¢æ¿ */
.shortcut-drawer {
  position: fixed;
  top: 0;
  right: 0;
  width: 320px;
  height: 100vh;
  background: white;
  z-index: 3001;
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
}

/* å¤´éƒ¨ */
.drawer-header {
  padding: 20px;
  border-bottom: 1px solid #ebeef5;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.drawer-header h3 {
  margin: 0;
  font-size: 18px;
  color: #303133;
}

.close-btn {
  background: none;
  border: none;
  cursor: pointer;
  color: #909399;
  padding: 4px;
  border-radius: 4px;
  transition: background 0.2s;
  display: flex;
}
.close-btn:hover {
  background: #f5f7fa;
  color: #606266;
}

/* å†…å®¹åŒº */
.drawer-content {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.group-section {
  margin-bottom: 24px;
}

.group-title {
  font-size: 14px;
  color: #909399;
  margin: 0 0 12px 0;
  font-weight: 600;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  font-size: 14px;
  color: #606266;
}

/* âœ¨ Keycap é£æ ¼æ ¸å¿ƒä»£ç  */
.keys {
  display: flex;
  gap: 4px;
}

.keycap {
  display: inline-block;
  padding: 2px 8px;
  font-size: 12px;
  font-family: 'SF Mono', 'Roboto Mono', Monaco, monospace;
  color: #303133;
  background: #fdfdfd; /* ç¨å¾®ç™½ä¸€ç‚¹ */
  border: 1px solid #dcdfe6;
  border-bottom-width: 3px; /* åº•éƒ¨åŠ åšæ¨¡æ‹Ÿç«‹ä½“æ„Ÿ */
  border-radius: 6px;
  min-width: 20px;
  text-align: center;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/* åŠ¨ç”» */
.fade-enter-active, .fade-leave-active {
  transition: opacity 0.3s ease;
}
.fade-enter-from, .fade-leave-to {
  opacity: 0;
}

.slide-enter-active, .slide-leave-active {
  transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
}
.slide-enter-from, .slide-leave-to {
  transform: translateX(100%);
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustFilters.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m19 2 2 2-2 2-2-2Z"/><path d="m13 2 2 2-2 2-2-2Z"/><path d="m6 6 2 2-2 2-2-2Z"/>
          <path d="m3 21 9-9"/><path d="M12.22 7.28a3 3 0 0 0-4.24 0L3.5 11.76a3 3 0 0 0 0 4.24l4.48 4.48a3 3 0 0 0 4.24 0l4.48-4.48a3 3 0 0 0 0-4.24Z"/>
        </svg>
        <span>æ»¤é•œæ•ˆæœ</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6"/>
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content filter-panel">
      <div v-for="cat in categories" :key="cat.name" class="filter-category">
        <div class="cat-title">{{ cat.name }}</div>
        <div class="filter-grid">
          <div 
            v-for="item in cat.list" 
            :key="item.key" 
            class="filter-item"
            :class="{ active: currentFilter === item.key }"
            @click="selectFilter(item.key)"
          >
            <div class="thumb-container">
              <img v-if="thumbnailMap[item.key]" :src="thumbnailMap[item.key]" class="filter-thumb">
              <div v-else class="thumb-placeholder loading"></div>
            </div>
            <span class="filter-label">{{ item.label }}</span>
          </div>
        </div>
      </div>

      <div class="intensity-box" v-if="currentFilter !== 'original'">
        <div class="label-row">
          <span>å¼ºåº¦ï¼š{{ intensity }}</span>
        </div>
        <input type="range" v-model.number="intensity" min="0" max="100" class="ie-slider" @input="updateIntensity">
      </div>

      <div class="action-buttons">
        <button class="ie-btn ie-primary full" @click="handleConfirm">ç¡®å®š</button>
        <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, inject, onMounted, watch } from 'vue';
import { 
    registerFilterModule, applyFilterPreset, loadThumbnailsTask, 
    backupCurrentFilters, commitFilterChange, cancelFilterChange 
} from './useCanvasFilters';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const currentFilter = ref('original');
const intensity = ref(100);
const thumbnailMap = reactive({});

const categories = [
  { name: 'åŸºç¡€', list: [{key:'original', label:'åŸå›¾'}, {key:'natural', label:'è‡ªç„¶'}, {key:'bright', label:'é²œäº®'}, {key:'whitening', label:'å‡€ç™½'}] },
  { name: 'å¤å¤', list: [{key:'v8090', label:'8090'}, {key:'modern', label:'æ‘©ç™»'}, {key:'cool_space', label:'çƒˆç©º'}] },
  { name: 'é£æ™¯', list: [{key:'snow', label:'åˆé›ª'}, {key:'sunset', label:'å¦ä¸'}, {key:'hot_sun', label:'çƒˆæ—¥'}] },
  { name: 'ç”µå½±', list: [{key:'smoke', label:'å°˜çƒŸ'}, {key:'spring', label:'æ˜¥é£'}, {key:'lalaland', label:'çˆ±ä¹ä¹‹åŸ'}] },
];

const selectFilter = (key) => {
  currentFilter.value = key;
  applyFilterPreset(key, intensity.value);
};

const updateIntensity = () => applyFilterPreset(currentFilter.value, intensity.value);

const handleConfirm = () => {
    commitFilterChange();
    emit('toggle');
};

const handleCancel = () => {
    cancelFilterChange();
    emit('toggle');
};

const refreshThumbnails = () => {
    loadThumbnailsTask((map) => Object.assign(thumbnailMap, map));
};

// æ ¸å¿ƒä¼˜åŒ–ï¼šä»…åœ¨é¢æ¿å±•å¼€æ—¶ç›‘å¬ï¼Œå¹¶æ‰§è¡Œå¤‡ä»½
watch(() => props.isExpanded, (expanded) => {
    const canvas = canvasAPI?.canvas?.value;
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    
    if (expanded && bgImage) {
        // âœ… 1. å±•å¼€ç¬é—´ï¼Œæ ¹æ®å›¾ç‰‡ä¸Šå­˜å‚¨çš„å…ƒæ•°æ®åŒæ­¥ UI é«˜äº®å’Œå¼ºåº¦
        currentFilter.value = bgImage._lastFilterKey || 'original';
        intensity.value = bgImage._lastFilterIntensity ?? 100;

        // 2. æ‰§è¡Œå¤‡ä»½é€»è¾‘ (ç”¨äºå–æ¶ˆå›æ»š)
        backupCurrentFilters(); 
        
        // 3. åŠ è½½ç¼©ç•¥å›¾åŠæ³¨å†Œç›‘å¬
        refreshThumbnails();
        canvas.on('image:updated', refreshThumbnails);
    } else if (!expanded && canvas) {
        canvas.off('image:updated', refreshThumbnails);
    }
});

onMounted(() => {
    if (canvasAPI?.canvas) registerFilterModule(canvasAPI.canvas, canvasAPI.saveHistory);
});
</script>

<style scoped>
/* æ ·å¼ä¿ç•™åŸæœ‰çš„ç½‘æ ¼å¸ƒå±€å’Œä¸»é¢˜è‰²å®šä¹‰ */
.filter-panel { padding: 12px; max-height: 520px; overflow-y: auto; }
.cat-title { font-size: 13px; font-weight: bold; margin: 12px 0 8px; color: #333; }
.filter-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
.filter-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; }
.thumb-container { width: 70px; height: 70px; border-radius: 4px; overflow: hidden; border: 2px solid transparent; transition: 0.2s; background: #eee; }
.filter-thumb { width: 100%; height: 100%; object-fit: cover; }
.thumb-placeholder.loading { width: 100%; height: 100%; background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: loading-skeleton 1.5s infinite; }
@keyframes loading-skeleton { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
.filter-item.active .thumb-container { border-color: var(--ie-primary-color); }
.filter-label { font-size: 11px; margin-top: 6px; color: #666; }
.intensity-box { margin-top: 20px; padding: 12px 0; border-top: 1px solid #f0f0f0; }
.label-row { display: flex; justify-content: space-between; font-size: 12px; color: #606266; margin-bottom: 8px; }
.action-buttons { display: flex; gap: 10px; margin-top: 16px; }
.full { flex: 1; }
</style>
</file>

<file path="src/components/modules/adjust/useCanvasFilters.js">
// src/components/modules/adjust/useCanvasFilters.js
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let thumbnailTimer = null;
let backupFilters = [];
let backupKey = 'original'; // ç”¨äºå¤‡ä»½æ»¤é•œ Key
let backupIntensity = 100;   // ç”¨äºå¤‡ä»½å¼ºåº¦


export const registerFilterModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};

// æ»¤é•œçŸ©é˜µé…ç½®ï¼ˆæ¨¡æ‹Ÿåº—å°ç§˜çš„å››å¤§åˆ†ç±»ï¼‰
export const filterDefinitions = {
    // åŸºç¡€ç±»
    natural: [1, 0, 0, 0, 0,  0, 1.05, 0, 0, 0,  0, 0, 1.02, 0, 0,  0, 0, 0, 1, 0], // è‡ªç„¶
    bright: [1.1, 0, 0, 0, 0,  0, 1.1, 0, 0, 0,  0, 0, 1.1, 0, 0,  0, 0, 0, 1, 0],   // é²œäº®
    whitening: [1.05, 0, 0, 0, 0.05,  0, 1.05, 0, 0, 0.05,  0, 0, 1.05, 0, 0.05,  0, 0, 0, 1, 0], // å‡€ç™½

    // å¤å¤ç±»
    v8090: [0.35, 0.25, 0.25, 0, 0,  0.25, 0.35, 0.25, 0, 0,  0.25, 0.25, 0.35, 0, 0,  0, 0, 0, 1, 0], // 8090
    modern: [0.393, 0.769, 0.189, 0, 0,  0.349, 0.686, 0.168, 0, 0,  0.272, 0.534, 0.131, 0, 0,  0, 0, 0, 1, 0], // æ‘©ç™»
    cool_space: [1, 0, 0, 0.1, -0.1,  0, 1, 0, 0.1, -0.1,  0, 0, 1.2, 0.2, -0.1,  0, 0, 0, 1, 0], // çƒˆç©º

    // é£æ™¯ç±»
    snow: [1, 0, 0, 0, 0.1,  0, 1, 0, 0, 0.1,  0, 0, 1.1, 0, 0.15,  0, 0, 0, 1, 0], // åˆé›ª
    sunset: [1.2, 0, 0, 0, 0,  0, 1, 0, 0, 0,  0, 0, 0.8, 0, 0,  0, 0, 0, 1, 0],     // å¦ä¸
    hot_sun: [1.1, 0, 0, 0.1, 0,  0, 1, 0, 0.1, 0,  0, 0, 0.9, 0, 0,  0, 0, 0, 1, 0], // çƒˆæ—¥

    // ç”µå½±ç±»
    smoke: [0.8, 0.1, 0.1, 0, 0,  0.1, 0.8, 0.1, 0, 0,  0.1, 0.1, 0.8, 0, 0,  0, 0, 0, 1, 0], // å°˜çƒŸ
    spring: [0.9, 0, 0, 0, 0,  0, 1.1, 0, 0, 0,  0, 0, 0.9, 0, 0,  0, 0, 0, 1, 0], // æ˜¥é£
    lalaland: [1, 0, 0, 0, 0,  0, 0.9, 0, 0, 0,  0, 0, 1.2, 0, 0,  0, 0, 0, 1, 0], // çˆ±ä¹ä¹‹åŸ
};

// å¤‡ä»½å½“å‰æ»¤é•œçŠ¶æ€
export const backupCurrentFilters = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        // æ·±æ‹·è´æ»¤é•œæ•°ç»„
        backupFilters = [...bgImage.filters];
        backupKey = bgImage._lastFilterKey || 'original';
        backupIntensity = bgImage._lastFilterIntensity ?? 100;
    }
};

/**
 * åº”ç”¨æ»¤é•œé¢„è®¾
 * @param {string} filterKey æ»¤é•œé…ç½®é”®å
 * @param {number} intensity å¼ºåº¦ (0-100)
 */
export const applyFilterPreset = (filterKey, intensity = 100) => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (!bgImage) return;

    // è®°å½•å½“å‰é€‰ä¸­çš„æ»¤é•œä¿¡æ¯åˆ°å¯¹è±¡ä¸Šï¼Œä»¥ä¾¿é‡æ–°æ‰“å¼€é¢æ¿æ—¶åŒæ­¥ UI
    bgImage._lastFilterKey = filterKey;
    bgImage._lastFilterIntensity = intensity;

    bgImage.filters = bgImage.filters.filter(f => !f._isArtFilter);

    if (filterKey !== 'original') {
        const matrix = filterDefinitions[filterKey];
        if (matrix) {
            const filter = new fabric.Image.filters.ColorMatrix({
                matrix: matrix,
                alpha: intensity / 100
            });
            filter._isArtFilter = true;
            bgImage.filters.push(filter);
        }
    }

    bgImage.applyFilters();
    canvas.requestRenderAll();
};

// ç¡®å®šï¼šä¿å­˜å†å²è®°å½•å¹¶æ¸…ç†å¤‡ä»½
export const commitFilterChange = () => {
    if (saveHistoryFn) saveHistoryFn();
    backupFilters = [];
};

/**
 * å–æ¶ˆä¿®æ”¹ï¼šæ ¸å¿ƒé€»è¾‘å›å½’ â€”â€” æ¢å¤åˆ°å¤‡ä»½çŠ¶æ€
 */
export const cancelFilterChange = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        bgImage.filters = [...backupFilters];
        // âœ… è¿˜åŸå…ƒæ•°æ®
        bgImage._lastFilterKey = backupKey;
        bgImage._lastFilterIntensity = backupIntensity;
        
        bgImage.applyFilters();
        canvas.requestRenderAll();
    }
    backupFilters = [];
};

/**
 * ç”Ÿæˆæ‰€æœ‰æ»¤é•œçš„é¢„è§ˆç¼©ç•¥å›¾
 * @returns {Promise<Object>} è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œé”®æ˜¯æ»¤é•œkeyï¼Œå€¼æ˜¯Base64å›¾ç‰‡æ•°æ®
 */
export const generateFilterThumbnails = () => {
  return new Promise((resolve, reject) => {
    const canvas = unref(canvasRef);
    if (!canvas) {
      reject("Canvas not initialized");
      return;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) {
      resolve({}); // æ²¡æœ‰å›¾ç‰‡æ—¶è¿”å›ç©º
      return;
    }

    const originalSrc = bgImage.getSrc();
    const thumbSize = 80; // ç¼©ç•¥å›¾å¤§å°ï¼Œè¶Šå°ç”Ÿæˆè¶Šå¿«

    // 1. åˆ›å»ºä¸€ä¸ªåå°å°å‹ç¦»å±ç”»å¸ƒ
    const tempCanvas = new fabric.StaticCanvas(null, {
      width: thumbSize,
      height: thumbSize,
      backgroundColor: 'transparent'
    });

    // 2. åŠ è½½åŸå›¾
    fabric.Image.fromURL(originalSrc, (thumbImg) => {
        // 3. å°†å›¾ç‰‡ç¼©æ”¾å¹¶å±…ä¸­å¡«æ»¡å°ç”»å¸ƒ
        const scale = Math.max(thumbSize / thumbImg.width, thumbSize / thumbImg.height);
        thumbImg.set({
            originX: 'center',
            originY: 'center',
            left: thumbSize / 2,
            top: thumbSize / 2,
            scaleX: scale,
            scaleY: scale
        });
        tempCanvas.add(thumbImg);

        const resultMap = {};

        // 4. å®šä¹‰ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥ç”Ÿæˆå•ä¸ªæ»¤é•œå›¾
        const renderOne = (matrix) => {
            thumbImg.filters = []; // æ¸…ç©ºæ—§æ»¤é•œ
            if (matrix) {
                const filter = new fabric.Image.filters.ColorMatrix({ matrix: matrix });
                thumbImg.filters.push(filter);
            }
            thumbImg.applyFilters();
            tempCanvas.renderAll();
            // ä½¿ç”¨è¾ƒä½è´¨é‡å¯¼å‡ºï¼Œæé«˜é€Ÿåº¦
            return tempCanvas.toDataURL({ format: 'jpeg', quality: 0.7 });
        };

        // 5. ç”Ÿæˆã€åŸå›¾ã€‘ç¼©ç•¥å›¾
        resultMap['original'] = renderOne(null);

        // 6. å¾ªç¯ç”Ÿæˆæ‰€æœ‰ã€æ»¤é•œã€‘ç¼©ç•¥å›¾
        for (const key in filterDefinitions) {
            resultMap[key] = renderOne(filterDefinitions[key]);
        }
        
        // æ¸…ç†å†…å­˜
        tempCanvas.dispose();
        resolve(resultMap);
    }, { crossOrigin: 'anonymous' }); // ç¡®ä¿è·¨åŸŸåŠ è½½
  });
};

/**
 * ä¼˜åŒ–çš„ç¼©ç•¥å›¾åŠ è½½é€»è¾‘ï¼ˆå¸¦å†…éƒ¨é˜²æŠ–ï¼‰
 * @param {Function} callback - æˆåŠŸç”Ÿæˆåçš„å›è°ƒ
 */
export const loadThumbnailsTask = (callback) => {
    if (thumbnailTimer) clearTimeout(thumbnailTimer);

    // è®¾ç½® 200ms é˜²æŠ–ï¼Œé˜²æ­¢é¢æ¿å¿«é€Ÿåˆ‡æ¢æˆ–å›¾ç‰‡è¿ç»­å˜æ¢æ—¶çš„è®¡ç®—æµªè´¹
    thumbnailTimer = setTimeout(async () => {
        try {
            const map = await generateFilterThumbnails(); // è°ƒç”¨ä¹‹å‰å®šä¹‰çš„ç”Ÿæˆå‡½æ•°
            if (callback) callback(map);
        } catch (e) {
            console.error("ç”Ÿæˆç¼©ç•¥å›¾å¤±è´¥:", e);
        }
    }, 200);
};
</file>

<file path="src/components/modules/adjust/useCanvasMosaic.js">
// [æ–‡ä»¶: src/components/modules/adjust/useCanvasMosaic.js]
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;

// å†…éƒ¨çŠ¶æ€ï¼šä¿æŒæŒä¹…åŒ–ï¼Œç›´åˆ°ç‚¹å‡»åº”ç”¨æˆ–å–æ¶ˆ
let mosaicPreviewLayer = null;
let maskGroup = null;

export const registerMosaicModule = (canvas, saveHistory) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
};

/**
 * æ ¸å¿ƒï¼šå¼€å¯æˆ–æ›´æ–°é©¬èµ›å…‹äº¤äº’ [éµå¾ªå…¨æ™¯æŠ¥å‘Šï¼šçŠ¶æ€ä¿æŠ¤]
 */
export const startMosaicInteraction = (mode, intensity = 15) => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  // 1. å¦‚æœé¢„è§ˆå±‚å·²å­˜åœ¨ï¼Œä»…æ›´æ–°æ»¤é•œå¼ºåº¦ï¼Œä¸é‡ç½®çŠ¶æ€
  if (mosaicPreviewLayer) {
    const filter = new fabric.Image.filters.Pixelate({ blocksize: intensity });
    mosaicPreviewLayer.filters = [filter];
    mosaicPreviewLayer.applyFilters();
    
    // åˆ‡æ¢æ¨¡å¼é€»è¾‘
    canvas.isDrawingMode = (mode === 'path');
    if (!canvas.isDrawingMode) addMosaicShape(mode);
    
    canvas.requestRenderAll();
    return;
  }

  // 2. é¦–æ¬¡åˆå§‹åŒ–ï¼šåˆ›å»ºé¢„è§ˆå±‚
  bgImage.clone((cloned) => {
    mosaicPreviewLayer = cloned;
    
    const pixelateFilter = new fabric.Image.filters.Pixelate({ blocksize: intensity });
    mosaicPreviewLayer.filters = [pixelateFilter];
    mosaicPreviewLayer.applyFilters();

    // åˆå§‹åŒ–è·¯å¾„é®ç½©ç»„
    maskGroup = new fabric.Group([], { absolutePositioned: true });

    mosaicPreviewLayer.set({
      selectable: false,
      evented: false,
      clipPath: maskGroup, // åˆå§‹å…³è”
      name: 'mosaic-preview-layer'
    });

    canvas.add(mosaicPreviewLayer);
    canvas.bringToFront(mosaicPreviewLayer);

    // è®¾ç½®äº¤äº’
    canvas.isDrawingMode = (mode === 'path');
    if (mode === 'path') {
      const brush = new fabric.PencilBrush(canvas);
      brush.width = 30;
      brush.color = 'rgba(0,0,0,1)'; // é®ç½©è‰²
      canvas.freeDrawingBrush = brush;
      canvas.on('path:created', onPathCreated);
    } else {
      addMosaicShape(mode);
    }
    
    canvas.requestRenderAll();
  });
};

const onPathCreated = (opt) => {
  const canvas = unref(canvasRef);
  if (maskGroup && mosaicPreviewLayer) {
    canvas.remove(opt.path);
    maskGroup.addWithUpdate(opt.path);
    canvas.requestRenderAll();
  }
};

/**
 * æ·»åŠ å¯äº¤äº’çš„å½¢çŠ¶æ¡† [ä¿®å¤äº¤äº’å¤±æ•ˆçš„å…³é”®]
 */
const addMosaicShape = (type) => {
  const canvas = unref(canvasRef);
  const center = canvas.getCenter();
  
  // æ£€æŸ¥æ˜¯å¦å·²æœ‰å½¢çŠ¶ï¼Œé¿å…é‡å¤ç”Ÿæˆ
  const existing = canvas.getObjects().find(o => o.name === 'mosaic-shape');
  if (existing) {
    canvas.setActiveObject(existing);
    return;
  }

  const commonTpl = {
    left: center.left, top: center.top,
    fill: 'rgba(64, 158, 255, 0.2)', // åŠé€æ˜è“è‰²ï¼Œè¡¨ç¤ºé€‰åŒº
    stroke: '#409eff', strokeWidth: 2,
    originX: 'center', originY: 'center',
    cornerColor: '#fff', cornerStrokeColor: '#409eff',
    transparentCorners: false,
    name: 'mosaic-shape',
    absolutePositioned: true
  };

  const shape = type === 'rect' 
    ? new fabric.Rect({ ...commonTpl, width: 150, height: 150 })
    : new fabric.Circle({ ...commonTpl, radius: 75 });

  canvas.add(shape);
  canvas.setActiveObject(shape);

  // âœ… å…³é”®ï¼šå½¢çŠ¶å˜åŠ¨æ—¶ï¼Œå¼ºåˆ¶é©¬èµ›å…‹é¢„è§ˆå±‚åˆ·æ–°æ¸²æŸ“
  const updateClip = () => canvas.requestRenderAll();
  shape.on('moving', updateClip);
  shape.on('scaling', updateClip);

  // ä¿®æ”¹é¢„è§ˆå±‚çš„ clipPathï¼Œä½¿å…¶åŒ…å«è·¯å¾„ç»„å’Œå½“å‰äº¤äº’å½¢çŠ¶
  mosaicPreviewLayer.clipPath = new fabric.Group([maskGroup, shape], { 
    absolutePositioned: true 
  });
  
  canvas.requestRenderAll();
};

/**
 * åº”ç”¨é©¬èµ›å…‹ï¼šç¦»å±é«˜æ¸…é‡åˆ¶ [éµå¾ªå…¨æ™¯æŠ¥å‘Šï¼šé«˜æ¸…å‡†åˆ™]
 */
export const applyMosaic = (intensity) => {
  return new Promise((resolve) => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (!bgImage) return resolve();

    // 1. æ•è·è§†è§‰å¿«ç…§ (Viewport Compensation)
    const prevVpt = [...canvas.viewportTransform];
    const prevZoom = canvas.getZoom();
    const imgCenter = bgImage.getCenterPoint();
    const rectCenterScreen = {
      x: imgCenter.x * prevVpt[0] + prevVpt[4],
      y: imgCenter.y * prevVpt[3] + prevVpt[5]
    };

    // 2. æ”¶é›†æ‰€æœ‰ä½œä¸ºé®ç½©çš„å¯¹è±¡
    const shapes = canvas.getObjects().filter(o => o.name === 'mosaic-shape');
    const allMaskObjects = [...maskGroup.getObjects(), ...shapes];
    if (allMaskObjects.length === 0) return resolve();

    const originalSrc = bgImage.getSrc();
    fabric.Image.fromURL(originalSrc, (highResImg) => {
      const { width, height } = highResImg;
      const tempCanvas = new fabric.StaticCanvas(null, { width, height });
      const scale = width / bgImage.getScaledWidth();

      const mosaicLayer = fabric.util.object.clone(highResImg);
      mosaicLayer.filters = [new fabric.Image.filters.Pixelate({ blocksize: intensity })];
      mosaicLayer.applyFilters();

      // åæ ‡æ¢ç®—
      const finalMaskObjects = allMaskObjects.map(obj => {
        const cloned = fabric.util.object.clone(obj);
        const localLeft = (obj.left - (bgImage.left - bgImage.getScaledWidth() / 2)) * scale;
        const localTop = (obj.top - (bgImage.top - bgImage.getScaledHeight() / 2)) * scale;
        cloned.set({
          left: localLeft, top: localTop,
          scaleX: obj.scaleX * scale, scaleY: obj.scaleY * scale,
          absolutePositioned: true
        });
        return cloned;
      });

      mosaicLayer.clipPath = new fabric.Group(finalMaskObjects, { absolutePositioned: true });

      tempCanvas.add(highResImg); 
      tempCanvas.add(mosaicLayer);
      tempCanvas.renderAll();

      const dataURL = tempCanvas.toDataURL({ format: 'png', quality: 1 });
      tempCanvas.dispose();

      // 3. åº”ç”¨å¹¶è¡¥å¿è§†å£
      bgImage.setSrc(dataURL, () => {
        const newZoom = prevZoom / scale;
        bgImage.set({
          scaleX: 1, scaleY: 1, angle: 0,
          originX: 'center', originY: 'center',
          left: canvas.width / 2, top: canvas.height / 2
        });
        bgImage.setCoords();
        canvas.centerObject(bgImage);

        stopMosaicInteraction();

        const newCenterLogic = { x: canvas.width / 2, y: canvas.height / 2 };
        const newPanX = rectCenterScreen.x - newCenterLogic.x * newZoom;
        const newPanY = rectCenterScreen.y - newCenterLogic.y * newZoom;
        canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);

        if (saveHistoryFn) saveHistoryFn();
        canvas.requestRenderAll();
        canvas.fire('zoom:change');
        resolve();
      });
    }, { crossOrigin: 'anonymous' });
  });
};

export const stopMosaicInteraction = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;
  canvas.off('path:created', onPathCreated);
  canvas.isDrawingMode = false;
  
  if (mosaicPreviewLayer) canvas.remove(mosaicPreviewLayer);
  const shapes = canvas.getObjects().filter(o => o.name === 'mosaic-shape');
  if (shapes.length > 0) canvas.remove(...shapes);

  mosaicPreviewLayer = null;
  maskGroup = null;
  canvas.requestRenderAll();
};

export const cancelMosaic = () => {
  stopMosaicInteraction();
};
</file>

<file path="src/components/modules/ai/AiExpand.vue">

</file>

<file path="src/components/modules/ai/AiGenerate.vue">

</file>

<file path="src/components/modules/ai/index.vue">
<!-- aiå·¥å…· -->
  <template>
    aiå·¥å…·
  </template>
</file>

<file path="src/components/modules/border/index.vue">
<!-- è¾¹æ¡† -->
  <template>
    è¾¹æ¡†
  </template>
</file>

<file path="src/components/modules/draw/DrawBrush.vue">
<!-- ç”»ç¬”è®¾ç½® -->
 <template>
    ç”»ç¬”è®¾ç½®
 </template>
</file>

<file path="src/components/modules/draw/DrawShape.vue">
<!-- å‡ ä½•å½¢çŠ¶ -->
  <template>
    å‡ ä½•å½¢çŠ¶
  </template>
</file>

<file path="src/components/modules/draw/index.vue">
<!-- ç»˜åˆ¶ -->
 <template>
    ç»˜åˆ¶
 </template>
</file>

<file path="src/components/modules/material/index.vue">
<!-- ç´ æ -->
  <template>
    ç´ æ
  </template>
</file>

<file path="src/components/modules/text/index.vue">
<!-- æ–‡æœ¬ -->
  <template>
    æ–‡æœ¬
  </template>
</file>

<file path="src/components/modules/text/TextAdd.vue">

</file>

<file path="src/components/modules/text/TextStyle.vue">
<!-- æ–‡æœ¬æ ·å¼ -->
  <template>
    æ–‡æœ¬æ ·å¼
  </template>
</file>

<file path="src/components/modules/watermark/index.vue">
<!-- æ°´å° -->
  <template>
    æ°´å°
  </template>
</file>

<file path="src/composables/useConstraint.js">
import { fabric } from 'fabric';

/**
 * è·å–å¯¹è±¡åœ¨ç”»å¸ƒä¸Šçš„é€»è¾‘çŸ©å½¢ï¼ˆæ¶ˆé™¤ç¼©æ”¾å’Œè§†å£åç§»çš„å½±å“ï¼‰
 * @param {fabric.Object} obj 
 * @param {fabric.Canvas} canvas 
 */
export const getLogicRect = (obj, canvas) => {
    if (!obj || !canvas) return { left: 0, top: 0, width: 0, height: 0 };

    const zoom = canvas.getZoom();
    const vpt = canvas.viewportTransform;

    // getBoundingRect è¿”å›çš„æ˜¯å±å¹•åæ ‡ï¼ˆå— zoom å’Œ viewport å½±å“ï¼‰
    const rawRect = obj.getBoundingRect();

    return {
        left: (rawRect.left - vpt[4]) / zoom,
        top: (rawRect.top - vpt[5]) / zoom,
        width: rawRect.width / zoom,
        height: rawRect.height / zoom
    };
};

/**
 * æ ¸å¿ƒç®—æ³•ï¼šè®¡ç®—â€œå¯¹è±¡â€ç›¸å¯¹äºâ€œå®¹å™¨â€çš„è¶Šç•Œä¿®æ­£å€¼
 * è¿”å›å…·ä½“çš„ deltaX å’Œ deltaYï¼Œä¸ç›´æ¥ä¿®æ”¹å¯¹è±¡
 */
export const calculateConstraintOffset = (targetRect, containerRect) => {
    let deltaX = 0;
    let deltaY = 0;

    // 1. å·¦è¾¹ç•Œæ£€æµ‹
    if (targetRect.left > containerRect.left) {
        deltaX = containerRect.left - targetRect.left;
    }

    // 2. ä¸Šè¾¹ç•Œæ£€æµ‹
    if (targetRect.top > containerRect.top) {
        deltaY = containerRect.top - targetRect.top;
    }

    // 3. å³è¾¹ç•Œæ£€æµ‹
    const targetRight = targetRect.left + targetRect.width;
    const containerRight = containerRect.left + containerRect.width;

    // å¦‚æœå½“å‰å·²ç»åœ¨å³è¾¹ç•Œå†…ï¼Œå°±ä¸éœ€è¦ä¿®æ­£ï¼ˆé™¤éå·¦è¾¹ä¿®æ­£å¯¼è‡´çš„è¿é”ååº”ï¼Œä½†è¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
    // é€»è¾‘ï¼šåªæœ‰å½“å³è¾¹â€œå‡ºç•Œâ€äº†ï¼ˆtargetRight < containerRight æ˜¯æŒ‡å›¾ç‰‡æ²¡å¡«æ»¡å³è¾¹ï¼‰
    // æ³¨æ„ï¼šè¿™é‡Œçš„è¯­ä¹‰æ˜¯â€œå›¾ç‰‡å¿…é¡»è¦†ç›–å®¹å™¨â€ï¼Œæ‰€ä»¥å›¾ç‰‡å³è¾¹å¿…é¡» >= å®¹å™¨å³è¾¹
    if (targetRight < containerRight) {
        // ä¼˜å…ˆä¿è¯å·¦å¯¹é½ï¼Œå¦‚æœå·¦è¾¹æ²¡é—®é¢˜ï¼Œæ‰ä¿®æ­£å³è¾¹
        if (deltaX === 0) {
            deltaX = containerRight - targetRight;
        }
    }

    // 4. ä¸‹è¾¹ç•Œæ£€æµ‹
    const targetBottom = targetRect.top + targetRect.height;
    const containerBottom = containerRect.top + containerRect.height;

    if (targetBottom < containerBottom) {
        if (deltaY === 0) {
            deltaY = containerBottom - targetBottom;
        }
    }

    return { deltaX, deltaY };
};

/**
 * åŠ¨ä½œï¼šç¬é—´ä¿®æ­£å¯¹è±¡ä½ç½®ï¼ˆé€šå¸¸ç”¨äº Resize è¿‡ç¨‹ä¸­ï¼Œæˆ–è€… mouse:up ä¸éœ€è¦åŠ¨ç”»æ—¶ï¼‰
 */
export const constrainObjectToRect = (obj, containerRect, canvas) => {
    if (!obj || !containerRect || !canvas) return false;

    const objRect = getLogicRect(obj, canvas);
    const boxRect = containerRect.type ? getLogicRect(containerRect, canvas) : containerRect;

    const { deltaX, deltaY } = calculateConstraintOffset(objRect, boxRect);

    if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
        obj.left += deltaX;
        obj.top += deltaY;
        obj.setCoords(); // é‡è¦ï¼šæ›´æ–°ç‚¹å‡»åŒºåŸŸ
        return true; // å‘ç”Ÿäº†ä¿®æ­£
    }
    return false; // æ— éœ€ä¿®æ­£
};

/**
 * åŠ¨ä½œï¼šå¸¦åŠ¨ç”»çš„å¹³æ»‘å›å¼¹ï¼ˆå®Œå–„ç‰ˆï¼‰
 * é€‚ç”¨åœºæ™¯ï¼šæ‹¼å›¾æ‹–æ‹½æ¾æ‰‹ã€å›¾ç‰‡ç§»åŠ¨æ¾æ‰‹
 */
export const animateRebound = (obj, containerRect, canvas) => {
    if (!obj || !containerRect || !canvas) return;

    // 1. è®¡ç®—éœ€è¦çš„ä¿®æ­£å€¼
    const objRect = getLogicRect(obj, canvas);
    const boxRect = containerRect.type ? getLogicRect(containerRect, canvas) : containerRect;

    const { deltaX, deltaY } = calculateConstraintOffset(objRect, boxRect);

    // 2. å¦‚æœåç§»é‡å¾ˆå°ï¼Œå¿½ç•¥
    if (Math.abs(deltaX) < 0.5 && Math.abs(deltaY) < 0.5) return;

    // 3. è®¡ç®—ç›®æ ‡åæ ‡
    const targetLeft = obj.left + deltaX;
    const targetTop = obj.top + deltaY;

    // 4. æ‰§è¡Œ Fabric åŠ¨ç”»
    obj.animate({
        left: targetLeft,
        top: targetTop
    }, {
        duration: 300, // åŠ¨ç”»æ—¶é•¿ 300ms
        onChange: canvas.requestRenderAll.bind(canvas), // æ¯ä¸€å¸§éƒ½é‡ç»˜
        onComplete: () => {
            obj.setCoords(); // åŠ¨ç”»ç»“æŸå¿…é¡»æ›´æ–°åæ ‡ï¼Œå¦åˆ™ç‚¹å‡»åŒºåŸŸä¼šé”™ä½
            canvas.requestRenderAll();
        },
        // ä½¿ç”¨æŒ‡æ•°ç¼“åŠ¨ï¼Œç‰©ç†æ„Ÿæ›´å¼º (easeOutExpo)
        easing: fabric.util.ease.easeOutExpo
    });
};
</file>

<file path="src/composables/useKeyboardShortcuts.js">
import { onMounted, onUnmounted } from 'vue';

export function useKeyboardShortcuts(actions) {
  
  const handleKeydown = (e) => {
    // 1. ğŸ›¡ï¸ é¿å¼€è¾“å…¥æ¡†ï¼šå¦‚æœç”¨æˆ·æ­£åœ¨æ‰“å­—ï¼Œä¸è§¦å‘å¿«æ·é”®
    const activeTag = document.activeElement.tagName.toUpperCase();
    if (activeTag === 'INPUT' || activeTag === 'TEXTAREA') {
      return;
    }

    const isCmd = e.ctrlKey || e.metaKey; // Windowsç”¨Ctrl, Macç”¨Command
    const isShift = e.shiftKey;
    const key = e.key.toLowerCase(); // ç»Ÿä¸€è½¬å°å†™åˆ¤æ–­

    // === ç»„åˆé”® (Cmd/Ctrl + ...) ===
    if (isCmd) {
      switch (key) {
        // --- åŸºç¡€ç¼–è¾‘ ---
        case 'c': 
          e.preventDefault(); 
          actions.copyActive();
          break;
          
        case 'v': 
          e.preventDefault();
          actions.pasteActive(); // è‡ªåŠ¨è§¦å‘"é”®ç›˜åç§»ç²˜è´´"
          break;
        
        case 'x': // å‰ªåˆ‡
          e.preventDefault();
          actions.cutActive();
          break;

        case 'z': // æ’¤é”€ & é‡åš
          e.preventDefault();
          if (isShift) {
            actions.redo && actions.redo(); // æ”¯æŒ Ctrl+Shift+Z é‡åš
          } else {
            actions.undo && actions.undo();
          }
          break;
          
        case 'y': // é‡åš (Windows ä¹ æƒ¯)
          e.preventDefault();
          actions.redo && actions.redo();
          break;

        case 'a': // å…¨é€‰ (é¢„ç•™)
          e.preventDefault();
          // actions.selectAll();
          break;

        case 's': // ä¿å­˜ (æ‹¦æˆªæµè§ˆå™¨ä¿å­˜)
          e.preventDefault();
          // actions.saveCanvas(); 
          break;
          
        // --- é”å®š (Ctrl + Shift + L) ---
        case 'l': 
          if (isShift) {
            e.preventDefault(); // é˜²æ­¢æµè§ˆå™¨è·³åˆ°åœ°å€æ 
            actions.toggleLock();
          }
          break;
      }
    } 
    
    // === å•é”®æˆ– Shift ç»„åˆé”® (ä¸æŒ‰ Ctrl) ===
    else {
      switch (e.key) { // è¿™é‡ŒåŒºåˆ†å¤§å°å†™æˆ–è€…ç”¨ key code æ›´å‡†ç¡®ï¼Œè¿™é‡Œç›´æ¥ç”¨å­—ç¬¦
        // --- åˆ é™¤ ---
        case 'Delete':
        case 'Backspace':
          actions.deleteActive();
          break;

        // --- å›¾å±‚å±‚çº§ (å…³é”®) ---
        case '[': // å·¦ä¸­æ‹¬å·
          if (isShift) {
             actions.moveLayer('back'); // Shift + [ = ç½®åº•
          } else {
             actions.moveLayer('backward'); // [ = ä¸‹ç§»ä¸€å±‚
          }
          break;

        case ']': // å³ä¸­æ‹¬å·
          if (isShift) {
             actions.moveLayer('front'); // Shift + ] = ç½®é¡¶
          } else {
             actions.moveLayer('forward'); // ] = ä¸Šç§»ä¸€å±‚
          }
          break;
      }
    }
  };

  onMounted(() => {
    window.addEventListener('keydown', handleKeydown);
  });

  onUnmounted(() => {
    window.removeEventListener('keydown', handleKeydown);
  });
}
</file>

<file path="src/composables/useObjectActions.js">
import { inject, unref, reactive, readonly } from 'vue';
import { toast } from '@/utils/toast'; 

// 1. å®šä¹‰å…¨å±€å‰ªè´´æ¿çŠ¶æ€ (æ”¾åœ¨å‡½æ•°å¤–ï¼Œä¿è¯è·¨ç»„ä»¶å…±äº«)
const clipboardState = reactive({
    hasContent: false, 
    data: null         
});

export function useObjectActions() {
    const canvasAPI = inject('canvasAPI');
    
    const getContext = () => {
        const canvas = unref(canvasAPI?.canvas);
        const activeObj = canvas?.getActiveObject();
        return { canvas, activeObj };
    };

    // === 1. åˆ é™¤ ===
    const deleteActive = () => {
        const { canvas, activeObj } = getContext();
        if (!canvas || !activeObj) return;
        
        if (activeObj.type === 'activeSelection') {
            activeObj.forEachObject(obj => canvas.remove(obj));
            canvas.discardActiveObject();
        } else {
            canvas.remove(activeObj);
        }
        canvas.requestRenderAll();
        canvasAPI.saveHistory && canvasAPI.saveHistory();
    };

    // === 2. å¤åˆ¶ ===
    const copyActive = () => {
        const { activeObj } = getContext();
        if (!activeObj) return;
        
        activeObj.clone((cloned) => {
            // å­˜å…¥å…¨å±€çŠ¶æ€
            clipboardState.data = cloned;
            clipboardState.hasContent = true; 
            toast.success('å·²å¤åˆ¶');
        });
    };

    // === 3. å‰ªåˆ‡ ===
    const cutActive = () => {
        const { canvas, activeObj } = getContext();
        if (!activeObj) return;
        
        activeObj.clone((cloned) => {
            clipboardState.data = cloned;
            clipboardState.hasContent = true;
            
            // å¤åˆ¶ååˆ é™¤åŸå¯¹è±¡
            if (activeObj.type === 'activeSelection') {
                activeObj.forEachObject(obj => canvas.remove(obj));
                canvas.discardActiveObject();
            } else {
                canvas.remove(activeObj);
            }
            canvas.requestRenderAll();
            canvasAPI.saveHistory && canvasAPI.saveHistory();
            toast.success('å·²å‰ªåˆ‡');
        });
    };

    // === 4. ç²˜è´´ (æ ¸å¿ƒä¿®æ”¹é€»è¾‘) ===
    const pasteActive = (point = null) => {
        // ä»å…¨å±€çŠ¶æ€è¯»å–
        if (!clipboardState.data) {
            return;
        }

        const { canvas } = getContext();
        if (!canvas) return;

        clipboardState.data.clone((clonedObj) => {
            canvas.discardActiveObject();

            clonedObj.set({
                evented: true,
            });

            if (point) {
                // æƒ…å†µ A: å³é”®å®šç‚¹ç²˜è´´
                clonedObj.set({
                    left: point.x,
                    top: point.y,
                    originX: 'left',
                    originY: 'top',
                });
            } else {
                // æƒ…å†µ B: é”®ç›˜å¿«æ·é”®ç²˜è´´ (è‡ªåŠ¨åç§»)
                clonedObj.set({
                    left: clonedObj.left + 20,
                    top: clonedObj.top + 20,
                    originX: 'left',
                    originY: 'top',
                });
            }

            if (clonedObj.type === 'activeSelection') {
                clonedObj.canvas = canvas;
                clonedObj.forEachObject((obj) => {
                    canvas.add(obj);
                });
                clonedObj.setCoords();
            } else {
                canvas.add(clonedObj);
            }
            
            canvas.setActiveObject(clonedObj);
            canvas.requestRenderAll();
            canvasAPI.saveHistory && canvasAPI.saveHistory();
            
            // æ›´æ–°å‰ªè´´æ¿å¼•ç”¨ï¼Œæ”¯æŒè¿ç»­ç²˜è´´
            clipboardState.data = clonedObj; 
        });
    };

    // === 5. é”å®š/è§£é” ===
    const toggleLock = () => {
        const { canvas, activeObj } = getContext();
        if (!activeObj) return;

        const isLocked = !activeObj.lockMovementX;
        
        activeObj.set({
            lockMovementX: isLocked,
            lockMovementY: isLocked,
            lockRotation: isLocked,
            lockScalingX: isLocked,
            lockScalingY: isLocked
        });

        if (isLocked) {
             activeObj.selectable = true; 
             toast.success('å¯¹è±¡å·²é”å®š');
        } else {
             toast.success('å¯¹è±¡å·²è§£é”');
        }
        
        canvas.requestRenderAll();
        canvasAPI.saveHistory && canvasAPI.saveHistory();
        return isLocked;
    };

    // === 6. å›¾å±‚è°ƒæ•´ (ä¿ç•™æ‰€æœ‰é€»è¾‘) ===
    const moveLayer = (direction) => {
        const { canvas, activeObj } = getContext();
        if (!activeObj) return;

        const objects = canvas.getObjects();
        // æŸ¥æ‰¾ä¸»å›¾ä½ç½®ï¼Œç¡®ä¿ä¸è¦†ç›–ä¸»å›¾
        const mainImgIndex = objects.findIndex(o => o.isMainImage);
        const floorIndex = mainImgIndex >= 0 ? mainImgIndex + 1 : 0;
        const currentIndex = objects.indexOf(activeObj);

        switch (direction) {
            case 'front': 
                activeObj.bringToFront(); 
                break;
            case 'back': 
                if (currentIndex > floorIndex) activeObj.moveTo(floorIndex);
                break;
            case 'forward': 
                activeObj.bringForward(); 
                break;
            case 'backward': 
                if (currentIndex > floorIndex) {
                    activeObj.sendBackwards();
                    // é˜²æ­¢è¢«é€åˆ°åº•å›¾ä¸‹é¢
                    const newIndex = canvas.getObjects().indexOf(activeObj);
                    if (newIndex <= mainImgIndex && mainImgIndex !== -1) {
                         activeObj.moveTo(floorIndex);
                    }
                }
                break;
        }
        canvas.requestRenderAll();
        canvasAPI.saveHistory && canvasAPI.saveHistory();
    };

    return {
        clipboardState: readonly(clipboardState),
        deleteActive,
        copyActive,
        cutActive,
        pasteActive,
        toggleLock,
        moveLayer
    };
}
</file>

<file path="src/composables/useOffscreenHelper.js">
import { fabric } from 'fabric';

/**
 * é€šç”¨ï¼šé«˜ä¿çœŸç¦»å±æ¸²æŸ“å™¨
 * @param {fabric.Image} originalImageObj ç”»å¸ƒä¸Šçš„æºå›¾ç‰‡å¯¹è±¡ï¼ˆç”¨äºè·å–åŸå›¾ URL å’Œå½“å‰çŠ¶æ€ï¼‰
 * @param {Number} targetWidth ç›®æ ‡å¯¼å‡ºå®½åº¦
 * @param {Number} targetHeight ç›®æ ‡å¯¼å‡ºé«˜åº¦
 * @param {Function} transformCallback å›è°ƒå‡½æ•°ï¼Œè®©ä½ åœ¨ç¦»å± canvas ä¸Šè°ƒæ•´å›¾ç‰‡å‚æ•°
 * @returns {Promise<string>} è¿”å›ç”Ÿæˆçš„ Base64
 */
export const renderHighResSnapshot = (originalImageObj, targetWidth, targetHeight, transformCallback) => {
    return new Promise((resolve) => {
        const originalSrc = originalImageObj.getSrc();

        // 1. åˆ›å»ºç¦»å±ç”»å¸ƒ
        const tempCanvas = new fabric.StaticCanvas(null, {
            width: targetWidth,
            height: targetHeight,
            backgroundColor: 'transparent'
        });

        // 2. åŠ è½½åŸå›¾ï¼ˆé¿å…ä½¿ç”¨ç¼“å­˜çš„ç¼©ç•¥å›¾ï¼‰
        fabric.Image.fromURL(originalSrc, (highResImg) => {

            // 3. æ‰§è¡Œè°ƒç”¨è€…çš„è‡ªå®šä¹‰å˜æ¢é€»è¾‘
            if (transformCallback) {
                transformCallback(highResImg, tempCanvas);
            } else {
                // é»˜è®¤è¡Œä¸ºï¼šå±…ä¸­å¡«æ»¡
                highResImg.set({
                    originX: 'center', originY: 'center',
                    left: targetWidth / 2, top: targetHeight / 2
                });
                // ç®€å•çš„ Cover é€»è¾‘...
            }

            tempCanvas.add(highResImg);
            tempCanvas.renderAll();

            // 4. å¯¼å‡º
            const dataURL = tempCanvas.toDataURL({ format: 'png', quality: 1 });

            // 5. æ¸…ç†å†…å­˜
            tempCanvas.dispose();

            resolve(dataURL);
        }, { crossOrigin: 'anonymous' });
    });
};
</file>

<file path="src/config/shortcuts.js">
// src/config/shortcuts.js

export const SHORTCUT_GROUPS = [
  {
    title: 'åŸºç¡€ç¼–è¾‘ (Editing)',
    items: [
      { label: 'å¤åˆ¶', keys: ['Ctrl', 'C'] },
      { label: 'ç²˜è´´', keys: ['Ctrl', 'V'] },
      { label: 'å‰ªåˆ‡', keys: ['Ctrl', 'X'] },
      { label: 'æ’¤é”€', keys: ['Ctrl', 'Z'] },
      { label: 'é‡åš', keys: ['Ctrl', 'Y'] },
      { label: 'åˆ é™¤', keys: ['Delete'] },
    ]
  },
  {
    title: 'å›¾å±‚ç®¡ç† (Layers)',
    items: [
      { label: 'ä¸Šç§»ä¸€å±‚', keys: [']'] },
      { label: 'ä¸‹ç§»ä¸€å±‚', keys: ['['] },
      { label: 'ç½®é¡¶', keys: ['Shift', ']'] },
      { label: 'ç½®åº•', keys: ['Shift', '['] },
      { label: 'é”å®š/è§£é”', keys: ['Ctrl', 'Shift', 'L'] },
    ]
  },
  {
    title: 'ç”»å¸ƒè§†å›¾ (View)',
    items: [
      { label: 'æ”¾å¤§', keys: ['Ctrl', '+'] }, // å‡è®¾ä½ æœªæ¥ä¼šåŠ è¿™ä¸ª
      { label: 'ç¼©å°', keys: ['Ctrl', '-'] },
      { label: 'é‡ç½®ç¼©æ”¾', keys: ['Ctrl', '0'] },
      { label: 'å¹³ç§»ç”»å¸ƒ', keys: ['Space', 'Drag'] },
    ]
  }
];
</file>

<file path="src/index.js">
import EditorLayout from './components/layout/EditorLayout.vue';
import './style.css'; // ç¡®ä¿æ ·å¼è¢«å¼•å…¥

// å¯¼å‡ºä¸»ç»„ä»¶
export { EditorLayout };
// é»˜è®¤å¯¼å‡º
export default EditorLayout;
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>image-editor</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
</file>

<file path="src/App.vue">
<template>
  <EditorLayout />
</template>

<script setup>
import EditorLayout from './components/layout/EditorLayout.vue';
</script>

<style>
html,
body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  /* é˜²æ­¢å‡ºç°æ»šåŠ¨æ¡ */
}

#app {
  width: 100%;
  height: 100%;
}

.app-wrapper {
  width: 100vw;
  /* å¼ºåˆ¶è§†å£å®½åº¦ */
  height: 100vh;
  /* å¼ºåˆ¶è§†å£é«˜åº¦ */
  display: flex;
  flex-direction: column;
}
</style>
</file>

<file path="src/components/common/FloatingObjectMenu.vue">
<template>
  <div
    v-show="isVisible"
    class="floating-wrapper"
    :style="{ left: position.left + 'px', top: position.top + 'px' }"
  >
    <button
      class="trigger-btn"
      @click.stop="toggleMenu"
      :class="{ active: isMenuOpen }"
      title="æ›´å¤šæ“ä½œ"
    >
      <svg
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
      >
        <circle cx="12" cy="12" r="1"></circle>
        <circle cx="19" cy="12" r="1"></circle>
        <circle cx="5" cy="12" r="1"></circle>
      </svg>
    </button>

    <div v-if="isMenuOpen" class="main-menu">
      <div class="menu-item" @click="handleAction(actions.copyActive)">
        <span class="icon">
          <svg
            width="14"
            height="14"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path
              d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"
            ></path>
          </svg>
        </span>
        <span class="label">å¤åˆ¶</span>
        <span class="shortcut">Ctrl+C</span>
      </div>

      <div class="menu-item" @click="handleAction(actions.cutActive)">
        <span class="icon">
          <svg
            width="14"
            height="14"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <circle cx="6" cy="6" r="3"></circle>
            <circle cx="6" cy="18" r="3"></circle>
            <line x1="20" y1="4" x2="8.12" y2="15.88"></line>
            <line x1="14.47" y1="14.48" x2="20" y2="20"></line>
            <line x1="8.12" y1="8.12" x2="12" y2="12"></line>
          </svg>
        </span>
        <span class="label">å‰ªåˆ‡</span>
        <span class="shortcut">Ctrl+X</span>
      </div>

      <div class="menu-item" @click="handleLock">
        <span class="icon">
          <svg
            v-if="isLocked"
            width="14"
            height="14"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
            <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
          </svg>
          <svg
            v-else
            width="14"
            height="14"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
            <path d="M7 11V7a5 5 0 0 1 9.9-1"></path>
          </svg>
        </span>
        <span class="label">{{ isLocked ? "è§£é”" : "é”å®š" }}</span>
        <span class="shortcut">Shift+Ctrl+L</span>
      </div>

      <div class="menu-item has-submenu">
        <span class="icon">
          <svg
            width="14"
            height="14"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <polyline points="2 17 12 22 22 17"></polyline>
            <polyline points="2 12 12 17 22 12"></polyline>
            <polyline points="2 7 12 12 22 7"></polyline>
          </svg>
        </span>
        <span class="label">å›¾å±‚é¡ºåº</span>
        <span class="arrow-right">
          <svg
            width="12"
            height="12"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <polyline points="9 18 15 12 9 6"></polyline>
          </svg>
        </span>

        <div class="submenu">
          <div
            class="menu-item"
            @click="handleAction(() => actions.moveLayer('forward'))"
          >
            <span class="label">ä¸Šä¸€å±‚</span>
            <span class="shortcut">]</span>
          </div>
          <div
            class="menu-item"
            @click="handleAction(() => actions.moveLayer('backward'))"
          >
            <span class="label">ä¸‹ä¸€å±‚</span>
            <span class="shortcut">[</span>
          </div>
          <div class="divider"></div>
          <div
            class="menu-item"
            @click="handleAction(() => actions.moveLayer('front'))"
          >
            <span class="label">ç½®é¡¶</span>
            <span class="shortcut">Shift+]</span>
          </div>
          <div
            class="menu-item"
            @click="handleAction(() => actions.moveLayer('back'))"
          >
            <span class="label">ç½®åº•</span>
            <span class="shortcut">Shift+[</span>
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="menu-item delete" @click="handleAction(actions.deleteActive)">
        <span class="icon">
          <svg
            width="14"
            height="14"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <polyline points="3 6 5 6 21 6"></polyline>
            <path
              d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"
            ></path>
          </svg>
        </span>
        <span class="label">åˆ é™¤</span>
        <span class="shortcut">Del</span>
      </div>

      <div v-if="$slots.extra">
        <div class="divider"></div>
        <slot name="extra"></slot>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, inject, onMounted, onUnmounted, unref } from "vue";
import { useObjectActions } from "@/composables/useObjectActions";

const canvasAPI = inject("canvasAPI");
const actions = useObjectActions();

const isVisible = ref(false);
const isMenuOpen = ref(false);
const isLocked = ref(false);
const position = ref({ left: 0, top: 0 });

const toggleMenu = () => {
  isMenuOpen.value = !isMenuOpen.value;
};

const handleAction = (actionFn) => {
  actionFn();
  isMenuOpen.value = false;
};

const handleLock = () => {
  const locked = actions.toggleLock();
  isLocked.value = locked;
};

// æ›´æ–°èœå•ä½ç½®
const updatePosition = () => {
  const canvas = unref(canvasAPI.canvas);
  const activeObj = canvas?.getActiveObject();

  // ğŸ›¡ï¸ [å…³é”®ä¿®å¤]ï¼šå¦‚æœå¯¹è±¡è¢«æ ‡è®°ä¸ºä¸å¯å“åº” (evented: false) æˆ–è€…ä¸å¯é€‰ä¸­ (selectable: false)ï¼Œ
  // åšå†³ä¸æ˜¾ç¤ºèœå•ï¼è¿™èƒ½é˜²æ­¢æ¼ç½‘ä¹‹é±¼ã€‚
  if (
    !activeObj ||
    activeObj.isMainImage ||
    activeObj.evented === false ||
    activeObj.selectable === false
  ) {
    isVisible.value = false;
    isMenuOpen.value = false;
    return;
  }

  const coords = activeObj.getBoundingRect(true, true);
  const containerWidth = canvas.getElement().parentElement.offsetWidth;
  const menuWidth = 40;

  let newLeft = coords.left + coords.width + 40;

  if (newLeft + menuWidth > containerWidth) {
    newLeft = coords.left - menuWidth + 76;
  }

  position.value = {
    left: newLeft,
    top: coords.top + 5,
  };

  isVisible.value = true;
  isLocked.value = !!activeObj.lockMovementX;
};

const bindEvents = () => {
  const canvas = unref(canvasAPI.canvas);
  if (!canvas) return;

  const events = [
    "selection:created",
    "selection:updated",
    "object:moving",
    "object:scaling",
    "object:rotating",
    "object:modified",
  ];
  events.forEach((evt) => canvas.on(evt, updatePosition));

  canvas.on("selection:cleared", () => {
    isVisible.value = false;
    isMenuOpen.value = false;
  });
};

const unbindEvents = () => {
  const canvas = unref(canvasAPI.canvas);
  if (!canvas) return;
  canvas.off("selection:cleared");
  const events = [
    "selection:created",
    "selection:updated",
    "object:moving",
    "object:scaling",
    "object:rotating",
    "object:modified",
  ];
  events.forEach((evt) => canvas.off(evt));
};

onMounted(() => setTimeout(bindEvents, 200));
onUnmounted(unbindEvents);
</script>

<style scoped>
.floating-wrapper {
  position: absolute;
  z-index: 2000;
  pointer-events: auto;
}

.trigger-btn {
  width: 24px;
  height: 24px;
  border-radius: 8px;
  background: #ffffff;
  border: 1px solid #e4e7ed;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #606266;
  transition: all 0.2s;
  padding: 0 !important;
}

.trigger-btn:hover,
.trigger-btn.active {
  background: #ecf5ff;
  color: var(--ie-primary-color);
  border-color: var(--ie-primary-color);
}

.main-menu {
  position: absolute;
  top: 15px;
  left: 22px;
  width: 180px;
  background: #ffffff;
  border: 1px solid #ebeef5;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
  padding: 4px 0;
  display: flex;
  flex-direction: column;
}

.menu-item {
  position: relative;
  display: flex;
  align-items: center;
  padding: 8px 12px;
  font-size: 13px;
  color: #606266;
  cursor: pointer;
  transition: background 0.1s;
}

.menu-item:hover {
  background: #f5f7fa;
  color: var(--ie-primary-color);
}

.menu-item.delete:hover {
  background: #fef0f0;
  color: #f56c6c;
}

.icon {
  display: flex;
  align-items: center;
  margin-right: 8px;
  width: 16px;
  opacity: 0.8;
}

.label {
  flex: 1;
}

.shortcut {
  font-size: 11px;
  color: #909399;
  margin-left: 8px;
  font-family: monospace;
  opacity: 0.8;
}

.arrow-right {
  margin-left: auto;
  opacity: 0.5;
  display: flex;
  align-items: center;
}

.divider {
  height: 1px;
  background: #ebeef5;
  margin: 4px 0;
}

.submenu {
  display: none;
  position: absolute;
  left: 100%;
  top: -4px;
  width: 140px;
  background: #ffffff;
  border: 1px solid #ebeef5;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
  padding: 4px 0;
  margin-left: 4px;
}

.menu-item.has-submenu:hover .submenu {
  display: block;
}

.menu-item.has-submenu::after {
  content: "";
  position: absolute;
  top: 0;
  right: -10px;
  width: 10px;
  height: 100%;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustMosaic.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="7" height="7" /><rect x="14" y="3" width="7" height="7" />
          <rect x="14" y="14" width="7" height="7" /><rect x="3" y="14" width="7" height="7" />
        </svg>
        <span>é©¬èµ›å…‹</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content filter-panel">
      <div class="mode-row">
        <div class="mode-btn" :class="{ active: activeMode === 'path' }" @click="setMode('path')" title="æ¶‚æŠ¹">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM4 11c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm16 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
        </div>
        <div class="mode-btn" :class="{ active: activeMode === 'rect' }" @click="setMode('rect')" title="çŸ©å½¢">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" /></svg>
        </div>
        <div class="mode-btn" :class="{ active: activeMode === 'circle' }" @click="setMode('circle')" title="åœ†å½¢">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9" /></svg>
        </div>
      </div>

      <div class="intensity-section">
        <div class="label-row">
          <span>å¼ºåº¦</span>
          <input type="number" v-model.number="intensity" class="ie-input-number" @change="updateConfig">
        </div>
        <input type="range" v-model.number="intensity" min="4" max="100" class="ie-slider" @input="updateConfig">
      </div>

      <div class="action-buttons">
        <button class="ie-btn ie-primary full" @click="handleApply" :disabled="loading">
          {{ loading ? 'å¤„ç†ä¸­...' : 'ç¡®å®šåº”ç”¨' }}
        </button>
        <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted } from 'vue';
import { registerMosaicModule, startMosaicInteraction, applyMosaic, cancelMosaic } from './useCanvasMosaic';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const activeMode = ref('path');
const intensity = ref(15);
const loading = ref(false);

const setMode = (mode) => {
  activeMode.value = mode;
  startMosaicInteraction(mode, intensity.value);
};

const updateConfig = () => {
  startMosaicInteraction(activeMode.value, intensity.value);
};

const handleApply = async () => {
  loading.value = true;
  await applyMosaic(intensity.value);
  loading.value = false;
  emit('toggle');
};

const handleCancel = () => {
  cancelMosaic();
  emit('toggle');
};

watch(() => props.isExpanded, (val) => {
  if (val) setMode('path');
  else cancelMosaic();
});

onMounted(() => {
  if (canvasAPI?.canvas) registerMosaicModule(canvasAPI.canvas, canvasAPI.saveHistory);
});

// ç»„ä»¶é”€æ¯æ—¶ç¡®ä¿æ¸…ç†äº¤äº’çŠ¶æ€
onUnmounted(() => {
  cancelMosaic();
});
</script>

<style scoped>
.filter-panel { padding: 16px; }
.mode-row { display: flex; justify-content: space-between; margin-bottom: 24px; gap: 12px; }
.mode-btn { 
  flex: 1; height: 44px; display: flex; align-items: center; justify-content: center; 
  border-radius: 8px; background: #f5f7fa; cursor: pointer; border: 1px solid transparent; transition: 0.2s; 
}
.mode-btn:hover { background: #eef1f6; color: #333; }
.mode-btn.active { background: #ecf5ff; border-color: var(--ie-primary-color); color: var(--ie-primary-color); }

.intensity-section { margin-bottom: 24px; }
/* label-row ç»§æ‰¿å®ªæ³•è§„èŒƒï¼Œè¿™é‡Œå¾®è°ƒé—´è· */
.label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; font-size: 13px; color: #606266; }

.action-buttons { display: flex; gap: 10px; }
.full { flex: 1; }
</style>
</file>

<file path="src/components/modules/adjust/useCanvasColor.js">
// src/components/modules/adjust/useCanvasColor.js
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let originalFilters = []; // ç”¨äºå–æ¶ˆæ—¶æ¢å¤

export const registerColorModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};

/**
 * æ ¸å¿ƒï¼šåº”ç”¨ç»„åˆæ»¤é•œ
 * @param {Object} params - åŒ…å«äº®åº¦ã€å¯¹æ¯”åº¦ç­‰æ•°å€¼çš„å¯¹è±¡
 */
export const applyColorAdjust = (params) => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) return;

    // è®°å½•åˆå§‹çŠ¶æ€ç”¨äºæ¢å¤
    if (originalFilters.length === 0 && bgImage.filters.length > 0) {
        originalFilters = [...bgImage.filters];
    }

    const filters = [];

    // 1. æ¨¡ç³Š (-100 ~ 0) / é”åŒ– (0 ~ 100)
    if (params.blurSharpen < 0) {
        filters.push(new fabric.Image.filters.Blur({ blur: Math.abs(params.blurSharpen) / 100 }));
    } else if (params.blurSharpen > 0) {
        filters.push(new fabric.Image.filters.Convolute({
            matrix: [0, -1, 0, -1, 5, -1, 0, -1, 0] // é”åŒ–çŸ©é˜µ
        }));
    }

    // 2. é¥±å’Œåº¦ (-100 ~ 100 -> -1 ~ 1)
    if (params.saturation !== 0) {
        filters.push(new fabric.Image.filters.Saturation({ saturation: params.saturation / 100 }));
    }

    // 3. äº®åº¦ (-100 ~ 100 -> -1 ~ 1)
    if (params.brightness !== 0) {
        filters.push(new fabric.Image.filters.Brightness({ brightness: params.brightness / 100 }));
    }

    // 4. å¯¹æ¯”åº¦ (-100 ~ 100 -> -1 ~ 1)
    if (params.contrast !== 0) {
        filters.push(new fabric.Image.filters.Contrast({ contrast: params.contrast / 100 }));
    }

    // 5. è‰²æ¸© (é€šè¿‡ ColorMatrix æ¨¡æ‹Ÿ)
    if (params.temperature !== 0) {
        const temp = params.temperature / 100;
        filters.push(new fabric.Image.filters.ColorMatrix({
            matrix: [
                1 + temp, 0, 0, 0, 0, // R
                0, 1, 0, 0, 0,        // G
                0, 0, 1 - temp, 0, 0, // B
                0, 0, 0, 1, 0         // A
            ]
        }));
    }

    // 6. è‰²è°ƒ (-100 ~ 100 -> -1 ~ 1)
    if (params.hue !== 0) {
        filters.push(new fabric.Image.filters.HueRotation({ rotation: params.hue / 100 }));
    }

    bgImage.filters = filters;
    bgImage.applyFilters();
    canvas.requestRenderAll();
};

export const cancelColorAdjust = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        bgImage.filters = [...originalFilters];
        bgImage.applyFilters();
        canvas.requestRenderAll();
    }
    originalFilters = [];
};

export const commitColorAdjust = () => {
    if (saveHistoryFn) saveHistoryFn();
    originalFilters = [];
};
</file>

<file path="src/components/modules/adjust/useCanvasColorOverlay.js">
// src/components/modules/adjust/useCanvasColorOverlay.js
import { unref } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let backupFilters = [];
let backupColor = null;    // âœ… æ–°å¢ï¼šå¤‡ä»½é¢œè‰²
let backupOpacity = 30;


export const registerColorOverlayModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};


/**
 * å¤‡ä»½å½“å‰çŠ¶æ€ï¼ˆåŒ…å«æ»¤é•œæ•°ç»„å’Œå…ƒæ•°æ®ï¼‰
 */
export const backupCurrentColorOverlay = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        // æ·±æ‹·è´æ»¤é•œæ•°ç»„
        backupFilters = [...bgImage.filters];
        // å¤‡ä»½å…ƒæ•°æ®
        backupColor = bgImage._lastOverlayColor || null;
        backupOpacity = bgImage._lastOverlayOpacity ?? 30;
    }
};

/**
 * åº”ç”¨é¢œè‰²å åŠ ï¼šè®°å½•å…ƒæ•°æ®åˆ°å›¾ç‰‡å¯¹è±¡
 */
export const applyColorOverlay = (color, opacity = 30) => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) return;

    // è®°å½•å…ƒæ•°æ®ï¼Œç”¨äº UI çŠ¶æ€åŒæ­¥
    bgImage._lastOverlayColor = color;
    bgImage._lastOverlayOpacity = opacity;

    const existingIndex = bgImage.filters.findIndex(f => f instanceof fabric.Image.filters.BlendColor);

    if (!color) {
        if (existingIndex > -1) {
            bgImage.filters.splice(existingIndex, 1);
        }
    } else {
        const filter = new fabric.Image.filters.BlendColor({
            color: color,
            mode: 'tint',
            alpha: opacity / 100
        });

        if (existingIndex > -1) {
            bgImage.filters[existingIndex] = filter;
        } else {
            bgImage.filters.push(filter);
        }
    }

    bgImage.applyFilters();
    canvas.requestRenderAll();
};

/**
 * å–æ¶ˆä¿®æ”¹ï¼šè¿˜åŸæ»¤é•œæ•°ç»„å’Œå…ƒæ•°æ®
 */
export const cancelColorOverlayChange = () => {
    const canvas = unref(canvasRef);
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    if (bgImage) {
        bgImage.filters = [...backupFilters];
        // è¿˜åŸå…ƒæ•°æ®
        bgImage._lastOverlayColor = backupColor;
        bgImage._lastOverlayOpacity = backupOpacity;
        
        bgImage.applyFilters();
        canvas.requestRenderAll();
    }
    backupFilters = [];
};

export const commitColorOverlay = () => {
    if (saveHistoryFn) saveHistoryFn(); // ä¿å­˜å†å²è®°å½•
    backupFilters = [];
};
</file>

<file path="src/config/theme.js">
// src/config/theme.js

/**
 * ğŸ¨ Design Token Source (Single Source of Truth)
 * ä¾› Canvas (JS) å’Œ UI (CSS) å…±åŒä½¿ç”¨
 */
export const THEME = {
    colors: {
        // å“ç‰Œè‰² (å¯¹åº” style.css ä¸­çš„ --ie-primary-color)
        primary: '#409eff',
        primaryHover: '#66b1ff',

        // åŸºç¡€è‰²
        bg: '#242424',            // ç”»å¸ƒèƒŒæ™¯
        panel: '#1e1e1e',         // å·¥å…·æ èƒŒæ™¯ (å¦‚æœä½ éœ€è¦åŒºåˆ†çš„è¯)
        text: 'rgba(255, 255, 255, 0.87)',
        border: '#dcdfe6',

        // Canvas äº¤äº’ä¸“ç”¨ (JS è¯»å–)
        selectionBorder: '#409eff',
        selectionFill: 'rgba(64, 158, 255, 0.1)',
    },

    // å­—ä½“æ ˆ
    fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif',
};

/**
 * æ³¨å…¥ä¸»é¢˜å˜é‡åˆ° CSS
 * @param {HTMLElement} [targetElement] - å¦‚æœä¼ å…¥ï¼Œåªæ³¨å…¥è¯¥å…ƒç´ çš„ styleï¼›å¦åˆ™æ³¨å…¥åˆ° document.documentElement
 */
export const applyTheme = (targetElement) => {
    const root = targetElement || document.documentElement;
    const { colors, fontFamily } = THEME;

    // æ³¨å…¥æ ¸å¿ƒå˜é‡
    root.style.setProperty('--ie-primary-color', colors.primary);
    root.style.setProperty('--ie-bg-color', colors.bg);
    root.style.setProperty('--ie-text-color', colors.text);
    root.style.setProperty('--ie-border-color', colors.border);
    root.style.setProperty('--ie-font-family', fontFamily);
    console.log(targetElement);
    console.log(`ğŸ¨ Theme applied to ${targetElement ? 'SDK Container' : 'Global Root'}`);
};
</file>

<file path="src/utils/toast.js">
export const toast = {
    show(text, type = 'info') {
        const div = document.createElement('div');
        div.className = 'ie-toast';
        div.innerText = text;
        // ç®€å•åŒºåˆ†é¢œè‰²
        if (type === 'error') div.style.background = 'rgba(255, 77, 79, 0.9)';
        if (type === 'success') div.style.background = 'rgba(82, 196, 26, 0.9)';

        document.body.appendChild(div);
        setTimeout(() => {
            div.style.transition = 'opacity 0.3s';
            div.style.opacity = '0';
            setTimeout(() => div.remove(), 300);
        }, 2000);
    },
    success(text) { this.show(text, 'success'); },
    warning(text) { this.show(text, 'warning'); },
    error(text) { this.show(text, 'error'); },
    info(text) { this.show(text, 'info'); }
};
</file>

<file path="src/api/ai.js">
// src/api/ai.js

// é»˜è®¤åœ°å€ (ä½œä¸ºå…œåº•ï¼Œé˜²æ­¢è°ƒç”¨æ—¶ä¼ ç©º)
const DEFAULT_BASE_URL = 'http://localhost:3000/ai';

export const aiApi = {
  /**
   * ç§»é™¤èƒŒæ™¯
   * @param {File} file - å›¾ç‰‡æ–‡ä»¶
   * @param {string} [baseUrl] - åç«¯ API åŸºç¡€åœ°å€
   * @returns {Promise<string>} - Blob URL
   */
  async removeBackground(file, baseUrl = DEFAULT_BASE_URL) {
    const formData = new FormData();
    formData.append('image', file);

    // æ‹¼æ¥å®Œæ•´çš„ URLï¼Œç§»é™¤æœ«å°¾å¯èƒ½å¤šä½™çš„æ–œæ 
    const cleanBaseUrl = baseUrl.replace(/\/+$/, '');

    try {
      const response = await fetch(`${cleanBaseUrl}/rembg`, {
        method: 'POST',
        body: formData,
        // fetch è‡ªåŠ¨å¤„ç† multipart/form-data çš„ Content-Typeï¼Œæ— éœ€æ‰‹åŠ¨è®¾ç½®
      });

      if (!response.ok) {
        throw new Error(`è¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
      }

      const blob = await response.blob();
      return URL.createObjectURL(blob);
    } catch (error) {
      console.error('AI API Error:', error);
      throw error;
    }
  },

  /**
   * å›¾åƒä¿®å¤ (Inpaint)
   * @param {Blob} imageBlob 
   * @param {Blob} maskBlob 
   * @param {string} [baseUrl] 
   */
  async inpaint(imageBlob, maskBlob, baseUrl = DEFAULT_BASE_URL) {
    const formData = new FormData();
    formData.append('image', imageBlob);
    formData.append('mask', maskBlob);

    const cleanBaseUrl = baseUrl.replace(/\/+$/, '');

    try {
      const response = await fetch(`${cleanBaseUrl}/inpaint`, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`è¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
      }

      const blob = await response.blob();
      return URL.createObjectURL(blob);
    } catch (error) {
      console.error('AI API Error:', error);
      throw error;
    }
  },

  /**
    * AI æ™ºèƒ½æ¶ˆé™¤æ¥å£
    * @param {string} imageUrl - åŸå›¾ URL
    * @param {string} maskBase64 - é®ç½©å›¾ç‰‡ Base64 (é»‘åº•ç™½å›¾)
    * @returns {Promise<string>} å¤„ç†åçš„å›¾ç‰‡ URL
    */
  async inpaint(imageUrl, maskBase64) {
    // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    return new Promise((resolve) => {
      console.log('Calling AI Inpaint API...');
      console.log('Image:', imageUrl.substring(0, 50) + '...');
      console.log('Mask Length:', maskBase64.length);

      setTimeout(() => {
        // âš ï¸ è¿™é‡Œç›®å‰ç›´æ¥è¿”å›åŸå›¾ï¼Œä»…åšæµç¨‹è·‘é€šæ¼”ç¤º
        // çœŸå®å¼€å‘è¯·æ›¿æ¢ä¸ºï¼š
        // const formData = new FormData();
        // formData.append('image', ...);
        // formData.append('mask', ...);
        // const res = await fetch('/api/inpaint', { ... });

        resolve(imageUrl);
      }, 2000);
    });
  }
};
</file>

<file path="src/components/modules/adjust/AdjustColor.vue">
<template>
    <div class="tool-group">
        <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
            <div class="left">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10" />
                    <path d="M12 2a10 10 0 0 0 0 20Z" />
                </svg>
                <span>è‰²å½©è°ƒèŠ‚</span>
            </div>
            <div class="right-icon">
                <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2">
                    <path d="m9 18 6-6-6-6" />
                </svg>
            </div>
        </div>

        <div v-if="isExpanded" class="tool-content">
            <div class="color-controls">
                <div v-for="item in config" :key="item.key" class="control-row">
                    <div class="label-box">
                        <span>{{ item.label }}</span>
                        <input type="number" v-model.number="values[item.key]" class="ie-input-number"
                            @input="updateFilters">
                    </div>
                    <input type="range" v-model.number="values[item.key]" :min="item.min" :max="item.max" step="1"
                        class="ie-slider" @input="updateFilters">
                </div>
            </div>

            <div class="action-buttons">
                <button class="ie-btn ie-primary full" @click="handleApply">ç¡®å®š</button>
                <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
</template>

<script setup>
import { reactive, inject, onMounted } from 'vue';
import { registerColorModule, applyColorAdjust, commitColorAdjust, cancelColorAdjust } from './useCanvasColor';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const values = reactive({
    blurSharpen: 0,
    saturation: 0,
    brightness: 0,
    contrast: 0,
    temperature: 0,
    hue: 0
});

const config = [
    { label: 'æ¨¡ç³Š / é”åŒ–', key: 'blurSharpen', min: -10, max: 10 },
    { label: 'é¥±å’Œåº¦', key: 'saturation', min: -100, max: 100 },
    { label: 'äº®åº¦', key: 'brightness', min: -10, max: 10 },
    { label: 'å¯¹æ¯”åº¦', key: 'contrast', min: -10, max: 10 },
    { label: 'è‰²æ¸©', key: 'temperature', min: -20, max: 20 },
    { label: 'è‰²è°ƒ', key: 'hue', min: -20, max: 20 },
];

const updateFilters = () => applyColorAdjust(values);
const handleToggle = () => emit('toggle');

const handleApply = () => {
    commitColorAdjust();
    emit('toggle');
};

const handleCancel = () => {
    cancelColorAdjust();
    emit('toggle');
};

onMounted(() => {
    if (canvasAPI?.canvas) {
        registerColorModule(canvasAPI.canvas, canvasAPI.saveHistory);
    }
});
</script>

<style scoped>
.color-controls {
    padding: 8px 0;
}

.control-row {
    margin-bottom: 16px;
}

.label-box {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
    font-size: 13px;
    color: #606266;
}

/* å·²ç§»é™¤å±€éƒ¨çš„ ie-small-input æ ·å¼ */

.ie-slider {
    width: 100%;
    height: 4px;
    background: #e4e7ed;
    border-radius: 2px;
    appearance: none;
    outline: none;
}

.ie-slider::-webkit-slider-thumb {
    appearance: none;
    width: 12px;
    height: 12px;
    background: #fff;
    border: 2px solid var(--ie-primary-color); /* ä¿®æ­£ä¸ºä¸»é¢˜è‰² */
    border-radius: 50%;
    cursor: pointer;
    transition: transform 0.2s;
}

.ie-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
}

.action-buttons {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.full {
    flex: 1;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustColorOverlay.vue">
<template>
    <div class="tool-group">
        <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
            <div class="left">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3-4-3-4-1 2.4-3 4-3 3.5-3 5.5a7 7 0 0 0 7 7Z"/>
                </svg>
                <span>é¢œè‰²å åŠ </span>
            </div>
            <div class="right-icon">
                <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="m9 18 6-6-6-6" />
                </svg>
            </div>
        </div>

        <div v-if="isExpanded" class="tool-content">
            <div class="section-label">é€‰æ‹©é¢œè‰²</div>
            <div class="color-presets">
                <div class="preset-item color-picker-wrapper" :class="{ active: isCustomActive }">
                    <input type="color" v-model="customColor" @input="handleCustomColorInput" class="native-color-picker">
                    <div class="rainbow-gradient"></div>
                </div>
                <div v-for="color in presets" :key="color" class="preset-item" :style="{ background: color }"
                    :class="{ active: selectedColor === color }" @click="selectColor(color)"></div>
                <div class="preset-item clear-item" :class="{ active: selectedColor === null }" @click="selectColor(null)">
                    <div class="slash-line"></div>
                </div>
            </div>

            <div class="intensity-section">
                <div class="label-row">
                    <span>å åŠ å¼ºåº¦</span>
                    <input type="number" v-model.number="intensity" class="ie-input-number" @input="updateOverlay">
                </div>
                <input type="range" v-model.number="intensity" min="0" max="100" class="ie-slider" @input="updateOverlay">
            </div>

            <div class="action-buttons">
                <button class="ie-btn ie-primary full" @click="handleConfirm">ç¡®å®š</button>
                <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
</template>

<script setup>
import { ref, inject, onMounted, computed, watch } from 'vue';
import { 
    registerColorOverlayModule, applyColorOverlay, commitColorOverlay, 
    backupCurrentColorOverlay, cancelColorOverlayChange 
} from './useCanvasColorOverlay';

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

const selectedColor = ref(null);
const customColor = ref('#ff0000');
const intensity = ref(30);
const presets = ['#000000', '#808080', '#ffffff'];

const isCustomActive = computed(() => selectedColor.value !== null && !presets.includes(selectedColor.value));

const selectColor = (color) => {
    selectedColor.value = color;
    updateOverlay();
};

const handleCustomColorInput = (e) => {
    selectedColor.value = e.target.value;
    updateOverlay();
};

const updateOverlay = () => {
    applyColorOverlay(selectedColor.value, intensity.value);
};

const handleConfirm = () => {
    commitColorOverlay();
    emit('toggle');
};

const handleCancel = () => {
    cancelColorOverlayChange();
    emit('toggle');
};

watch(() => props.isExpanded, (expanded) => {
    const canvas = canvasAPI?.canvas?.value;
    const bgImage = canvas?.getObjects().find(o => o.type === 'image');
    
    if (expanded && bgImage) {
        selectedColor.value = bgImage._lastOverlayColor || null;
        intensity.value = bgImage._lastOverlayOpacity ?? 30;
        if (selectedColor.value && !presets.includes(selectedColor.value)) {
            customColor.value = selectedColor.value;
        }
        backupCurrentColorOverlay();
    }
});

onMounted(() => {
    if (canvasAPI?.canvas) {
        registerColorOverlayModule(canvasAPI.canvas, canvasAPI.saveHistory);
    }
});
</script>

<style scoped>
.section-label { font-size: 12px; color: #666; margin-bottom: 8px; }
.color-presets { display: flex; gap: 8px; margin-bottom: 20px; }
.preset-item { width: 36px; height: 20px; border-radius: 4px; border: 1px solid #ddd; cursor: pointer; position: relative; overflow: hidden; }
.preset-item.active { border-color: var(--ie-primary-color); border-width: 2px; }
.rainbow-gradient { width: 100%; height: 100%; background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red); }
.color-picker-wrapper { position: relative; }
.native-color-picker { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
.clear-item { background: #fff; }
.slash-line { position: absolute; top: 50%; left: 0; width: 100%; height: 1px; background: red; transform: rotate(-45deg); }
.intensity-section { margin-bottom: 16px; }
.label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 13px; color: #606266; }
/* å·²ç§»é™¤å±€éƒ¨çš„ input æ ·å¼ */
.action-buttons { display: flex; gap: 10px; margin-top: 16px; }
.full { flex: 1; }
</style>
</file>

<file path="src/components/modules/adjust/useCanvasInpaint.js">
import { ref, unref, watch } from 'vue';
import { fabric } from 'fabric';
import { aiApi } from '@/api/ai';
import { toast } from '@/utils/toast';
import { useEditorState } from '@/composables/useEditorState';

// === æ¨¡å—çº§å•ä¾‹çŠ¶æ€ ===
let canvasRef = null;
let saveHistoryFn = null;
let initialSnapshot = null; 
let autoInpaintTimer = null;
let isDragging = false;
let startPoint = null;
let activeRect = null;

// å“åº”å¼çŠ¶æ€
export const brushSize = ref(30);
export const drawMode = ref('brush'); 

// æ³¨å†Œæ¨¡å—
export const registerInpaintModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;
};

// === ğŸ”’ ç”»å¸ƒé”å®šç³»ç»Ÿ ===
const setObjectsLocked = (locked) => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    const objects = canvas.getObjects();
    objects.forEach(obj => {
        if (obj.isMaskObject || obj.type === 'path') return; // è·³è¿‡é®ç½©å±‚

        if (locked) {
            obj._prevSelectable = obj.selectable;
            obj._prevEvented = obj.evented;
            obj.selectable = false;
            obj.evented = false; // è®©äº‹ä»¶ç©¿é€åº•å›¾
            obj.lockMovementX = true;
            obj.lockMovementY = true;
        } else {
            obj.selectable = obj._prevSelectable ?? true;
            obj.evented = obj._prevEvented ?? true;
            obj.lockMovementX = false;
            obj.lockMovementY = false;
        }
    });

    if (locked) {
        canvas.discardActiveObject();
        canvas.selection = false;
    } else {
        canvas.selection = true;
    }
    canvas.requestRenderAll();
};

// === ğŸ›  æ ¸å¿ƒä¿®å¤ï¼šç¦»å±ç”Ÿæˆé®ç½© (è§£å†³é—ªå±é—®é¢˜) ===
const getInpaintMaskOffscreen = async () => {
    const canvas = unref(canvasRef);
    if (!canvas) return null;

    // 1. ç­›é€‰å‡ºå±å¹•ä¸Šçš„çº¢çº¿æˆ–çº¢æ¡†
    const maskObjects = canvas.getObjects().filter(o => o.isMaskObject || o.type === 'path');
    if (maskObjects.length === 0) return null;

    // 2. åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ã€ä¸å¯è§çš„ç”»å¸ƒ (StaticCanvas)
    // å¤§å°ä¸ä¸»ç”»å¸ƒä¸€è‡´ï¼ŒèƒŒæ™¯è®¾ä¸ºé»‘è‰²
    const tempCanvas = new fabric.StaticCanvas(null, {
        width: canvas.width,
        height: canvas.height,
        backgroundColor: 'black' 
    });

    // 3. å…‹éš†é®ç½©å¯¹è±¡å¹¶â€œæ´—ç™½â€
    const clonePromises = maskObjects.map(obj => {
        return new Promise(resolve => {
            obj.clone((cloned) => {
                // å¼ºåˆ¶è®¾ä¸ºçº¯ç™½ï¼Œä¸é€æ˜
                cloned.set({
                    left: obj.left,
                    top: obj.top,
                    fill: 'white', 
                    stroke: 'white',
                    opacity: 1,
                    visible: true,
                    evented: false
                });

                // é’ˆå¯¹ç”»ç¬”(Path)å’Œæ¡†é€‰(Rect)åšå¾®è°ƒï¼Œç¡®ä¿æ˜¯å®å¿ƒç™½
                if (cloned.type === 'path') {
                    cloned.set({ fill: null, stroke: 'white' });
                } else if (cloned.type === 'rect') {
                    cloned.set({ fill: 'white', stroke: 'transparent' });
                }

                resolve(cloned);
            });
        });
    });

    // 4. å°†å…‹éš†ä½“æ·»åŠ åˆ°ä¸´æ—¶ç”»å¸ƒ
    const clones = await Promise.all(clonePromises);
    clones.forEach(c => tempCanvas.add(c));
    
    // 5. æ¸²æŸ“å¹¶å¯¼å‡º (è¿™ä¸€æ­¥å‘ç”Ÿåœ¨å†…å­˜ä¸­ï¼Œç”¨æˆ·çœ‹ä¸è§)
    tempCanvas.renderAll();
    const dataUrl = tempCanvas.toDataURL({ 
        format: 'png',
        multiplier: 1 
    });
    
    // 6. é”€æ¯ä¸´æ—¶ç”»å¸ƒé‡Šæ”¾å†…å­˜
    tempCanvas.dispose();
    
    return dataUrl;
};

// === è¿›å…¥/é€€å‡ºæ¨¡å— ===
export const enterInpaintMode = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    initialSnapshot = JSON.stringify(canvas.toJSON(['id', 'selectable', 'name']));
    setObjectsLocked(true); // é”å®šåº•å›¾
    drawMode.value = 'brush';
    enableBrush();
};

export const exitInpaintMode = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    if (autoInpaintTimer) clearTimeout(autoInpaintTimer);
    unbindEvents();
    
    canvas.isDrawingMode = false;
    setObjectsLocked(false); // è§£é”åº•å›¾
    clearMaskObjects();
    canvas.defaultCursor = 'default';
};

// === æ¨¡å¼åˆ‡æ¢ ===
const enableBrush = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    unbindEvents();
    canvas.isDrawingMode = true;
    
    const brush = new fabric.PencilBrush(canvas);
    brush.color = 'rgba(255, 0, 0, 0.5)';
    brush.width = brushSize.value;
    canvas.freeDrawingBrush = brush;
    
    canvas.on('path:created', onPathCreated);
};

const enableRect = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    canvas.isDrawingMode = false;
    unbindEvents();
    setObjectsLocked(true); 
    canvas.defaultCursor = 'crosshair';

    canvas.on('mouse:down', onRectDown);
    canvas.on('mouse:move', onRectMove);
    canvas.on('mouse:up', onRectUp);
};

// === äº‹ä»¶å¤„ç† ===
const onPathCreated = (opt) => {
    const path = opt.path;
    if (path) {
        path.excludeFromHistory = true; 
        path.isMaskObject = true;
    }
    // 1ç§’é˜²æŠ–
    if (autoInpaintTimer) clearTimeout(autoInpaintTimer);
    autoInpaintTimer = setTimeout(() => executeInpaint(), 1000);
};

const onRectDown = (opt) => {
    const canvas = unref(canvasRef);
    if (opt.target && !opt.target.isMaskObject) return;

    const pointer = canvas.getPointer(opt.e);
    isDragging = true;
    startPoint = { x: pointer.x, y: pointer.y };

    activeRect = new fabric.Rect({
        left: startPoint.x, top: startPoint.y,
        width: 0, height: 0,
        fill: 'rgba(255, 0, 0, 0.5)',
        stroke: 'transparent',
        selectable: false, evented: false,
        isMaskObject: true,
        excludeFromHistory: true
    });
    canvas.add(activeRect);
};

const onRectMove = (opt) => {
    if (!isDragging || !activeRect) return;
    const canvas = unref(canvasRef);
    const pointer = canvas.getPointer(opt.e);
    
    let w = Math.abs(pointer.x - startPoint.x);
    let h = Math.abs(pointer.y - startPoint.y);
    
    if (pointer.x < startPoint.x) activeRect.set({ left: pointer.x });
    if (pointer.y < startPoint.y) activeRect.set({ top: pointer.y });

    activeRect.set({ width: w, height: h });
    canvas.requestRenderAll();
};

const onRectUp = () => {
    isDragging = false;
    if (activeRect && (activeRect.width < 5 || activeRect.height < 5)) {
        unref(canvasRef).remove(activeRect);
    } else {
        executeInpaint(); // æ¾æ‰‹å³è§¦å‘
    }
    activeRect = null;
};

const unbindEvents = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;
    canvas.off('path:created', onPathCreated);
    canvas.off('mouse:down', onRectDown);
    canvas.off('mouse:move', onRectMove);
    canvas.off('mouse:up', onRectUp);
};

// === ğŸš€ æ ¸å¿ƒæ‰§è¡Œé€»è¾‘ ===
const executeInpaint = async () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;

    // 1. æ£€æŸ¥æ˜¯å¦æœ‰é®ç½©å†…å®¹
    const hasContent = canvas.getObjects().some(o => o.isMaskObject || o.type === 'path');
    if (!hasContent) return;

    const { setLoading } = useEditorState(); // è·å–å…¨å±€ Loading æ§åˆ¶

    try {
        setLoading(true, 'AI æ­£åœ¨æ¶ˆé™¤...'); // å¼€å¯ Loadingï¼Œé®ä½ç”»å¸ƒ
        
        // 2. å¯»æ‰¾åº•å›¾
        const activeObj = canvas.getObjects().find(o => o.type === 'image' && !o.isMaskObject);
        if (!activeObj) throw new Error('æœªæ‰¾åˆ°åº•å›¾');

        // 3. ã€æ–°é€»è¾‘ã€‘ä½¿ç”¨ç¦»å±æ¸²æŸ“è·å– Maskï¼Œä¸å†å¯¼è‡´ä¸»ç”»å¸ƒé—ªé»‘
        const maskBase64 = await getInpaintMaskOffscreen();
        if (!maskBase64) return;

        // 4. è°ƒç”¨ AI æ¥å£
        const resultUrl = await aiApi.inpaint(activeObj.getSrc(), maskBase64);
        
        if (resultUrl) {
            // 5. æˆåŠŸåæ›¿æ¢å›¾ç‰‡
            activeObj.setSrc(resultUrl, () => {
                clearMaskObjects(); // æ¸…é™¤çº¢çº¿
                setObjectsLocked(true); // é‡æ–°é”å®šæ–°å›¾ç‰‡
                
                if (saveHistoryFn) saveHistoryFn();
                toast.success('æ¶ˆé™¤å®Œæˆ');
                canvas.requestRenderAll();
                
                // å›¾ç‰‡åŠ è½½å®Œå†å…³é—­ Loadingï¼Œä½“éªŒæ›´å¹³æ»‘
                setLoading(false);
            }, { crossOrigin: 'anonymous' });
        } else {
            setLoading(false);
        }
    } catch (error) {
        console.error('Inpaint error:', error);
        toast.error('æ¶ˆé™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
        clearMaskObjects();
        setLoading(false);
    }
};

const clearMaskObjects = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;
    const masks = canvas.getObjects().filter(o => o.isMaskObject || o.type === 'path');
    canvas.remove(...masks);
    canvas.requestRenderAll();
};

// === æ¢å¤åŸå›¾ ===
export const handleRestoreOriginal = () => {
    const canvas = unref(canvasRef);
    if (!canvas || !initialSnapshot) return;

    canvas.loadFromJSON(initialSnapshot, () => {
        setObjectsLocked(true);
        if (drawMode.value === 'brush') enableBrush();
        else enableRect();
        
        if (saveHistoryFn) saveHistoryFn();
        toast.success('å·²æ¢å¤è‡³åˆå§‹çŠ¶æ€');
    });
};

watch(drawMode, (newMode) => {
    if (newMode === 'brush') enableBrush();
    else enableRect();
});

watch(brushSize, (val) => {
    const canvas = unref(canvasRef);
    if (canvas && canvas.freeDrawingBrush) {
        canvas.freeDrawingBrush.width = val;
    }
});
</file>

<file path="src/components/common/Modal.vue">
<template>
    <Teleport to="body">
        <Transition name="fade">
            <div v-if="modelValue" class="modal-mask" @click.self="$emit('cancel')">
                <div class="modal-container">
                    <button class="modal-close" title="å…³é—­" @click="$emit('cancel')">Ã—</button>

                    <div class="modal-header">
                        <h3>{{ title }}</h3>
                    </div>
                    <div class="modal-body">
                        <slot>{{ content }}</slot>
                    </div>
                    <div class="modal-footer">
                        <button class="ie-btn btn-secondary" @click="$emit('discard')">{{ cancelText }}</button>
                        <button class="ie-btn btn-primary" @click="$emit('confirm')">{{ confirmText }}</button>
                    </div>
                </div>
            </div>
        </Transition>
    </Teleport>
</template>

<script setup>
defineProps({
    modelValue: Boolean,
    title: { type: String, default: 'ä¿å­˜?' },
    content: { type: String, default: 'æ³¨æ„: ä½¿ç”¨æ‹¼å›¾åä¼šè¦†ç›–åŸå›¾æ‰€æœ‰å†…å®¹' },
    cancelText: { type: String, default: 'å–æ¶ˆ' },
    confirmText: { type: String, default: 'ç¡®è®¤' },
});
defineEmits(['update:modelValue', 'confirm', 'discard', 'cancel']);
</script>

<style scoped>
.modal-mask {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.modal-container {
    position: relative;
    background: white;
    border-radius: 12px;
    width: 320px;
    padding: 24px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

.modal-header h3 {
    margin: 0 0 16px;
    font-size: 18px;
    color: #333;
}

.modal-close {
    position: absolute;
    top: 4px;
    right: 4px;
    background: none;
    border: none;
    font-size: 32px;
    color: #909399;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    line-height: 1;
}

.modal-close:hover {
    color: #606266;
}

.modal-body {
    font-size: 14px;
    color: #666;
    margin-bottom: 24px;
    line-height: 1.5;
}

.modal-footer {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
}

.ie-btn {
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    border: none;
    font-size: 14px;
}

.btn-primary {
    background: var(--ie-primary-color);
    color: white;
}

.btn-secondary {
    background: #f4f4f5;
    color: #606266;
}

.fade-enter-active,
.fade-leave-active {
    transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
    opacity: 0;
}
</style>
</file>

<file path="src/components/layout/LeftSidebar.vue">
<template>
  <div class="left-sidebar">
    <div 
      v-for="item in menuItems" 
      :key="item.id" 
      class="menu-item" 
      :class="{ 
        active: state.activeTool === item.id,
        'auto-activated': state.activeTool === item.id && state.navigationSource === 'canvas'
      }"
      @click="handleToolClick(item.id)"
    >
      <svg class="menu-icon" viewBox="0 0 1024 1024" width="20" height="20">
        <path :d="item.iconPath" fill="currentColor" />
      </svg>
      <span class="label">{{ item.label }}</span>
    </div>
  </div>
</template>

<script setup>
import { useEditorState } from '../../composables/useEditorState';

// 1. æ›¿ä»£ Pinia
const { state, setActiveTool } = useEditorState();

// 2. ç‚¹å‡»å¤„ç†ï¼šæ‰‹åŠ¨ç‚¹å‡»æ—¶ï¼Œå¼ºåˆ¶è§£é™¤ Disabled çŠ¶æ€
// ç‚¹å‡»å¤„ç†ï¼šæ ‡è®°æ¥æºä¸º 'manual'
const handleToolClick = (id) => {
  setActiveTool(id, 'manual');
};

// 3. å®šä¹‰èœå•é…ç½® (ä¿æŒåŸæ ·)
const menuItems = [
  {
    id: 'adjust',
    label: 'è°ƒæ•´',
    iconPath: 'M192 128v768h128V672h192v224h128V672h192V544H512V128H192zm128 128h192v160H320V256z'
  },
  {
    id: 'draw',
    label: 'ç»˜åˆ¶',
    iconPath: 'M853.504 192.064l-235.008 235.008-60.352-60.352 235.008-235.008a64 64 0 0 1 90.496 0l-30.144 30.144 30.144 30.208z m-467.2 491.52l60.352-60.352L249.408 425.984l-60.352 60.352 197.248 197.248zM189.056 365.632l60.352-60.352 384.896 384.896-60.352 60.352L189.056 365.632zM128 896a64 64 0 0 1-64-64c0-68.992 48.128-196.608 107.52-256l192 192C304.128 827.392 192 896 128 896z'
  },
  {
    id: 'text',
    label: 'æ–‡æœ¬',
    iconPath: 'M832 64H192a64 64 0 0 0-64 64v768a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V128a64 64 0 0 0-64-64zM256 256h512v64H256v-64zm512 448H256v-64h512v64zm0-192H256v-64h512v64z'
  },
  {
    id: 'border',
    label: 'è¾¹æ¡†',
    iconPath: 'M160 160v192h-64V96h256v64H160z m0 704h192v64H96V672h64v192z m704-192v192H672v64h256V672h-64z m0-288V160H672V96h256v288h-64z'
  },
  {
    id: 'material',
    label: 'ç´ æ',
    iconPath: 'M448 128H128v320h320V128zm-64 256H192V192h192v192z m448-256H576v320h256V128zm-64 256H640V192h192v192z M448 576H128v320h320V576zm-64 256H192V640h192v192z m448-256H576v320h256V576zm-64 256H640V640h192v192z'
  },
  {
    id: 'watermark',
    label: 'æ°´å°',
    iconPath: 'M832 320H608V128h-64a96 96 0 0 0-96-96h-64a96 96 0 0 0-96 96h-64v192H192a64 64 0 0 0-64 64v512h768V384a64 64 0 0 0-64-64z m-320-96h64v96h-64v-96z m0-128h64a32 32 0 0 1 32 32v32h-128V128a32 32 0 0 1 32-32zM256 704a64 64 0 1 1 0-128 64 64 0 0 1 0 128zm256 128a64 64 0 1 1 0-128 64 64 0 0 1 0 128zm256-128a64 64 0 1 1 0-128 64 64 0 0 1 0 128z'
  },
  {
    id: 'puzzle',
    label: 'æ‹¼å›¾',
    iconPath: 'M704 576a128 128 0 0 1-128 128h-64v256h-64V704h-64a128 128 0 1 1 0-256h64V192h64v256h64a128 128 0 0 1 128 128z m-256-64h64V256h-64v256zM320 576a64 64 0 1 0 64-64h-64v64zm384 0a64 64 0 1 0-64-64h64v64z'
  },
  {
    id: 'ai',
    label: 'AI',
    iconPath: 'M832 192H192v640h640V192z m64-64v768H128V128h768z M320 320h128v128H320V320z m0 256h128v128H320V576z m256-256h128v128H576V320z m0 256h128v128H576V576z'
  },
];
</script>

<style scoped>
.left-sidebar {
  width: 72px;
  background-color: #fff;
  border-right: 1px solid #e4e7ed;
  display: flex;
  flex-direction: column;
  padding-top: 12px;
  overflow-y: auto;
  transition: opacity 0.3s ease;
}


.left-sidebar::-webkit-scrollbar {
  display: none;
}

.menu-item {
  height: 68px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #606266;
  gap: 6px;
  transition: all 0.2s;
  flex-shrink: 0;
}

.menu-item:hover {
  color: var(--ie-primary-color);
  background-color: #f5f7fa;
}

.menu-item.active {
  color: var(--ie-primary-color);
  font-weight: 500;
  background-color: #ecf5ff;
  position: relative;
}

.menu-item.active::before {
  content: '';
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 3px;
  height: 24px;
  background-color: var(--ie-primary-color);
  border-radius: 0 2px 2px 0;
}

.label {
  font-size: 12px;
  line-height: 1;
}

.menu-icon {
  fill: currentColor;
  display: block;
}

/* è¿™æ˜¯ä¸€ä¸ªå¯é€‰çš„å¢å¼ºï¼š */
/* å¦‚æœæ˜¯è‡ªåŠ¨è·³è½¬çš„ï¼Œæˆ‘ä»¬å¯ä»¥è®©é«˜äº®æ¡æœ‰ä¸ªæ·¡å…¥æ•ˆæœï¼Œè€Œä¸æ˜¯ç¬é—´åˆ‡æ¢ */
.menu-item.active.auto-activated::before {
  transition: all 0.3s ease;
}

.left-sidebar.is-disabled {
    /* ä½ çš„æ®‹å½±æ ·å¼ */
    opacity: 0.5;
    filter: grayscale(0.8);
    pointer-events: auto; /* å…³é”®ï¼šå…è®¸ç‚¹å‡»ä»¥é‡æ–°æ¿€æ´» */
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustRuler.vue">
<template>
  <div class="tool-group">
    <div
      class="tool-item"
      :class="{ 'is-expanded': isExpanded }"
      @click="$emit('toggle')"
    >
      <div class="left">
        <svg
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <path
            d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.4 2.4 0 0 1 0-3.4l2.6-2.6a2.4 2.4 0 0 1 3.4 0l12.6 12.6z"
          ></path>
          <path d="m5 6 1.7 1.7"></path>
          <path d="m17 18 1.7 1.7"></path>
          <path d="m11 12 1.7 1.7"></path>
        </svg>
        <span>æµ‹é‡æ ‡å°º</span>
      </div>
      <div class="right-icon">
        <svg
          class="arrow"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">
      <div class="control-group">
        <div class="section-title">
          ç«¯ç‚¹æ ·å¼
          <span
            v-if="isDrawing"
            style="
              color: var(--ie-primary-color);
              float: right;
              font-weight: normal;
              animation: blink 1.5s infinite;
            "
          >
            ç»˜åˆ¶ä¸­...
          </span>
        </div>
        <div class="style-grid">
          <div
            v-for="style in CAP_STYLES"
            :key="style.id"
            class="style-item"
            :class="{ active: isStyleActive(style.id) }"
            @click="setCapStyle(style.id)"
            :title="style.label"
          >
            <svg width="40" height="20" viewBox="0 0 60 20">
              <line
                x1="10"
                y1="10"
                x2="50"
                y2="10"
                stroke="currentColor"
                stroke-width="2"
              />
              <g v-if="style.id === 'line'">
                <line
                  x1="10"
                  y1="5"
                  x2="10"
                  y2="15"
                  stroke="currentColor"
                  stroke-width="2"
                />
                <line
                  x1="50"
                  y1="5"
                  x2="50"
                  y2="15"
                  stroke="currentColor"
                  stroke-width="2"
                />
              </g>
              <g v-if="style.id === 'arrow'">
                <path d="M10 10 L15 7 V13 Z" fill="currentColor" />
                <path d="M50 10 L45 7 V13 Z" fill="currentColor" />
              </g>
              <g v-if="style.id === 'arrow_in'">
                <path d="M5 7 L10 10 L5 13 Z" fill="currentColor" />
                <path d="M55 7 L50 10 L55 13 Z" fill="currentColor" />
              </g>
              <g v-if="style.id === 'dot'">
                <circle cx="10" cy="10" r="3" fill="currentColor" />
                <circle cx="50" cy="10" r="3" fill="currentColor" />
              </g>
            </svg>
          </div>
        </div>
      </div>

      <div class="control-group">
        <div class="section-title">çº¿èº«ç±»å‹</div>
        <div class="custom-select" :class="{ open: isDashSelectOpen }">
          <div
            class="selected-value"
            @click="isDashSelectOpen = !isDashSelectOpen"
          >
            <svg
              width="100%"
              height="10"
              viewBox="0 0 160 10"
              preserveAspectRatio="none"
            >
              <line
                x1="0"
                y1="5"
                x2="160"
                y2="5"
                stroke="currentColor"
                stroke-width="2"
                :stroke-dasharray="currentDashStr"
                :stroke-linecap="rulerConfig.strokeLineCap || 'butt'"
              />
            </svg>
            <svg
              class="dropdown-arrow"
              width="12"
              height="12"
              viewBox="0 0 24 24"
            >
              <path d="M7 10l5 5 5-5z" fill="currentColor" />
            </svg>
          </div>

          <div v-show="isDashSelectOpen" class="options-list">
            <div
              v-for="(opt, idx) in DASH_OPTIONS"
              :key="idx"
              class="option-item"
              @click="setDashPattern(opt)"
            >
              <div class="opt-label">{{ opt.label }}</div>
              <svg
                width="80"
                height="10"
                viewBox="0 0 80 10"
                preserveAspectRatio="none"
              >
                <line
                  x1="0"
                  y1="5"
                  x2="80"
                  y2="5"
                  stroke="#606266"
                  stroke-width="2"
                  :stroke-dasharray="opt.value.join(',')"
                  :stroke-linecap="opt.strokeLineCap || 'butt'"
                />
              </svg>
            </div>
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="control-group">
        <div class="label-row">
          <span>æ ‡æ³¨æ•°å€¼</span>
        </div>
        <div class="input-group">
          <input
            type="number"
            v-model.number="rulerConfig.value"
            class="ie-input-number"
            style="flex: 1; width: auto"
            @input="updateActiveRuler"
          />
          <select
            v-model="rulerConfig.unit"
            class="ie-select"
            @change="updateActiveRuler"
          >
            <option value="px">px</option>
            <option value="cm">cm</option>
            <option value="mm">mm</option>
            <option value="m">m</option>
            <option value="in">inch</option>
            <option value="ft">foot</option>
          </select>
        </div>
      </div>

      <div class="control-group">
        <div class="label-row">
          <span>çº¿æ¡é¢œè‰²</span>
          <input
            type="color"
            v-model="rulerConfig.color"
            @input="updateActiveRuler"
          />
        </div>

        <div class="label-row">
          <span>é€æ˜åº¦</span>
          <span class="val">{{ rulerConfig.opacity }}%</span>
        </div>
        <input
          type="range"
          v-model.number="rulerConfig.opacity"
          min="10"
          max="100"
          class="ie-slider"
          @input="updateActiveRuler"
        />
      </div>

      <div class="control-group">
        <div class="label-row">
          <span>çº¿æ¡ç²—ç»†</span>
          <span class="val">{{ rulerConfig.strokeWidth }}px</span>
        </div>
        <input
          type="range"
          v-model.number="rulerConfig.strokeWidth"
          min="1"
          max="10"
          class="ie-slider"
          @input="updateActiveRuler"
        />
      </div>

      <div class="control-group">
        <div class="label-row">
          <span>å­—ä½“å¤§å°</span>
          <input
            type="number"
            v-model.number="rulerConfig.fontSize"
            class="ie-input-number"
            @input="updateActiveRuler"
          />
        </div>
        <div class="label-row" style="margin-top: 8px">
          <span>æ–‡å­—èƒŒæ™¯</span>
          <input
            type="checkbox"
            v-model="rulerConfig.showBg"
            @change="updateActiveRuler"
          />
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import {
  defineProps,
  defineEmits,
  inject,
  onMounted,
  onUnmounted,
  ref,
  computed,
  watch,
} from "vue";
import {
  registerRulerModule,
  rulerConfig,
  isDrawing,
  // âœ¨ ä¿®å¤ç‚¹ï¼šæ›¿æ¢ä¸ºæ–°çš„æ¨¡å¼æ§åˆ¶å‡½æ•°
  startRulerMode, 
  stopRulerMode,
  updateActiveRuler,
  syncConfigFromActiveSelection,
  CAP_STYLES,
  DASH_OPTIONS,
} from "./useCanvasRuler";
import { useCanvasLock } from "@/composables/useCanvasLock";

const props = defineProps({ isExpanded: Boolean });
const emit = defineEmits(["toggle"]);
const canvasAPI = inject("canvasAPI");

const isDashSelectOpen = ref(false);
const { setBackgroundLock } = useCanvasLock();

// === ç”Ÿå‘½å‘¨æœŸä¸çŠ¶æ€ç®¡ç† ===
watch(
  () => props.isExpanded,
  (val) => {
    const canvas = canvasAPI.canvas.value;
    if (!canvas) return;

    // âœ¨ ç‰©ç†é”è”åŠ¨ï¼šè¿›å…¥æ ‡å°ºæ¨¡å—æ—¶ï¼Œè®¾ç½®è±å…æ ‡å°ºå¹¶è¿›å…¥æ ‡å°ºå…‰æ ‡æ¨¡å¼
    setBackgroundLock(canvas, val, { 
        excludeRulers: true, 
        isRulerMode: val 
    });

    if (val) {
      // åŒæ­¥å½“å‰é€‰ä¸­çš„æ ‡å°ºé…ç½®ï¼ˆå¦‚æœæœ‰ï¼‰
      syncConfigFromActiveSelection();
      // âœ¨ å¼€å¯â€œæ™ºèƒ½æ„ŸçŸ¥â€æ ‡å°ºæ¨¡å¼
      startRulerMode(canvasAPI.canvas, canvasAPI.saveHistory);
    } else {
      // é€€å‡ºæ ‡å°ºæ¨¡å¼ï¼Œç§»é™¤ç›‘å¬
      stopRulerMode();
    }
  }
);

onMounted(() => {
  if (canvasAPI && canvasAPI.canvas) {
    // æ³¨å†Œæ¨¡å—å¼•ç”¨
    registerRulerModule(canvasAPI.canvas, canvasAPI.saveHistory);

    if (props.isExpanded) {
      syncConfigFromActiveSelection();
      startRulerMode(canvasAPI.canvas, canvasAPI.saveHistory);
    }
  }
});

onUnmounted(() => {
  const canvas = canvasAPI?.canvas?.value;
  if (canvas) {
    setBackgroundLock(canvas, false);
    stopRulerMode();
  }
});

// === è§†è§‰é«˜äº® ===
const isStyleActive = (styleId) => {
  const isEditing = canvasAPI.canvas.value?.getActiveObject()?.isRuler;
  if (isEditing) {
    return rulerConfig.value.capStyle === styleId;
  }
  // åœ¨æµ‹é‡æ¨¡å¼ä¸‹ï¼Œå³ä½¿æ²¡é€‰ä¸­ä¹Ÿé«˜äº®å½“å‰é…ç½®çš„æ ·å¼
  return props.isExpanded && rulerConfig.value.capStyle === styleId;
};

const setCapStyle = (styleId) => {
  rulerConfig.value.capStyle = styleId;
  const canvas = canvasAPI.canvas.value;
  const activeObj = canvas?.getActiveObject();

  if (activeObj && activeObj.isRuler) {
    updateActiveRuler();
  }
  // æ³¨æ„ï¼šä¸å†éœ€è¦æ‰‹åŠ¨è°ƒç”¨ startDrawModeï¼ŒstartRulerMode å·²åœ¨åå°ç›‘å¬
};

const setDashPattern = (opt) => {
  rulerConfig.value.dashArray = opt.value;
  rulerConfig.value.strokeLineCap = opt.strokeLineCap || "butt";
  isDashSelectOpen.value = false;
  const canvas = canvasAPI.canvas.value;
  const activeObj = canvas?.getActiveObject();
  if (activeObj && activeObj.isRuler) {
    updateActiveRuler();
  }
};

const currentDashStr = computed(() => {
  return rulerConfig.value.dashArray
    ? rulerConfig.value.dashArray.join(",")
    : "";
});
</script>

<style scoped>
@keyframes blink {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

.tool-content {
  padding: 16px;
}
.section-title {
  font-size: 12px;
  color: #909399;
  margin-bottom: 8px;
  font-weight: 500;
}
.style-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin-bottom: 16px;
}
.style-item {
  height: 32px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #606266;
  background: #fff;
  transition: all 0.2s;
}
.style-item:hover {
  border-color: #c0c4cc;
}
.style-item.active {
  border-color: var(--ie-primary-color);
  color: var(--ie-primary-color);
  background-color: #ecf5ff;
}

.custom-select {
  position: relative;
  width: 100%;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
}
.selected-value {
  height: 32px;
  padding: 0 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  color: #606266;
}
.options-list {
  position: absolute;
  top: 100%;
  left: -1px;
  right: -1px;
  background: #fff;
  border: 1px solid #dcdfe6;
  border-radius: 0 0 4px 4px;
  z-index: 10;
  max-height: 200px;
  overflow-y: auto;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}
.option-item {
  height: 32px;
  padding: 0 12px;
  display: flex;
  align-items: center;
}
.option-item:hover {
  background-color: #f5f7fa;
}
.opt-label {
  font-size: 12px;
  color: #606266;
  margin-right: 12px;
  min-width: 40px;
}

.divider {
  height: 1px;
  background: #ebeef5;
  margin: 16px 0;
}
.control-group {
  margin-bottom: 16px;
}
.label-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12px;
  color: #606266;
  margin-bottom: 8px;
}
.input-group {
  display: flex;
  gap: 8px;
}
.ie-select {
  height: 28px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  font-size: 12px;
  color: #606266;
  padding: 0 4px;
  outline: none;
  background: white;
}
.ie-input-number {
    height: 28px;
    border: 1px solid #dcdfe6;
    border-radius: 4px;
    padding: 0 8px;
    outline: none;
    width: 60px;
}
.val {
  font-family: monospace;
}
.ie-slider {
  width: 100%;
}
</style>
</file>

<file path="src/components/modules/adjust/useCanvasWhite.js">
// [File: src/components/modules/adjust/useCanvasWhite.js]

import { ref, unref, shallowRef, toRaw } from "vue";
import { fabric } from "fabric";

let canvasRef = null;
let saveHistoryFn = null;
let zoomToRectFn = null;
// === é¢„è§ˆç›¸å…³çŠ¶æ€ ===
const previewBgRect = shallowRef(null);
let originalSelectable = true;
let originalEvented = true;
let originalTransform = null;


export const registerWhiteModule = (canvas, saveHistory, zoomToRect) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
  zoomToRectFn = zoomToRect;
};


// æ–°å¢ï¼šæ‰‹åŠ¨è§¦å‘è§†è§’å¯¹é½çš„æ–¹æ³•
export const zoomToPreview = () => {
  const canvas = unref(canvasRef);
  // å¦‚æœ zoomToRectFn ä¸º nullï¼Œè¿™é‡Œå°±ä¼šç›´æ¥ returnï¼Œå¯¼è‡´æ²¡ååº”
  if (!canvas || !previewBgRect.value || !zoomToRectFn || !originalTransform) return;

  const rect = previewBgRect.value;

  // è®¡ç®—è¡¥ç™½æ¡†åœ¨ç”»å¸ƒä¸Šçš„é€»è¾‘çŸ©å½¢èŒƒå›´
  const logicRect = {
    left: rect.left - (rect.width * rect.scaleX) / 2,
    top: rect.top - (rect.height * rect.scaleY) / 2,
    width: rect.width * rect.scaleX,
    height: rect.height * rect.scaleY
  };

  // è°ƒç”¨ç›¸æœºç¼©æ”¾æ–¹æ³•
  zoomToRectFn(logicRect);
};





export const getCurrentSize = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return { width: 0, height: 0 };
  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (bgImage) {
    return {
      width: Math.round(bgImage.getScaledWidth()),
      height: Math.round(bgImage.getScaledHeight())
    };
  }
  return { width: canvas.width, height: canvas.height };
};

const restoreImageState = (bgImage) => {
  if (originalTransform && bgImage) {
    bgImage.set({
      scaleX: originalTransform.scaleX,
      scaleY: originalTransform.scaleY,
      left: originalTransform.left,
      top: originalTransform.top,
      width: originalTransform.width,
      height: originalTransform.height,
      angle: originalTransform.angle,
      originX: originalTransform.originX,
      originY: originalTransform.originY
    });
    bgImage.setCoords();
  }
};

export const startPreview = (targetW, targetH, bgColor = '#ffffff') => {
  const canvas = unref(canvasRef);
  if (!canvas || !targetW || !targetH) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  if (!originalTransform) {
    originalSelectable = bgImage.selectable;
    originalEvented = bgImage.evented;
    originalTransform = {
      scaleX: bgImage.scaleX,
      scaleY: bgImage.scaleY,
      left: bgImage.left,
      top: bgImage.top,
      width: bgImage.width,
      height: bgImage.height,
      angle: bgImage.angle,
      originX: bgImage.originX,
      originY: bgImage.originY
    };
  }

  if (previewBgRect.value) {
    canvas.remove(toRaw(previewBgRect.value));
    previewBgRect.value = null;
  }

  const imgW = originalTransform.width * originalTransform.scaleX;
  const imgH = originalTransform.height * originalTransform.scaleY;
  const scaleX = targetW / imgW;
  const scaleY = targetH / imgH;
  const fitScale = Math.min(scaleX, scaleY);

  // const canvasW = canvas.width;
  // const canvasH = canvas.height;
  // const center = canvas.getCenter();
  // const VIEW_FACTOR = 0.85;

  // const viewScale = Math.min(
  //   (canvasW * VIEW_FACTOR) / targetW,
  //   (canvasH * VIEW_FACTOR) / targetH
  // );
  const viewScale = 1;
  const center = canvas.getCenter();
  const rect = new fabric.Rect({
    width: targetW,
    height: targetH,
    left: center.left,
    top: center.top,
    originX: 'center',
    originY: 'center',
    fill: bgColor === 'transparent' ? 'transparent' : bgColor,
    stroke: '#409eff',
    strokeWidth: 2 / viewScale,
    selectable: false,
    evented: false,
    excludeFromExport: true,
    scaleX: viewScale,
    scaleY: viewScale
  });

  previewBgRect.value = rect;
  canvas.add(rect);
  canvas.sendToBack(rect);

  const finalScaleX = originalTransform.scaleX * fitScale * viewScale;
  const finalScaleY = originalTransform.scaleY * fitScale * viewScale;

  bgImage.set({
    scaleX: finalScaleX,
    scaleY: finalScaleY,
    left: center.left,
    top: center.top,
    originX: 'center',
    originY: 'center',
    selectable: false,
    evented: false
  });
  bgImage.setCoords();
  canvas.requestRenderAll();
};

export const updatePreview = (targetW, targetH, bgColor) => {
  startPreview(targetW, targetH, bgColor);
};

export const stopPreview = () => {
  const canvas = unref(canvasRef);
  if (canvas) {
    if (previewBgRect.value) {
      canvas.remove(toRaw(previewBgRect.value));
      previewBgRect.value = null;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (bgImage) {
      restoreImageState(bgImage);
      bgImage.selectable = originalSelectable;
      bgImage.evented = originalEvented;
    }
    canvas.discardActiveObject();
    originalTransform = null;
    canvas.requestRenderAll();
  }
};


// æ¯å¸¦é‡åˆ¶ (Source Remastering) åŸæ¸…æ™°åº¦
export const applyWhitePadding = (width, height, bgColor) => {
  return new Promise((resolve, reject) => {
    const canvas = unref(canvasRef);
    if (!canvas || !previewBgRect.value) {
      resolve();
      return;
    }

    const targetW = Math.round(width);
    const targetH = Math.round(height);
    if (targetW <= 0 || targetH <= 0) {
      resolve();
      return;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (!bgImage) {
      resolve();
      return;
    }

    // 1. è·å–åŸå›¾çš„åŸå§‹ Source URL (æœ€æ¸…æ™°çš„æ•°æ®æº)
    const originalSrc = bgImage.getSrc();

    // 2. æ•è·å½“å‰ç”»å¸ƒä¸Šçš„è§†è§‰çŠ¶æ€ (ç”¨äºæœ€åæ¢å¤è§†å›¾)
    const rect = previewBgRect.value;
    const targetVisualZoom = rect.scaleX;

    // 3. åœ¨å†…å­˜ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„ Fabric Image å¯¹è±¡ï¼ŒåŠ è½½åŸå§‹é«˜æ¸…å›¾
    fabric.Image.fromURL(originalSrc, (highResImg) => {

      // === æ ¸å¿ƒå·®å¼‚ï¼šåŸºäºåŸå§‹åˆ†è¾¨ç‡è®¡ç®— ===
      // highResImg.width / height æ˜¯å›¾ç‰‡æœ€åŸå§‹çš„åƒç´ å°ºå¯¸ (æ¯”å¦‚ 4000x3000)
      const originalW = highResImg.width;
      const originalH = highResImg.height;

      // è®¡ç®—é€‚åº”æ¯”ä¾‹ï¼šè®©åŸå›¾å®Œæ•´å¡è¿›ç›®æ ‡å°ºå¯¸ (Fit)
      // ä¾‹å¦‚ï¼šç›®æ ‡ 1000x222ï¼ŒåŸå›¾ 4000x3000
      // scale = min(1000/4000, 222/3000)
      const fitScale = Math.min(targetW / originalW, targetH / originalH);

      // 4. åˆ›å»ºé«˜æ¸…ç¦»å±ç”»å¸ƒ
      // è¿™é‡Œçš„ç­–ç•¥æ˜¯ï¼šå¦‚æœç›®æ ‡å°ºå¯¸å¾ˆå°(å¦‚1000px)ï¼Œæˆ‘ä»¬å¼ºåˆ¶æ”¾å¤§å¯¼å‡ºå°ºå¯¸ï¼Œä¿è¯Retinaå±æ¸…æ™°åº¦
      // è‡³å°‘ä¿è¯é•¿è¾¹æœ‰ 2500px ä»¥ä¸Šï¼Œæˆ–è€…æŒ‰ç›®æ ‡å°ºå¯¸çš„ 2-3 å€è¾“å‡º
      const outputMultiplier = Math.max(1, 3000 / Math.max(targetW, targetH)); // åŠ¨æ€è®¡ç®—å€ç‡

      const outputW = Math.round(targetW * outputMultiplier);
      const outputH = Math.round(targetH * outputMultiplier);

      const tempCanvas = new fabric.StaticCanvas(null, {
        width: outputW,
        height: outputH,
        backgroundColor: bgColor,
      });

      // 5. è®¾ç½®é«˜æ¸…å›¾åœ¨ç¦»å±ç”»å¸ƒä¸­çš„ä½ç½®
      highResImg.set({
        originX: 'center',
        originY: 'center',
        left: outputW / 2,
        top: outputH / 2,
        // å…³é”®ï¼šç¼©æ”¾ = é€‚åº”æ¯”ä¾‹ * è¾“å‡ºå€ç‡
        scaleX: fitScale * outputMultiplier,
        scaleY: fitScale * outputMultiplier,
        // ç»§æ‰¿åŸå›¾çš„è§’åº¦å’Œç¿»è½¬ï¼ˆå¦‚æœæœ‰ï¼‰
        angle: bgImage.angle,
        flipX: bgImage.flipX,
        flipY: bgImage.flipY
      });

      tempCanvas.add(highResImg);
      tempCanvas.renderAll();

      // 6. å¯¼å‡ºæœ€ç»ˆå›¾ç‰‡ (è¿™æ˜¯çœŸæ­£çš„é«˜æ¸…å›¾)
      const dataURL = tempCanvas.toDataURL({
        format: 'png',
        quality: 1
      });

      tempCanvas.dispose();

      // 7. åº”ç”¨å›ä¸»ç”»å¸ƒ
      bgImage.setSrc(dataURL, () => {
        // 1. æ¸…ç†é¢„è§ˆèµ„æº
        if (previewBgRect.value) {
          canvas.remove(toRaw(previewBgRect.value));
          previewBgRect.value = null;
        }
        originalTransform = null;

        // 2. æ¢å¤äº¤äº’çŠ¶æ€
        bgImage.selectable = originalSelectable;
        bgImage.evented = originalEvented;

        // === 3. æ ¸å¿ƒï¼šæ¸…æ™°åº¦è°ƒæ•´ (Source Remastering) ===
        // æ³¨æ„ï¼šè¿™æ®µé€»è¾‘ä¸èƒ½åˆ ã€‚é«˜æ¸…é‡åˆ¶å¯¼å‡ºäº†ç‰©ç†åƒç´ æé«˜çš„æ–°å›¾ (outputMultiplier)ï¼Œ
        // æˆ‘ä»¬éœ€è¦æŠŠå®ƒç¼©æ”¾åˆ°é€»è¾‘å°ºå¯¸ï¼Œå¦åˆ™å›¾ç‰‡ä¼šæ˜¾å¾—å¼‚å¸¸å·¨å¤§æˆ–æ¨¡ç³Šã€‚
        const displayScale = 1 / outputMultiplier;

        bgImage.set({
          scaleX: displayScale,
          scaleY: displayScale,
          angle: 0,
          flipX: false,
          flipY: false,
          originX: 'center',
          originY: 'center',
          left: 0,
          top: 0
        });

        // === 4. è§†å›¾å¤„ç† ===
        // æ ¹æ®ä½ çš„è¦æ±‚ï¼Œè¿™é‡Œæ³¨é‡Šæ‰äº†ä¼šå¼•èµ·è§†è§’è·³åŠ¨çš„é‡ç½®ä»£ç 
        // canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); // âŒ ä¸è¿›è¡Œè§†è§’å¤ä½

        // ä¹Ÿä¸ä½¿ç”¨ zoomToPoint è·³è½¬åˆ°é¢„è®¾è§†è·
        // canvas.zoomToPoint(new fabric.Point(canvas.width / 2, canvas.height / 2), targetVisualZoom); // âŒ ä¸æ”¹å˜å½“å‰ç¼©æ”¾æ¯”ä¾‹

        // 5. ä»…åœ¨å½“å‰è§†è§’ä¸‹å°†å›¾ç‰‡å±…ä¸­
        canvas.centerObject(bgImage);
        bgImage.setCoords();

        // 6. åˆ·æ–°ç”»å¸ƒå¹¶ä¿å­˜å†å²
        canvas.requestRenderAll();
        if (saveHistoryFn) saveHistoryFn();

        resolve();
      });
    }, { crossOrigin: 'anonymous' }); // ç¡®ä¿è·¨åŸŸå›¾ç‰‡èƒ½åŠ è½½
  });
};
</file>

<file path="src/components/modules/puzzle/config.js">
// src/components/modules/puzzle/config.js

// =========================================================================
// 1. ç½‘æ ¼æ¨¡æ¿æ•°æ® - æŒ‰å›¾ç‰‡æ•°é‡åˆ†ç»„
// =========================================================================
// ç½‘æ ¼æ¨¡æ¿æ•°æ® - æŒ‰å›¾ç‰‡æ•°é‡åˆ†ç»„
export const gridTemplates = {
  1: [
    {
      id: '1-1',
      wrapStyle: {
        'grid-template-columns': 'repeat(1, 1fr)',
        'grid-template-rows': 'repeat(1, 1fr)',
      },
      gridAreas: ['1 / 1 / 2 / 2'],
    }
  ],
  2: [
    {
      id: '2-1',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: ['1 / 1 / 3 / 2', '1 / 2 / 3 / 3'],
    },
    {
      id: '2-2',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: ['1 / 1 / 2 / 3', '2 / 1 / 3 / 3'],
    }
  ],
  3: [
    {
      id: '3-1',
      wrapStyle: {
        'grid-template-columns': 'repeat(3, 1fr)',
        'grid-template-rows': 'repeat(3, 1fr)',
      },
      gridAreas: ['1 / 1 / 3 / 3', '1 / 3 / 3 / 4', '3 / 1 / 4 / 4'],
    },
    {
      id: '3-2',
      wrapStyle: {
        'grid-template-columns': 'repeat(3, 1fr)',
        'grid-template-rows': 'repeat(3, 1fr)',
      },
      gridAreas: ['1 / 1 / 2 / 4', '2 / 1 / 4 / 3', '2 / 3 / 4 / 4'],
    },
    {
      id: '3-3',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 3 / 2',
        '1 / 2 / 2 / 3',
        '2 / 2 / 3 / 3'
      ],
    },
    {
      id: '3-4',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 2',
        '1 / 2 / 3 / 3',
        '2 / 1 / 3 / 2'
      ],
    },
    {
      id: '3-5',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 3',
        '2 / 1 / 3 / 2',
        '2 / 2 / 3 / 3'
      ],
    },
    {
      id: '3-6',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 2',
        '1 / 2 / 2 / 3',
        '2 / 1 / 3 / 3'
      ],
    },
    {
      id: '3-7',
      wrapStyle: {
        'grid-template-columns': 'repeat(3, 1fr)',
        'grid-template-rows': 'repeat(3, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 4 / 2',
        '1 / 2 / 4 / 3',
        '1 / 3 / 4 / 4'
      ],
    },
    {
      id: '3-8',
      wrapStyle: {
        'grid-template-columns': 'repeat(3, 1fr)',
        'grid-template-rows': 'repeat(3, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 4',
        '2 / 1 / 3 / 4',
        '3 / 1 / 4 / 4'
      ],
    }
  ],
  4: [
    {
      id: '4-1',
      wrapStyle: {
        'grid-template-columns': 'repeat(2, 1fr)',
        'grid-template-rows': 'repeat(2, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 2',
        '1 / 2 / 2 / 3',
        '2 / 1 / 3 / 2',
        '2 / 2 / 3 / 3'
      ],
    },
    {
      id: '4-2',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 4 / 3',
        '1 / 3 / 4 / 7',
        '4 / 1 / 7 / 5',
        '4 / 5 / 7 / 7'
      ],
    },
    {
      id: '4-3',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 7 / 3',
        '1 / 3 / 4 / 5',
        '4 / 3 / 7 / 5',
        '1 / 5 / 7 / 7'
      ],
    },
    {
      id: '4-4',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 3 / 7',
        '3 / 1 / 5 / 4',
        '3 / 4 / 5 / 7',
        '5 / 1 / 7 / 7'
      ],
    },
    {
      id: '4-5',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 5 / 2',
        '1 / 2 / 5 / 3',
        '1 / 3 / 5 / 4',
        '1 / 4 / 5 / 5'
      ],
    },
    {
      id: '4-6',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 5',
        '2 / 1 / 3 / 5',
        '3 / 1 / 4 / 5',
        '4 / 1 / 5 / 5'
      ],
    },
    {
      id: '4-7',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 3 / 4',
        '3 / 1 / 5 / 4',
        '5 / 1 / 7 / 4',
        '1 / 4 / 7 / 7'
      ],
    },
    {
      id: '4-8',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 7 / 4',
        '1 / 4 / 3 / 7',
        '3 / 4 / 5 / 7',
        '5 / 4 / 7 / 7'
      ],
    },
    {
      id: '4-9',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 4 / 3',
        '1 / 3 / 4 / 5',
        '1 / 5 / 4 / 7',
        '4 / 1 / 7 / 7'
      ],
    },
    {
      id: '4-10',
      wrapStyle: {
        'grid-template-columns': 'repeat(6, 1fr)',
        'grid-template-rows': 'repeat(6, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 4 / 7',
        '4 / 1 / 7 / 3',
        '4 / 3 / 7 / 5',
        '4 / 5 / 7 / 7'
      ],
    },
    {
      id: '4-11',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 3 / 5',
        '3 / 1 / 5 / 3',
        '3 / 3 / 4 / 5',
        '4 / 3 / 5 / 5'
      ],
    },
    {
      id: '4-12',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 5 / 3',
        '1 / 3 / 3 / 4',
        '1 / 4 / 3 / 5',
        '3 / 3 / 5 / 5'
      ],
    },
    {
      id: '4-13',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 2 / 3',
        '2 / 1 / 3 / 3',
        '1 / 3 / 3 / 5',
        '3 / 1 / 5 / 5'
      ],
    },
    {
      id: '4-14',
      wrapStyle: {
        'grid-template-columns': 'repeat(4, 1fr)',
        'grid-template-rows': 'repeat(4, 1fr)',
      },
      gridAreas: [
        '1 / 1 / 3 / 3',
        '3 / 1 / 5 / 2',
        '3 / 2 / 5 / 3',
        '1 / 3 / 5 / 5'
      ],
    },
  ]
};

// å›¾ç‰‡æ•°é‡ä¸‹æ‹‰
export const countOptions = [
  { value: 'all', label: 'å…¨éƒ¨' },
  ...Array.from({ length: 4 }, (_, i) => ({ value: `${i + 1}`, label: `${i + 1}` })),
];

// =========================================================================
// 3. æ ¸å¿ƒå·¥å…·å‡½æ•°ï¼šç”Ÿæˆå’Œè§£æç½‘æ ¼
// =========================================================================

/**
 * åŠ¨æ€ç”Ÿæˆ NxM ç½‘æ ¼çš„å•å…ƒæ ¼æ•°æ®
 * @param {Number} rows è¡Œæ•°
 * @param {Number} cols åˆ—æ•°
 * @returns {Array} å•å…ƒæ ¼æ•°ç»„
 */
export const generateGridCells = (rows, cols) => {
  const cells = [];
  const w = 1 / cols;
  const h = 1 / rows;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      cells.push({
        index: r * cols + c,
        x: c * w,
        y: r * h,
        w,
        h
      });
    }
  }
  return cells;
};

/**
 * è§£æ CSS Grid Area æ¨¡æ¿ä¸ºç™¾åˆ†æ¯”åæ ‡
 * å…¼å®¹æ ¼å¼å¦‚: "1 / 1 / 2 / 2" (rowStart / colStart / rowEnd / colEnd)
 * @param {Object} tpl æ¨¡æ¿å¯¹è±¡
 */
export const parseTemplateToCells = (tpl) => {
  if (!tpl || !tpl.gridAreas) return [];

  let maxR = 1, maxC = 1;

  const getCountFromStyle = (styleStr) => {
    if (!styleStr) return 1;
    const repeatMatch = styleStr.match(/repeat\((\d+)/);
    if (repeatMatch) return parseInt(repeatMatch[1]);
    const spaceMatch = styleStr.trim().split(/\s+/);
    return spaceMatch.length;
  };

  if (tpl.wrapStyle) {
    maxC = Math.max(maxC, getCountFromStyle(tpl.wrapStyle['grid-template-columns']));
    maxR = Math.max(maxR, getCountFromStyle(tpl.wrapStyle['grid-template-rows']));
  }

  tpl.gridAreas.forEach(area => {
    const parts = area.split('/').map(s => parseInt(s.trim()));
    if (parts.length >= 4) {
      if (parts[2] - 1 > maxR) maxR = parts[2] - 1;
      if (parts[3] - 1 > maxC) maxC = parts[3] - 1;
    }
  });

  return tpl.gridAreas.map((area, index) => {
    const [r1, c1, r2, c2] = area.split('/').map(s => parseInt(s.trim()));
    const x = (c1 - 1) / maxC;
    const y = (r1 - 1) / maxR;
    const w = (c2 - c1) / maxC;
    const h = (r2 - r1) / maxR;

    return { index, x, y, w, h };
  });
};
</file>

<file path="src/composables/useCanvasLock.js">
import { unref } from 'vue';

/**
 * âœ¨ 1. å®šä¹‰ LOCKABLE_PROPERTIES é™æ€å¸¸é‡åˆ—è¡¨
 * æ‰€æœ‰çš„é”å®šå’Œè±å…åŠ¨ä½œéƒ½å¿…é¡»ä¸¥æ ¼éµå¾ªæ­¤åˆ—è¡¨ï¼Œç¡®ä¿é€»è¾‘ä¸€ä¸€å¯¹åº”
 */
const LOCK_CONFIG = {
  // å±æ€§å: [é”å®šå€¼, äº¤äº’å€¼]
  'selectable': [false, true],
  'evented': [false, true],
  'hasControls': [false, true],
  'hasBorders': [false, true],
  'lockMovementX': [true, false],
  'lockMovementY': [true, false],
  'lockRotation': [true, false],
  'lockScalingX': [true, false],
  'lockScalingY': [true, false],
};

export function useCanvasLock() {
  // çŠ¶æ€è®°å¿†åº“ (WeakMap)
  const objectStates = new WeakMap();

  /**
   * ğŸ›¡ï¸ å†…éƒ¨å‡½æ•°ï¼šObjectFunctions.enable(obj)
   * å¼ºåˆ¶å°†å¯¹è±¡æ¢å¤åˆ°å…¨åŠŸèƒ½çŠ¶æ€ï¼Œç”¨äºè±å…é€»è¾‘ (ç­–ç•¥ B)
   */
  const forceEnableObject = (obj, isRulerMode) => {
    Object.keys(LOCK_CONFIG).forEach(prop => {
      const [_, interactiveValue] = LOCK_CONFIG[prop];
      obj.set(prop, interactiveValue);
    });
    // ç‰¹æ®Šå…‰æ ‡å¤„ç†
    obj.set('hoverCursor', isRulerMode ? 'move' : 'default');
  };

  /**
   * ğŸ›¡ï¸ å†…éƒ¨å‡½æ•°ï¼šå®æ–½ç‰©ç†é”å®šå¹¶å¤‡ä»½
   */
  const lockAndStoreObject = (obj) => {
    const backup = {};
    Object.keys(LOCK_CONFIG).forEach(prop => {
      // âœ¨ åªæœ‰ç¬¬ä¸€æ¬¡é”å®šè¯¥å¯¹è±¡æ—¶æ‰å¤‡ä»½ï¼Œé˜²æ­¢å¤šå±‚è®°å¿†è¦†ç›–åŸå§‹çŠ¶æ€
      if (!objectStates.has(obj)) {
        backup[prop] = obj[prop];
      }
      const [lockedValue] = LOCK_CONFIG[prop];
      obj.set(prop, lockedValue);
    });
    
    if (Object.keys(backup).length > 0) {
      objectStates.set(obj, backup);
    }
    obj.set('hoverCursor', 'default');
  };

  /**
   * ğŸ›¡ï¸ ä¸»å‡½æ•°ï¼šæ™ºèƒ½ç‰©ç†é”æ§åˆ¶
   */
  const setBackgroundLock = (canvasInstance, shouldLock, options = {}) => {
    const canvas = unref(canvasInstance);
    if (!canvas) return;

    const { excludeRulers = true, dragMode = false, isRulerMode = false } = options;
    const objects = canvas.getObjects();
    
    if (shouldLock) {
      // 1. ç”»å¸ƒçº§çŠ¶æ€è°ƒæ•´
      canvas.selection = false; 
      canvas.defaultCursor = dragMode ? 'grab' : (isRulerMode ? 'crosshair' : 'default');

      objects.forEach(obj => {
        const isMain = obj.isMainImage || obj.id === 'main-image' || (obj.type === 'image' && objects.indexOf(obj) === 0);
        
        // 2. ä¸»å›¾è·¯ç”± (å§‹ç»ˆæ‹¥æœ‰æœ€é«˜è±å…æƒ)
        if (isMain) {
          obj.set({
            selectable: dragMode, 
            evented: dragMode,
            hoverCursor: dragMode ? 'grab' : (isRulerMode ? 'crosshair' : 'default'),
            moveCursor: dragMode ? 'grabbing' : 'default'
          });
          return;
        }

        // 3. ç­–ç•¥ B è±å…é€»è¾‘ï¼šå¦‚æœæ˜¯æ ‡å°ºä¸”å¼€å¯è±å…ï¼Œæ‰§è¡Œâ€œå¼ºåˆ¶å¼€å¯â€å¾ªç¯
        if (excludeRulers && obj.isRuler) {
          forceEnableObject(obj, isRulerMode);
          return;
        }

        // 4. æ ‡å‡†é”å®šé€»è¾‘ï¼šæ‰§è¡Œâ€œå¼ºåˆ¶é”å®šâ€å¾ªç¯å¹¶å¤‡ä»½
        lockAndStoreObject(obj);
      });

      // è‡ªåŠ¨æ¸…ç†éæ‹–æ‹½æ¨¡å¼ä¸‹çš„ä¸»å›¾é€‰ä¸­
      if (!dragMode && canvas.getActiveObject()?.isMainImage) {
        canvas.discardActiveObject();
      }

    } else {
      // === ğŸ”“ å…¨å±€è§£é”é˜¶æ®µ ===
      canvas.selection = true;
      canvas.defaultCursor = 'default';

      objects.forEach(obj => {
        const originalState = objectStates.get(obj);
        if (originalState) {
          // åŸºäºå¤‡ä»½æ¢å¤
          obj.set(originalState);
          objectStates.delete(obj);
        } else {
          // å¦‚æœæ²¡æœ‰å¤‡ä»½ï¼ˆå¯èƒ½æ˜¯æ–°ç”Ÿæˆçš„å¯¹è±¡ï¼‰ï¼Œæ‰§è¡Œæ ‡å‡†åŒ–è§£é”
          forceEnableObject(obj, false);
        }
      });
    }

    canvas.requestRenderAll();
  };

  return { setBackgroundLock };
}
</file>

<file path=".spec/project-charter.md">
# Project Charter: Image Editor SDK (å¤§ç§˜ç¾å›¾)

> **Version**: 3.8.0 (Integrated Edition)
> **Last Updated**: 2025-12-22
> **Context**: High-performance Web Image Processing SDK
> **Enforcement**: æ­¤æ–‡æ¡£ä¸ºæœ€é«˜å‡†åˆ™ï¼ŒAI ç”Ÿæˆä»£ç å¿…é¡»ä¸¥æ ¼æŸ¥é˜…å¹¶éµå¾ªã€‚

## 0. AI äº¤äº’æ ¸å¿ƒæŒ‡ä»¤ (Prime Directives)

> **ä¼˜å…ˆçº§**: ğŸ”´ æœ€é«˜ (Highest Priority)
> **é€‚ç”¨èŒƒå›´**: æ‰€æœ‰ä»£ç ç”Ÿæˆä¸ä¿®æ”¹ä»»åŠ¡
> 

1.  **ä»£ç å®Œæ•´æ€§å…¬çº¦ (Code Integrity Protocol)**:
    - **å…¨é‡äº¤ä»˜ (Full Output)**: é™¤éç”¨æˆ·æ˜ç¡®è¦æ±‚â€œä»…å‘é€ç‰‡æ®µâ€ï¼Œå¦åˆ™åœ¨ä¿®æ”¹æ–‡ä»¶æ—¶ï¼Œ**å¿…é¡»è¾“å‡ºæ–‡ä»¶çš„å®Œæ•´ä»£ç **ã€‚
    - **ç¦æ­¢ç²¾ç®€ (No Simplification)**: ä¸¥ç¦ä½¿ç”¨ `// ... rest of code`ã€`// ... keep original` æˆ–çœç•¥å·æ¥ä»£æ›¿åŸæœ‰ä»£ç ã€‚å¿…é¡»å®Œæ•´ä¿ç•™æœªä¿®æ”¹çš„ UI ç»“æ„ã€æ ·å¼ (`<style>`)ã€SVG å›¾æ ‡åŠè¾…åŠ©å‡½æ•°ã€‚
    - **æ— æŸæ³¨å…¥ (Non-Destructive)**: æ–°ä»£ç å¿…é¡»æ˜¯â€œæ³¨å…¥â€åˆ°ç°æœ‰é€»è¾‘ä¸­ï¼Œä¸¥ç¦åœ¨é‡æ„æ—¶é€šè¿‡â€œé‡å†™â€å¯¼è‡´åŸæœ‰ Grid å¸ƒå±€ã€é¢„è®¾æ•°æ®æˆ–é€»è¾‘ä¸¢å¤±ã€‚
2.  **å®‰å…¨ç¬¬ä¸€ (Safety First)**:
    - å½“æ–‡ä»¶è¶…è¿‡ token é™åˆ¶æ— æ³•ä¸€æ¬¡è¾“å‡ºæ—¶ï¼Œ**ä¸»åŠ¨æš‚åœ**å¹¶è¯¢é—®ç”¨æˆ·æ˜¯å¦åˆ†æ®µè¾“å‡ºï¼Œè€Œä¸æ˜¯æ“…è‡ªåˆ å‡ä»£ç ã€‚
3.  **âœ¨ æ™ºèƒ½äº¤äº’å…¬çº¦ (Smart Interaction Protocol) `NEW`**:
    - **æ·±åº¦åé—® (Proactive Counter-Questioning)**: é’ˆå¯¹ç”¨æˆ·çš„ä»»ä½•æŠ€æœ¯æè®®æˆ–åŠŸèƒ½æ”¹å˜ï¼ŒAI ä¸å¾—ç›´æ¥ç›²ç›®æ‰§è¡Œã€‚å¿…é¡»ä»æ¶æ„ä¸€è‡´æ€§ã€æ½œåœ¨ Bugã€ç”¨æˆ·ä½“éªŒã€æ€§èƒ½æŸè€—ç­‰ç»´åº¦è¿›è¡Œè‡³å°‘ 2-3 ä¸ªæ·±åº¦çš„â€œåé—®â€æˆ–â€œè´¨ç–‘â€ã€‚
    -   **ç²¾å‡†ç´¢å– (Precision File Solicitation)**: åœ¨é’ˆå¯¹æè®®è¿›è¡Œåˆ†æå‰ï¼ŒAI å¿…é¡»æ ¹æ®æè®®æ¶‰åŠçš„æ¨¡å—ï¼Œåˆ—å‡ºéœ€è¦ç”¨æˆ·æä¾›çš„æ ¸å¿ƒæ–‡ä»¶åˆ—è¡¨ï¼ˆå¦‚ `useCanvasXXX.js`, `XXX.vue`ï¼‰ï¼Œä»¥ç¡®ä¿åˆ†ææ˜¯åŸºäºæœ€æ–°çœŸå®ä»£ç çš„ã€‚
4.  **åŒé‡é”å®šå‡†åˆ™ (Double-Locking)**: é’ˆå¯¹å¼‚æ­¥åŠ è½½å¯¹è±¡ï¼Œå¿…é¡»åœ¨ `onMounted` ä¸ `image:updated` (æˆ– `nextTick`) æ‰§è¡ŒåŒé‡é”å®šã€‚
5.  **âœ¨ é…ç½®é©±åŠ¨åŸåˆ™ (Configuration-Driven Principle)**: 
    - **æ ¸å¿ƒè§„èŒƒ**: å‡¡æ˜¯æ¶‰åŠå¤šå±æ€§æ˜ å°„ã€çŠ¶æ€è½¬æ¢ã€é”å®š/æ¢å¤é€»è¾‘çš„ï¼Œå¿…é¡»é‡‡ç”¨â€œé…ç½®å¯¹è±¡ (Configuration Object)â€æˆ–â€œå¸¸é‡æ± â€è¿›è¡Œé©±åŠ¨ã€‚
    - **ä¸¥ç¦ç¡¬ç¼–ç **: ä¸¥ç¦åœ¨å¾ªç¯ã€æ¡ä»¶åˆ¤æ–­ä¸­ç›´æ¥ä¹¦å†™å±æ€§åå­—ç¬¦ä¸²ã€‚
    - **å¯¹ç§°æ€§ä¿è¯**: é”å®šä¸è§£é”ã€å¼€å¯ä¸å…³é—­çš„é€»è¾‘å¿…é¡»å…±äº«åŒä¸€ä»½é…ç½®æºï¼Œç¡®ä¿æ“ä½œçš„åŸå­æ€§ä¸å®Œæ•´æ€§ã€‚  
---

## 1. é¡¹ç›®æ„¿æ™¯ (Vision)

æ„å»ºä¸€ä¸ª**æ¨¡å—åŒ–ã€é«˜æ€§èƒ½**çš„ Web ç«¯å›¾åƒå¤„ç† SDKã€‚æ ¸å¿ƒæ¶æ„é‡‡ç”¨â€œè½»é‡çº§æ ¸å¿ƒ (Core) + åŠŸèƒ½æ’ä»¶åŒ– (Modules)â€çš„è®¾è®¡æ¨¡å¼ï¼Œæ”¯æŒä»åŸºç¡€çš„è£å‰ªæ—‹è½¬åˆ°å¤æ‚çš„ AI æ¶ˆé™¤ã€æ‹¼å›¾å’Œæ»¤é•œå¤„ç†ã€‚

---

## 2. æŠ€æœ¯æ ˆä¸ç‰ˆæœ¬çº¦æŸ (Tech Stack)

> âš ï¸ **å…³é”®çº¦æŸ**ï¼šæ‰€æœ‰è‡ªåŠ¨ç”Ÿæˆçš„ä»£ç å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹ç‰ˆæœ¬ç‰¹æ€§ã€‚

- **Core Framework**: Vue 3.3+ (Composition API, `<script setup>`)
- **Graphics Engine**: **Fabric.js v5.3.0** (Locked)
  - âŒ **ä¸¥ç¦**: ä½¿ç”¨ Fabric v6 çš„ `Canvas` ç±»åæˆ– Promise-based æ¸²æŸ“ã€‚
  - âœ… **å¿…é¡»**: ä½¿ç”¨ `new fabric.Canvas()` ç­‰ v5 é£æ ¼ APIã€‚
- **Build Tool**: Vite 7.x
- **Style System**: **Native CSS (Scoped) + CSS Variables**
  - **Color Source**: éµå¾ª SSOT åŸåˆ™ï¼Œé¢œè‰²å¿…é¡»å®šä¹‰åœ¨ `src/config/theme.js`ã€‚
  - **Isolation**: æ‰€æœ‰æ ·å¼å¿…é¡»åŒ…è£¹åœ¨ `.image-editor-sdk-container` ä½œç”¨åŸŸå†…ã€‚
- **State Management**: **Custom Reactive Singleton**
  - å¿…é¡»ä¿æŒå“åº”æ€§ï¼Œä¸¥ç¦ç›´æ¥è§£æ„ State å¯¹è±¡ã€‚

---

## 3. æ ¸å¿ƒæ¶æ„æ¨¡å¼ (Core Architecture Patterns) `Critical`

### 3.1 é¢œè‰²ç®¡ç†ç­–ç•¥ (Color Strategy)

> **åŸåˆ™**: è§£å†³ Canvas (JS) ä¸ UI (CSS) é¢œè‰²ä¸åŒæ­¥é—®é¢˜ã€‚

1.  **çœŸç†æº**: æ‰€æœ‰é¢œè‰²å€¼å®šä¹‰åœ¨ `src/config/theme.js` çš„ `THEME` å¯¹è±¡ä¸­ã€‚
2.  **æ³¨å…¥æœºåˆ¶**: App æŒ‚è½½æ—¶ (`onMounted`)ï¼Œå¿…é¡»è°ƒç”¨ `applyTheme(containerRef)` å°† JS å˜é‡æ³¨å…¥ä¸º CSS å˜é‡ã€‚
3.  **ä½¿ç”¨è§„èŒƒ**:
    - **UI (Vue/CSS)**: ä½¿ç”¨ `var(--ie-primary-color)`ã€‚
    - **Canvas (JS)**: å¼•å…¥ `THEME` å¯¹è±¡ï¼Œä½¿ç”¨ `THEME.colors.primary`ã€‚
    - **ç¦æ­¢**: ä»£ç ä¸­å‡ºç° `#409eff` ç­‰ç¡¬ç¼–ç é¢œè‰²ã€‚

### 3.2 é«˜æ¸…ç¦»å±æ¸²æŸ“ (Offscreen Rendering)

- æ‰€æœ‰æ¶‰åŠ**å¯¼å‡ºå›¾ç‰‡**æˆ–**ç”Ÿæˆ AI é®ç½©**çš„æ“ä½œï¼Œå¿…é¡»ä½¿ç”¨ `src/composables/useOffscreenHelper.js`ï¼Œä¸¥ç¦ç›´æ¥å¯¹ä¸» Canvas è¿›è¡Œ `toDataURL`ã€‚

### 3.3 æ¨¡å—é€šä¿¡ (Event Bus)

- ä½¿ç”¨ Fabric Canvas å®ä¾‹ (`canvas.fire`) ä½œä¸ºå”¯ä¸€äº‹ä»¶æ€»çº¿ã€‚

---

## 4. ç›®å½•ç»“æ„è§„èŒƒ (Directory Structure)

src/
â”œâ”€â”€ api/ # åç«¯æ¥å£äº¤äº’ (AI, Rembg, Inpaint)
â”œâ”€â”€ components/
â”‚ â”œâ”€â”€ common/ # é€šç”¨åŸå­ç»„ä»¶ (Modal, LoadingOverlay, ContextMenu...)
â”‚ â”œâ”€â”€ layout/ # å…¨å±€å¸ƒå±€ç»„ä»¶ (EditorLayout, LeftSidebar, NavBar)
â”‚ â”œâ”€â”€ modules/ # ç‹¬ç«‹åŠŸèƒ½æ¨¡å— (ä¸šåŠ¡é€»è¾‘æ ¸å¿ƒ)
â”‚ â”‚ â”œâ”€â”€ adjust/ # è°ƒæ•´ç±» (Crop, Resize, Filter...) - å†…å« Vue + useCanvasHooks
â”‚ â”‚ â”œâ”€â”€ ai/ # AI ç±»åŠŸèƒ½ (AiGenerate, AiExpand)
â”‚ â”‚ â”œâ”€â”€ draw/ # è‡ªç”±ç»˜åˆ¶æ¨¡å—
â”‚ â”‚ â”œâ”€â”€ text/ # æ–‡æœ¬æ¨¡å—
â”‚ â”‚ â”œâ”€â”€ puzzle/ # æ‹¼å›¾æ¨¡å— (å« config.js)
â”‚ â”‚ â””â”€â”€ ... # å…¶ä»–æ¨¡å— (border, material, watermark)
â”‚ â”œâ”€â”€ panels/ # äºŒçº§ä¾§è¾¹æ å®¹å™¨ (ToolPanel)
â”‚ â””â”€â”€ Workspace.vue # ç”»å¸ƒæ ¸å¿ƒå®¹å™¨ (Canvas åˆå§‹åŒ–ä¸äº‹ä»¶ç»‘å®š)
â”œâ”€â”€ composables/ # æ ¸å¿ƒé€»è¾‘ Hooks (useCanvas, useEditorState, useCanvasLock...)
â”œâ”€â”€ config/ # é™æ€é…ç½® (theme.js, shortcuts.js)
â””â”€â”€ utils/ # çº¯å‡½æ•°å·¥å…·åº“ (toast.js)

---

## 5. UI å¼€å‘è§„èŒƒ (UI Design System)

> **åŸåˆ™**: ä½¿ç”¨ Scoped CSS å’Œ CSS å˜é‡ï¼Œç»Ÿä¸€è§†è§‰é£æ ¼ã€‚

### 5.1 é€šç”¨ç±»åè¡¨ (Common Classes)

| ç»„ä»¶ç±»å‹       | ç±»å (Class Name)  | æ ·å¼ç‰¹å¾ (Style Specs)                                               |
| :------------- | :----------------- | :------------------------------------------------------------------- |
| **é¢æ¿å®¹å™¨**   | `.tool-panel`      | `bg: var(--panel-bg)`, å›ºå®šå®½ 280pxï¼Œç™½åº•/æ·±è‰²æ¨¡å¼é€‚é…ï¼Œç»å¯¹å®šä½å³ä¾§ |
| **é¢æ¿æ ‡é¢˜**   | `.panel-title`     | 14px, 600 weight, åº•éƒ¨ Margin                                        |
| **æ§åˆ¶ç»„**     | `.control-group`   | åŒ…å«æ ‡ç­¾å’Œæ§ä»¶çš„å®¹å™¨ï¼Œåº•éƒ¨ Margin (24px)                             |
| **å±æ€§è¡Œ**     | `.label-row`       | Flex å¸ƒå±€ (ä¸¤ç«¯å¯¹é½)ï¼Œç”¨äºæ˜¾ç¤º "å±æ€§å - æ•°å€¼"                       |
| **ä¸»è¦æŒ‰é’®**   | `.btn-primary`     | 100% å®½åº¦ï¼Œ`bg: var(--primary)`ï¼Œåœ†è§’ (4px)                          |
| **æ¬¡è¦æŒ‰é’®**   | `.btn-secondary`   | `border: var(--border)`ï¼Œç”¨äºå–æ¶ˆæˆ–æ¬¡è¦æ“ä½œ                          |
| **æ»‘åŠ¨æ¡**     | `.slider-input`    | ç»Ÿä¸€å®½åº¦çš„ range input                                               |
| **æ•°å€¼è¾“å…¥æ¡†** | `.ie-input-number` | å›ºå®šå®½ 50pxï¼Œé«˜ 28pxï¼Œå±…ä¸­å¯¹é½ï¼Œæ— åŸç”Ÿç®­å¤´ï¼Œå¸¸é…åˆ Slider ä½¿ç”¨       |

---

## 6. å¼€å‘å·¥ä½œæµ (OpenSpec Workflow)

### 6.1 æè®® (Proposal)

åœ¨å¼€å‘æ–°åŠŸèƒ½å‰ï¼Œå¿…é¡»åœ¨ `.spec/proposals/` ä¸‹åˆ›å»ºæ–‡æ¡£ï¼Œå¹¶å›ç­”ä»¥ä¸‹â€œçµé­‚ä¸‰é—®â€ï¼š

1.  **å¤ç”¨æ£€æŸ¥**: â€œæˆ‘è¦å†™çš„è¿™ä¸ªè¾…åŠ©å‡½æ•°ï¼Œ`src/utils` é‡Œæœ‰æ²¡æœ‰ï¼ŸUI ç»„ä»¶åœ¨ `common` é‡Œæœ‰æ²¡æœ‰ï¼Ÿæ¶æ„æ¨¡å¼åœ¨ `Section 3` é‡Œæœ‰æ²¡æœ‰ï¼Ÿâ€
2.  **UI ä½ç½®**: åœ¨ `ToolPanel` çš„å“ªä¸ªä½ç½®å¢åŠ å…¥å£ï¼Ÿ
3.  **äº¤äº’é€»è¾‘**: æ‹–å…¥ç”»å¸ƒåçš„é»˜è®¤è¡Œä¸ºï¼ˆå±…ä¸­ï¼Ÿè‡ªåŠ¨ç¼©æ”¾ï¼Ÿï¼‰ã€‚

### 6.2 å®æ–½æ£€æŸ¥æ¸…å• (The "Golden Checklist") [CRITICAL]

- [ ]æ¯æ¬¡ç”Ÿæˆä»£ç å‰ï¼Œå…ˆè¯»å– `active-context.md` ç¡®è®¤å½“å‰ä¸Šä¸‹æ–‡ã€‚
- [ ] **Canvas é”€æ¯**: ç»„ä»¶ `onUnmounted` æ—¶æ˜¯å¦æ³¨é”€äº† fabric äº‹ä»¶ç›‘å¬ï¼Ÿ
- [ ] **çŠ¶æ€æ¸…ç†**: é€€å‡ºæ¨¡å—æ—¶ï¼Œæ˜¯å¦é‡ç½®äº† `activeTool` å’Œä¸´æ—¶å›¾å±‚ï¼Ÿ
- [ ] **é”®ç›˜å®‰å…¨**: æ–°å¢å¿«æ·é”®æ˜¯å¦åˆ¤æ–­äº† `document.activeElement` ä»¥é˜²æ­¢è¾“å…¥æ¡†å†²çªï¼Ÿ
- [ ] **å“åº”å¼æ£€æŸ¥**: æ˜¯å¦é”™è¯¯åœ°ä½¿ç”¨äº† `const { state } = useStore()` å¯¼è‡´å“åº”æ€§ä¸¢å¤±ï¼Ÿ
- [ ] **é¢œè‰²åˆè§„**: æ£€æŸ¥ä»£ç ä¸­æ˜¯å¦è¿˜æ®‹ç•™ `#hex` ç¡¬ç¼–ç é¢œè‰²ï¼Ÿ
- [ ]ç”Ÿæˆä»£ç åï¼Œè‡ªæˆ‘æ£€æŸ¥æ˜¯å¦ç ´åäº†ç°æœ‰çš„ Grid å¸ƒå±€æˆ– CSS å˜é‡å¼•ç”¨ã€‚

---

## 7. æœ¯è¯­è¡¨ (Glossary)
- **Counter-Questioning Logic**: æŒ‡ AI åœ¨æ¥å—ä»»åŠ¡å‰ï¼Œé€šè¿‡åé—®ç¡®è®¤äº¤äº’è¾¹ç•Œä¸æŠ€æœ¯ç»†èŠ‚çš„è¿‡ç¨‹ï¼Œæ—¨åœ¨å‡å°‘é‡æ„æˆæœ¬ã€‚
- **Main Image**: ç”»å¸ƒåº•å±‚çš„æ ¸å¿ƒå›¾ç‰‡ (Index 0)ï¼Œé€šå¸¸è¢«é”å®šã€‚
- **Mask Object**: ç”¨äºé®ç½©çš„è¾…åŠ©å¯¹è±¡ï¼Œå¯¼å‡ºæ—¶é€šå¸¸ä¸å¯è§ã€‚
- **Puzzle Controller**: æ‹¼å›¾æ¨¡å¼ä¸‹çš„è™šæ‹Ÿæ§åˆ¶å™¨ï¼Œç”¨äºè°ƒæ•´é—´è·å’Œåœ†è§’ã€‚
- **Physical Lock**: é€šè¿‡ `useCanvasLock` æ–½åŠ çš„å¼ºåˆ¶ä¸å¯äº¤äº’çŠ¶æ€ã€‚
- **Main Image Identification**: å¿…é¡»åŒæ—¶å…·å¤‡ isMainImage: true å’Œ id: 'main-image' å±æ€§ã€‚æ‰€æœ‰æ“ä½œä¸»å›¾çš„æ¨¡å—ï¼ˆå¦‚ Resize, Whiteï¼‰
  åœ¨åˆå§‹åŒ–æ—¶å¿…é¡»æ ¡éªŒå¹¶è¡¥é½æ­¤  æ ‡è¯†ï¼Œä»¥é˜²è¢« useCanvasLock è¯¯é”ã€‚
- **Physical Lock Priority**: ç‰©ç†é”å¿…é¡»åœ¨æ‰€æœ‰ UI æ¸²æŸ“åŠé¢„è§ˆå¯¹è±¡åˆ›å»ºï¼ˆå¦‚ startPreviewï¼‰å®Œæˆåï¼Œåœ¨ nextTick ä¸­æ‰§è¡Œæœ€åä¸€æ¬¡â€œæ‰«å°¾å¼â€åŠ é”ã€‚
- **Configuration-Driven Lock**: æ‰€æœ‰çš„é”å®šå±æ€§ï¼ˆselectable, lockMovement ç­‰ï¼‰å‡å®šä¹‰åœ¨ `LOCK_CONFIG` ä¸­ï¼Œç³»ç»Ÿé€šè¿‡éå†è¯¥é…ç½®å®ç°é€»è¾‘è‡ªæ´½ã€‚
- **Force Functional State (ç­–ç•¥ B)**: è¿›å…¥ç‰¹å®šæ¨¡å—æ—¶ï¼Œé€šè¿‡é…ç½®æ± å¼ºåˆ¶æ¢å¤å¯¹è±¡çš„æ‰€æœ‰äº¤äº’å±æ€§ï¼Œç¡®ä¿åŠŸèƒ½ä¸å—å‰åºæ¨¡å—æ®‹ç•™çŠ¶æ€çš„å½±å“ã€‚
- **Configuration-Driven Lock**: æ‰€æœ‰çš„é”å®šå±æ€§å‡é›†ä¸­å®šä¹‰åœ¨ `LOCK_CONFIG` ä¸­ã€‚
</file>

<file path="src/components/modules/adjust/AdjustWhite.vue">
<template>
    <div class="tool-group">
        <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
            <div class="left">
                <svg width="18" height="18" viewBox="0 0 1024 1024" style="margin-right: 8px; fill: currentColor">
                    <path
                        d="M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32H96z m315.52-228.48l-68.928-114.88a32 32 0 0 0-54.784 0l-68.928 114.88L158.72 768h316.16l-60.16-100.48zM288 384a64 64 0 1 0 0-128 64 64 0 0 0 0 128z m261.12 216.96l-78.72-118.08a32 32 0 0 0-53.12 0l-78.72 118.08L483.2 697.6h126.72l-54.4-96.64z m208.64-106.88l-98.56-147.84a32 32 0 0 0-53.12 0l-98.56 147.84L652.8 697.6h209.92l-104.96-157.44z" />
                </svg>
                <span>å›¾ç‰‡è¡¥ç™½</span>
            </div>
            <div class="right-icon">
                <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="m9 18 6-6-6-6" />
                </svg>
            </div>
        </div>

        <div v-if="isExpanded" class="tool-content">

            <div class="preset-grid">
                <div class="preset-item custom-item" :class="{ active: isCustomMode }" @click="selectCustomMode">
                    <span>è‡ªå®šä¹‰</span>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="12" y1="8" x2="12" y2="16"></line>
                        <line x1="8" y1="12" x2="16" y2="12"></line>
                    </svg>
                </div>

                <div v-for="(preset, index) in presets" :key="index" class="preset-item"
                    :class="{ active: activePresetIndex === index }" @click="selectPreset(preset, index)">
                    <span class="preset-name">{{ preset.label }}</span>
                    <span class="preset-dim">{{ preset.w }}Ã—{{ preset.h }}</span>
                </div>
            </div>

            <div class="resize-input-box">
                <div class="input-controls">
                    <div class="input-wrapper">
                        <input type="number" v-model.number="width" class="ie-input" @change="onInputChanged('w')">
                        <span class="suffix">W</span>
                    </div>

                    <div class="link-icon-btn" @click="toggleAdaptive" :title="isAdaptive ? 'é”å®šæ¯”ä¾‹' : 'è‡ªç”±æ¯”ä¾‹'">
                        <svg v-if="isAdaptive" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="var(--ie-primary-color)" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                        </svg>
                        <svg v-else width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                            <line x1="4" y1="4" x2="20" y2="20" stroke="#999"></line>
                        </svg>
                    </div>

                    <div class="input-wrapper">
                        <input type="number" v-model.number="height" class="ie-input" @change="onInputChanged('h')">
                        <span class="suffix">H</span>
                    </div>
                </div>

                <div class="bg-color-section">
                    <div class="section-label">èƒŒæ™¯é¢œè‰²</div>
                    <div class="color-row">
                        <div class="color-item checkerboard" :class="{ active: currentBgColor === 'transparent' }"
                            @click="setBgColor('transparent')" title="é€æ˜"></div>
                        <div class="color-item" style="background: #ffffff; border: 1px solid #ddd;"
                            :class="{ active: currentBgColor === '#ffffff' }" @click="setBgColor('#ffffff')"></div>
                        <div class="color-item" style="background: #808080;"
                            :class="{ active: currentBgColor === '#808080' }" @click="setBgColor('#808080')"></div>
                        <div class="color-item" style="background: #000000;"
                            :class="{ active: currentBgColor === '#000000' }" @click="setBgColor('#000000')"></div>
                        <div class="color-item color-picker-wrap" :class="{ active: isCustomColor }">
                            <input type="color" v-model="customColorVal" @input="onCustomColorChange"
                                class="native-color-input" />
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path
                                    d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" />
                            </svg>
                        </div>
                    </div>
                </div>

            </div>

            <div class="action-buttons">
                <button class="ie-btn ie-primary full" @click="handleApply">åº”ç”¨ä¿®æ”¹</button>
                <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
            </div>

        </div>
    </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted, nextTick, computed } from 'vue';
// å¼•å…¥ä¿®æ”¹åçš„ useCanvasWhite
import { registerWhiteModule, getCurrentSize, applyWhitePadding, startPreview, updatePreview, stopPreview, zoomToPreview } from './useCanvasWhite';

const props = defineProps({
    isExpanded: { type: Boolean, default: false }
});

const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

// === çŠ¶æ€å®šä¹‰ ===
const width = ref(0);
const height = ref(0);
const isAdaptive = ref(false); // è¡¥ç™½æ¨¡å¼ä¸‹ï¼Œé»˜è®¤è‡ªç”±æ¯”ä¾‹
const originalRatio = ref(1);
const activePresetIndex = ref(-1);
const isInternalUpdate = ref(false);

// èƒŒæ™¯é¢œè‰²çŠ¶æ€
const currentBgColor = ref('#ffffff'); // é»˜è®¤ç™½è‰²
const customColorVal = ref('#ff0000');
const isCustomColor = computed(() => !['transparent', '#ffffff', '#808080', '#000000'].includes(currentBgColor.value));


// é¢„è®¾æ•°æ®
const presets = [
    { label: 'æ–¹å½¢ä¸»å›¾', w: 800, h: 800 },
    { label: 'Temuæœè£…å›¾', w: 1340, h: 1785 },
    { label: 'æ–¹å½¢ä¸»å›¾', w: 1000, h: 1000 },
    { label: 'ç«–å›¾ä¸»å›¾', w: 750, h: 1000 },
    { label: 'æ–¹å½¢ä¸»å›¾', w: 500, h: 500 },
    { label: 'ç«–å›¾ä¸»å›¾', w: 1000, h: 1200 },
    { label: 'Youtubeè§†é¢‘å°é¢', w: 1280, h: 720 },
    { label: 'Pinterestå¸–å­', w: 750, h: 1120 },
    { label: 'Facebookå°é¢', w: 851, h: 315 },
];

const isCustomMode = computed(() => activePresetIndex.value === -1);
const currentTargetRatio = computed(() => {
    if (activePresetIndex.value >= 0) {
        const p = presets[activePresetIndex.value];
        return p.h !== 0 ? (p.w / p.h) : 1;
    } else {
        return originalRatio.value;
    }
});

// === åˆå§‹åŒ– ===
const initSize = () => {
    if (canvasAPI && canvasAPI.canvas) {
        // ç¡®ä¿ä¼ å…¥äº† zoomToRect
        registerWhiteModule(canvasAPI.canvas, canvasAPI.saveHistory, canvasAPI.zoomToRect);

        const size = getCurrentSize();
        width.value = size.width;
        height.value = size.height;

        nextTick(() => {
            // ä»…å¼€å¯é¢„è§ˆæ¡†ï¼Œä¸ç§»åŠ¨ç›¸æœº
            startPreview(width.value, height.value, currentBgColor.value);
        });
    }
};


// === äº¤äº’é€»è¾‘ ===
const selectCustomMode = () => {
    activePresetIndex.value = -1;
    const size = getCurrentSize();
    width.value = size.width;
    height.value = size.height;
    updatePreviewBox();
};

const selectPreset = (preset, index) => {
    activePresetIndex.value = index;
    isInternalUpdate.value = true;
    width.value = preset.w;
    height.value = preset.h;

    nextTick(() => {
        isInternalUpdate.value = false;
        updatePreviewBox(); // å…ˆæ›´æ–°è“æ¡†å°ºå¯¸

        // âœ… è§¦å‘ç›¸æœºæ”¾å¤§ï¼šè®© 500*500 çš„æ¡†å æ®å½“åˆå›¾ç‰‡å æ®çš„å±å¹•èŒƒå›´
        zoomToPreview();
    });
};

const toggleAdaptive = () => {
    isAdaptive.value = !isAdaptive.value;
    if (isAdaptive.value && width.value > 0) {
        height.value = Math.round(width.value / currentTargetRatio.value);
        updatePreviewBox();
    }
};

// èƒŒæ™¯é¢œè‰²å¤„ç†
const setBgColor = (color) => {
    currentBgColor.value = color;
    updatePreviewBox();
};

const onCustomColorChange = (e) => {
    currentBgColor.value = e.target.value;
    updatePreviewBox();
};

// ç›‘å¬è¾“å…¥
watch([width, height], ([newW, newH]) => {
    if (isInternalUpdate.value) return;
    // å¦‚æœå¼€å¯äº†é”å®šæ¯”ä¾‹ (è¾“å…¥Wè‡ªåŠ¨ç®—H)
    if (isAdaptive.value) {
        // ç®€å•çš„é˜²æ­¢æ­»å¾ªç¯é€»è¾‘
        // å®é™…ä¸šåŠ¡ä¸­é€šå¸¸åªåœ¨ä¸€ä¸ªæ–¹å‘è¾“å…¥æ—¶è§¦å‘å¦ä¸€ä¸ªï¼Œè¿™é‡Œç®€åŒ–ä¸ºchangeè§¦å‘updatePreview
    }
    updatePreviewBox();
});

const onInputChanged = (type) => {
    // 1. å¦‚æœå¼€å¯äº†â€œé”å®šæ¯”ä¾‹â€ (isAdaptive) ä¸”æœ‰åŸå§‹æ¯”ä¾‹æ•°æ®
    if (isAdaptive.value && originalRatio.value) {

        // æ ‡è®°ä¸ºå†…éƒ¨æ›´æ–°ï¼Œé˜²æ­¢è§¦å‘ watch å¯¼è‡´æ­»å¾ªç¯æˆ–å¤šä½™è®¡ç®—
        isInternalUpdate.value = true;

        // æ ¹æ®è¾“å…¥çš„ç±»å‹è¿›è¡Œæ¢ç®—
        // originalRatio = å®½ / é«˜

        if (type === 'w' && width.value > 0) {
            // ç”¨æˆ·æ”¹äº†ã€å®½åº¦ã€‘ -> è‡ªåŠ¨ç®—ã€é«˜åº¦ã€‘
            // å…¬å¼: Height = Width / Ratio
            height.value = Math.round(width.value / originalRatio.value);

        } else if (type === 'h' && height.value > 0) {
            // ç”¨æˆ·æ”¹äº†ã€é«˜åº¦ã€‘ -> è‡ªåŠ¨ç®—ã€å®½åº¦ã€‘
            // å…¬å¼: Width = Height * Ratio
            width.value = Math.round(height.value * originalRatio.value);
        }

        // è®¡ç®—å¹¶èµ‹å€¼å®Œæˆåï¼Œåœ¨ä¸‹ä¸€ä¸ª tick é‡Šæ”¾é”
        nextTick(() => {
            isInternalUpdate.value = false;
        });
    }

    // 2. å®æ—¶æ›´æ–°ç”»å¸ƒä¸Šçš„é¢„è§ˆæ¡†
    updatePreviewBox();
};

const updatePreviewBox = () => {
    if (width.value > 0 && height.value > 0) {
        updatePreview(width.value, height.value, currentBgColor.value);
    } else {
        stopPreview();
    }
};

// ç›‘å¬é¢æ¿å±•å¼€
watch(() => props.isExpanded, (val) => {
    if (val) initSize();
    else stopPreview();
});

const handleApply = async () => {
    // 1. ç­‰å¾…å›¾ç‰‡å¤„ç†å®Œå…¨ç»“æŸ (æ–°å›¾ä¸Šå±ï¼ŒçŠ¶æ€é‡ç½®å®Œæˆ)
    await applyWhitePadding(width.value, height.value, currentBgColor.value);

    // 2. åªæœ‰å¤„ç†å®Œäº†ï¼Œæ‰é€šçŸ¥çˆ¶ç»„ä»¶å…³é—­é¢æ¿
    // æ­¤æ—¶ isExpanded å˜ false è§¦å‘ watcher é‡Œçš„ stopPreview
    // ä½†å› ä¸º originalTransform å·²ç»è¢«ç½®ç©ºï¼ŒstopPreview ä¸ä¼šäº§ç”Ÿä»»ä½•å‰¯ä½œç”¨
    emit('toggle');
};

const handleCancel = () => {
    stopPreview();
    emit('toggle');
}

const handleToggle = () => emit('toggle');

onMounted(() => {
    if (props.isExpanded) initSize();
});

onUnmounted(() => stopPreview());
</script>

<style scoped>
/* ç»§æ‰¿å¹¶å¤ç”¨äº†å¤§éƒ¨åˆ† AdjustResize çš„æ ·å¼ */
.preset-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 16px;
    max-height: 280px;
    overflow-y: auto;
}

.preset-item {
    background-color: #f5f7fa;
    padding: 10px;
    border-radius: 6px;
    font-size: 13px;
    color: #606266;
    cursor: pointer;
    border: 1px solid transparent;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    text-align: center;
    transition: all 0.2s;
}

.preset-item:hover {
    background-color: #e6f7ff;
    border-color: #c0c4cc;
}

.preset-item.active {
    background-color: #ecf5ff;
    color: var(--ie-primary-color);
    border-color: var(--ie-primary-color);
    font-weight: 500;
}

.custom-item {
    flex-direction: row;
    grid-column: span 2;
    background-color: #fff;
    border: 1px dashed #dcdfe6;
}

.custom-item.active {
    border-style: solid;
}

.preset-name {
    font-weight: 500;
    margin-bottom: 2px;
}

.preset-dim {
    font-size: 11px;
    color: #909399;
}

.resize-input-box {
    background-color: #fff;
    padding: 4px 0;
}

.input-controls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;
}

.input-wrapper {
    position: relative;
    width: 40%;
}

.ie-input {
    text-align: center;
    padding-right: 20px;
    font-weight: bold;
    color: #333;
    width: 100%;
    border: 1px solid #dcdfe6;
    border-radius: 4px;
    height: 32px;
    font-size: 13px;
}

.ie-input:focus {
    border-color: var(--ie-primary-color);
    outline: none;
}

.suffix {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    color: #c0c4cc;
    font-size: 11px;
    pointer-events: none;
}

.link-icon-btn {
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
}

.link-icon-btn:hover {
    background-color: #f0f0f0;
}

/* é¢œè‰²é€‰æ‹©å™¨æ ·å¼ */
.bg-color-section {
    margin-bottom: 16px;
}

.section-label {
    font-size: 12px;
    color: #606266;
    margin-bottom: 8px;
}

.color-row {
    display: flex;
    gap: 12px;
}

.color-item {
    width: 28px;
    height: 28px;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    border: 2px solid transparent;
    transition: all 0.2s;
}

.color-item.active {
    border-color: var(--ie-primary-color);
    transform: scale(1.1);
}

.checkerboard {
    background-image:
        linear-gradient(45deg, #ccc 25%, transparent 25%),
        linear-gradient(-45deg, #ccc 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #ccc 75%),
        linear-gradient(-45deg, transparent 75%, #ccc 75%);
    background-size: 8px 8px;
    background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
    background-color: #fff;
}

.color-picker-wrap {
    background: linear-gradient(to bottom right, #ff0000, #00ff00, #0000ff);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    position: relative;
    overflow: hidden;
}

.native-color-input {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
}


.action-buttons {
    display: flex;
    gap: 10px;
}

.full {
    flex: 1;
}

.tool-item:hover .arrow {
    transform: translateX(2px);
    transition: transform 0.2s;
}

.tool-content {
    padding: 16px;
    border: 1px solid #eee;
    border-top: none;
}
</style>
</file>

<file path="src/components/modules/adjust/useCanvasRuler.js">
import { ref, unref } from 'vue';
import { fabric } from 'fabric';
import { useEditorState } from '@/composables/useEditorState';

// === æ¨¡å—çº§å•ä¾‹çŠ¶æ€ ===
let canvasRef = null;
let saveHistoryFn = null;
const { state } = useEditorState();

export const DASH_OPTIONS = [
    { label: 'å®çº¿', value: [], icon: 'solid' },
    { label: 'é•¿è™šçº¿', value: [15, 15], icon: 'long-dash' },
    { label: 'çŸ­è™šçº¿', value: [5, 5], icon: 'short-dash' },
    { label: 'ç–ç‚¹çº¿', value: [0, 8], strokeLineCap: 'round' }, 
    { label: 'å¯†ç‚¹çº¿', value: [0, 4], strokeLineCap: 'round' },
    { label: 'ç‚¹åˆ’çº¿', value: [15, 5, 0, 5], strokeLineCap: 'round' } 
];

export const CAP_STYLES = [
    { id: 'line', label: 'çŸ­çº¿' },
    { id: 'arrow', label: 'å¤–å‘ç®­å¤´' },
    { id: 'arrow_in', label: 'å†…å‘ç®­å¤´' },
    { id: 'dot', label: 'åœ†ç‚¹' },
    { id: 'none', label: 'æ— ' }
];

const isDrawing = ref(false);
const rulerConfig = ref({
    value: 20,
    unit: 'cm',
    color: '#ff0000',
    opacity: 100,
    fontSize: 24,
    fontFamily: 'Arial',
    strokeWidth: 4,
    showBg: true,
    capStyle: 'line',    
    dashArray: [],       
    strokeLineCap: 'butt'
});

export const registerRulerModule = (canvas, saveHistory) => {
    canvasRef = canvas;
    saveHistoryFn = saveHistory;

    const c = unref(canvas);
    if (c) {
        c.off('selection:created', onSelectionChanged);
        c.off('selection:updated', onSelectionChanged);
        c.on('selection:created', onSelectionChanged);
        c.on('selection:updated', onSelectionChanged);
    }
};

const createCap = (type, color, strokeWidth) => {
    const size = 10 + strokeWidth; 
    if (type === 'arrow' || type === 'arrow_in') {
        return new fabric.Triangle({
            width: size, height: size, fill: color,
            originX: 'center', originY: 'center', selectable: false
        });
    } else if (type === 'dot') {
        return new fabric.Circle({
            radius: strokeWidth * 1.5, fill: color,
            originX: 'center', originY: 'center', selectable: false
        });
    } else if (type === 'line') {
        return new fabric.Line([0, -size, 0, size], {
            stroke: color, strokeWidth: strokeWidth,
            originX: 'center', originY: 'center', selectable: false
        });
    } else {
        return new fabric.Rect({ width: 0, height: 0, visible: false });
    }
};

const createRulerObject = (start, end) => {
    const canvas = unref(canvasRef);
    const cfg = rulerConfig.value;
    
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
    const midX = (start.x + end.x) / 2;
    const midY = (start.y + end.y) / 2;
    const halfLen = length / 2;

    const line = new fabric.Line([-halfLen, 0, halfLen, 0], {
        stroke: cfg.color, strokeWidth: cfg.strokeWidth,
        strokeDashArray: cfg.dashArray, strokeLineCap: cfg.strokeLineCap || 'butt',
        originX: 'center', originY: 'center'
    });

    const startCap = createCap(cfg.capStyle, cfg.color, cfg.strokeWidth);
    const endCap = createCap(cfg.capStyle, cfg.color, cfg.strokeWidth);
    startCap.set({ left: -halfLen, top: 0 });
    endCap.set({ left: halfLen, top: 0 });
    
    const updateCapRotation = (cap, isStart) => {
        if (cfg.capStyle.includes('arrow')) {
            let rot = 90;
            if (cfg.capStyle === 'arrow') rot = isStart ? -90 : 90;
            else rot = isStart ? 90 : -90;
            cap.set({ angle: rot });
        } else { cap.set({ angle: 0 }); }
    };
    updateCapRotation(startCap, true);
    updateCapRotation(endCap, false);

    const textObj = new fabric.Text(`${cfg.value} ${cfg.unit}`, {
        fontSize: cfg.fontSize, fill: cfg.color, fontFamily: cfg.fontFamily,
        backgroundColor: cfg.showBg ? 'rgba(255,255,255,0.8)' : '',
        originX: 'center', originY: 'bottom', left: 0, top: -10
    });
    if (Math.abs(angle) > 90) textObj.set({ angle: 180, originY: 'bottom', top: 10 });

    const group = new fabric.Group([line, startCap, endCap, textObj], {
        left: midX, top: midY, angle: angle,
        originX: 'center', originY: 'center', opacity: cfg.opacity / 100,
        customTab: 'ruler', customTool: 'adjust', isRuler: true,
        _rulerValue: cfg.value, _rulerUnit: cfg.unit,
        _capStyle: cfg.capStyle, _dashArray: cfg.dashArray, _strokeLineCap: cfg.strokeLineCap,
        lockScalingY: true, lockUniScaling: true,
        hoverCursor: 'move' // âœ¨ ç¡®ä¿å¯¹è±¡è‡ªèº«çš„æ‚¬åœå½¢æ€
    });

    group.setControlsVisibility({ mtr: true, ml: true, mr: true, mt:false, mb:false, tl:false, tr:false, bl:false, br:false });
    canvas.add(group);
    
    if (saveHistoryFn) saveHistoryFn();
    return group;
};

const recreateActiveRuler = (activeGroup) => {
    const canvas = unref(canvasRef);
    const center = activeGroup.getCenterPoint();
    const lineObj = activeGroup.getObjects()[0];
    const currentWidth = lineObj.width * activeGroup.scaleX;
    const angleRad = fabric.util.degreesToRadians(activeGroup.angle);
    const dx = (currentWidth / 2) * Math.cos(angleRad);
    const dy = (currentWidth / 2) * Math.sin(angleRad);
    const start = { x: center.x - dx, y: center.y - dy };
    const end = { x: center.x + dx, y: center.y + dy };
    
    canvas.remove(activeGroup);
    const newGroup = createRulerObject(start, end);
    canvas.setActiveObject(newGroup);
    canvas.requestRenderAll();
};

export const updateActiveRuler = () => {
    const canvas = unref(canvasRef);
    if (!canvas) return;
    const group = canvas.getActiveObject();
    if (!group || !group.isRuler) return;

    const cfg = rulerConfig.value;
    const needsRebuild = (group._capStyle !== cfg.capStyle) || (group.getObjects()[3].fontSize !== cfg.fontSize);

    if (needsRebuild) {
        recreateActiveRuler(group);
    } else {
        const items = group.getObjects(); 
        items[0].set({
            stroke: cfg.color, strokeWidth: cfg.strokeWidth,
            strokeDashArray: cfg.dashArray, strokeLineCap: cfg.strokeLineCap || 'butt'
        });
        items[1].set({ fill: cfg.color, stroke: cfg.color });
        items[2].set({ fill: cfg.color, stroke: cfg.color });
        items[3].set({
            text: `${cfg.value} ${cfg.unit}`, fill: cfg.color,
            backgroundColor: cfg.showBg ? 'rgba(255,255,255,0.8)' : ''
        });
        group.set({ opacity: cfg.opacity / 100 });
        group._rulerValue = cfg.value;
        group._rulerUnit = cfg.unit;
        group._dashArray = cfg.dashArray;
        group._strokeLineCap = cfg.strokeLineCap;

        canvas.requestRenderAll();
        if (saveHistoryFn) saveHistoryFn();
    }
};

const onSelectionChanged = (e) => {
    if (isDrawing.value) return;
    const activeObj = e.selected?.[0];
    syncConfigFromObject(activeObj);
};

export const syncConfigFromActiveSelection = () => {
    const canvas = unref(canvasRef);
    const activeObj = canvas?.getActiveObject();
    syncConfigFromObject(activeObj);
    return activeObj;
};

const syncConfigFromObject = (activeObj) => {
    if (activeObj && activeObj.isRuler) {
        const items = activeObj.getObjects();
        rulerConfig.value.value = activeObj._rulerValue ?? 20;
        rulerConfig.value.unit = activeObj._rulerUnit ?? 'cm';
        rulerConfig.value.opacity = (activeObj.opacity || 1) * 100;
        rulerConfig.value.capStyle = activeObj._capStyle || 'line'; 
        rulerConfig.value.dashArray = activeObj._dashArray || [];
        rulerConfig.value.strokeLineCap = activeObj._strokeLineCap || 'butt';
        if (items[0]) {
            rulerConfig.value.color = items[0].stroke;
            rulerConfig.value.strokeWidth = items[0].strokeWidth;
        }
        if (items[3]) {
            rulerConfig.value.fontSize = items[3].fontSize;
            rulerConfig.value.showBg = !!items[3].backgroundColor;
        }
    }
};

let startPoint = null;
let activeLine = null;

const onKeyDown = (e) => {
    if (e.key === 'Escape' || e.key === 'Esc') {
        stopRulerMode();
    }
};

const onMouseDown = (opt) => {
    const canvas = unref(canvasRef);
    if (!canvas || state.isGlobalDragMode) return;

    if (opt.target && opt.target.isRuler) {
        canvas.setActiveObject(opt.target);
        return;
    }

    if (!opt.target) {
        const pointer = canvas.getPointer(opt.e);
        startPoint = { x: pointer.x, y: pointer.y };
        
        activeLine = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], {
            stroke: rulerConfig.value.color,
            strokeWidth: rulerConfig.value.strokeWidth,
            selectable: true, 
            evented: true,
            isRuler: true
        });
        
        canvas.add(activeLine);
        canvas.on('mouse:move', onMouseMove);
        canvas.on('mouse:up', onMouseUp);
    }
};

const onMouseMove = (opt) => {
    if (!activeLine) return;
    const canvas = unref(canvasRef);
    const pointer = canvas.getPointer(opt.e);
    activeLine.set({ x2: pointer.x, y2: pointer.y });
    canvas.requestRenderAll();
};

const onMouseUp = () => {
    const canvas = unref(canvasRef);
    canvas.off('mouse:move', onMouseMove);
    canvas.off('mouse:up', onMouseUp);
    
    if (!activeLine) return;
    const endPoint = { x: activeLine.x2, y: activeLine.y2 };
    canvas.remove(activeLine);
    activeLine = null;
    
    const dist = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));
    if (dist > 10) {
        createRulerObject(startPoint, endPoint);
    }
};

export const startRulerMode = (canvas) => {
    canvasRef = canvas;
    const c = unref(canvas);
    if (!c) return;
    
    c.on('mouse:down', onMouseDown);
    window.addEventListener('keydown', onKeyDown);
    // âœ¨ å…‰æ ‡ç”± useCanvasLock ç»Ÿä¸€ç®¡ç†ï¼Œæ— éœ€æ­¤å¤„æ‰‹åŠ¨è®¾ç½®
};

export const stopRulerMode = () => {
    const c = unref(canvasRef);
    if (!c) return;
    c.off('mouse:down', onMouseDown);
    c.off('mouse:move', onMouseMove);
    c.off('mouse:up', onMouseUp);
    window.removeEventListener('keydown', onKeyDown);
};

export { rulerConfig, isDrawing };
</file>

<file path="src/components/panels/ToolPanel.vue">
<template>
  <div class="tool-panel">
    <component :is="currentModule" />

    <Modal v-model="showPuzzleConfirm" cancel-text="ä¸ä¿å­˜" confirm-text="ä¿å­˜" @confirm="handleConfirmExit(true)"
      @discard="handleConfirmExit(false)" @cancel="handleCancelExit"
      />
  </div>
</template>

<script setup>
import { computed, defineAsyncComponent, ref, watch, inject } from 'vue';
import { useEditorState } from '../../composables/useEditorState';
import Modal from '../common/Modal.vue';
import { completeExitPuzzle } from '../modules/puzzle/useCanvasPuzzle';

const { state, setActiveTool, setPuzzleMode } = useEditorState();

// å†…éƒ¨é©±åŠ¨ UI çš„å·¥å…·çŠ¶æ€
const localActiveTool = ref(state.activeTool);
const showPuzzleConfirm = ref(false);
let pendingTool = null; // è®°å½•ç”¨æˆ·ç‚¹å‡»çš„ç›®æ ‡å·¥å…·

// åŠ¨æ€æ˜ å°„è¡¨ä¿æŒä¸å˜
const modules = {
  adjust: defineAsyncComponent(() => import('../modules/adjust/index.vue')),
  draw: defineAsyncComponent(() => import('../modules/draw/index.vue')),
  text: defineAsyncComponent(() => import('../modules/text/index.vue')),
  border: defineAsyncComponent(() => import('../modules/border/index.vue')),
  material: defineAsyncComponent(() => import('../modules/material/index.vue')),
  watermark: defineAsyncComponent(() => import('../modules/watermark/index.vue')),
  puzzle: defineAsyncComponent(() => import('../modules/puzzle/index.vue')),
  ai: defineAsyncComponent(() => import('../modules/ai/index.vue')),
};

const currentModule = computed(() => {
  return modules[localActiveTool.value] || modules['adjust'];
});

// === æ ¸å¿ƒé€»è¾‘ï¼šæ‹¦æˆªåˆ‡æ¢ ===
watch(() => state.activeTool, (newTool, oldTool) => {
  // å¦‚æœä»æ‹¼å›¾æ¨¡å—åˆ‡å¾€åˆ«çš„æ¨¡å—
  if (oldTool === 'puzzle' && state.isPuzzleMode) {
    pendingTool = newTool; // è®°ä½æƒ³å»çš„åœ°æ–¹
    showPuzzleConfirm.value = true; // å¼¹å‡ºæç¤º

    setActiveTool('puzzle');
  } else {
    // æ™®é€šåˆ‡æ¢ç›´æ¥åŒæ­¥
    localActiveTool.value = newTool;
  }
});

// å¤„ç†å¼¹çª—ç‚¹å‡»
const handleConfirmExit = (isSave) => {
  // è°ƒç”¨ useCanvasPuzzle æä¾›çš„æœ€ç»ˆé€€å‡ºå‡½æ•°
  completeExitPuzzle(isSave ? 'save' : 'discard');

  showPuzzleConfirm.value = false;

  if (pendingTool) {
    // ç¡®è®¤åï¼Œæ‰§è¡ŒçœŸæ­£çš„å…¨å±€è·³è½¬
    setActiveTool(pendingTool);
    localActiveTool.value = pendingTool;
    pendingTool = null;
  }

  setPuzzleMode(false);
};

const handleCancelExit = () => {
  showPuzzleConfirm.value = false;
  pendingTool = null;
};
</script>

<style scoped>
.tool-panel {
  background: #fff;
  border-right: 1px solid #e4e7ed;
  height: 100%;
  overflow-y: auto;
}
</style>
</file>

<file path="vite.config.js">
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import dts from 'vite-plugin-dts'
import { fileURLToPath, URL } from 'node:url'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    vue(),
    // 2. é…ç½®æ’ä»¶
    dts({
      outDir: 'dist',
      // ç¡®ä¿åªä¸ºæºç ç”Ÿæˆç±»å‹
      include: ['src/**/*.js', 'src/**/*.vue'],
      // è‡ªåŠ¨å°è¯•ç”Ÿæˆ vue æ–‡ä»¶çš„ç±»å‹å®šä¹‰
      // ç¡®ä¿ç”Ÿæˆçš„ .d.ts æ–‡ä»¶è·¯å¾„æ¸…æ™°
      insertTypesEntry: true,
    })
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  build: {
    lib: {
      entry: resolve(__dirname, 'src/index.js'),
      name: 'ImageEditor',
      fileName: 'image-editor'
    },
    rollupOptions: {
      external: ['vue'],
      output: {
        globals: {
          vue: 'Vue'
        },
        assetFileNames: (assetInfo) => {
          if (assetInfo.name === 'style.css') return 'index.css';
          return assetInfo.name;
        },
        exports: 'named'
      }
    },
    cssCodeSplit: false
  }
})
</file>

<file path="src/components/modules/adjust/AdjustInpaint.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="$emit('toggle')">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34"></path>
          <polygon points="18 2 22 6 12 16 8 16 8 12 18 2"></polygon>
        </svg>
        <span>æ™ºèƒ½æ¶ˆé™¤ç¬”</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">
      
      <div class="mode-row">
        <div 
          class="mode-btn" 
          :class="{ active: drawMode === 'brush' }" 
          @click="drawMode = 'brush'" 
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 13.29C18 16.54 15.6 19 12 19s-6-2.46-6-5.71c0-2.83 2-6.29 6-9.29 4 3 6 6.46 6 9.29z"></path>
            <path d="M12 19v2"></path>
          </svg>
          <span class="mode-label">æ¶‚æŠ¹</span>
        </div>
        
        <div 
          class="mode-btn" 
          :class="{ active: drawMode === 'rect' }" 
          @click="drawMode = 'rect'" 
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          </svg>
          <span class="mode-label">æ¡†é€‰</span>
        </div>
      </div>

      <div class="control-section">
        <div v-if="drawMode === 'brush'">
          <div class="label-row">
            <span>ç”»ç¬”å¤§å°</span>
            <input 
              type="number" 
              v-model.number="brushSize" 
              class="ie-input-number"
              min="5"
              max="100"
            >
          </div>
          <input 
            type="range" 
            v-model.number="brushSize" 
            min="5" 
            max="100" 
            class="ie-slider"
          >
          <div class="auto-tip">
             ğŸ’¡ æ¶‚æŠ¹ç»“æŸ 1ç§’åè‡ªåŠ¨æ¶ˆé™¤
          </div>
        </div>

        <div v-else class="tips-box">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:4px; min-width:14px">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          </svg>
          <span>æ‹–æ‹½æ¡†é€‰ï¼Œæ¾æ‰‹åè‡ªåŠ¨æ¶ˆé™¤åŒºåŸŸå†…å®¹ã€‚</span>
        </div>
      </div>

      <div class="action-buttons">
        <button class="ie-btn full" @click="handleRestoreOriginal">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:6px">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
            <path d="M3 3v5h5"></path>
          </svg>
          æ¢å¤åŸå›¾
        </button>
      </div>

    </div>
  </div>
</template>

<script setup>
import { ref, inject, watch, onMounted, onUnmounted } from 'vue';
import { 
  registerInpaintModule, 
  enterInpaintMode, 
  exitInpaintMode, 
  handleRestoreOriginal,
  brushSize, 
  drawMode 
} from './useCanvasInpaint';

const props = defineProps({
  isExpanded: Boolean
});

const emit = defineEmits(['toggle']);
const canvasAPI = inject('canvasAPI');

onMounted(() => {
  if (canvasAPI?.canvas) {
    registerInpaintModule(canvasAPI.canvas, canvasAPI.saveHistory);
  }
});

watch(() => props.isExpanded, (expanded) => {
  if (expanded) {
    enterInpaintMode();
  } else {
    exitInpaintMode();
  }
});

onUnmounted(() => {
  exitInpaintMode();
});
</script>

<style scoped>
.mode-row { 
  display: flex; 
  gap: 12px; 
  margin-bottom: 20px; 
}

.mode-btn { 
  flex: 1; 
  height: 60px;
  display: flex; 
  flex-direction: column;
  align-items: center; 
  justify-content: center; 
  border-radius: 6px; 
  background: #f5f7fa; 
  cursor: pointer; 
  border: 1px solid transparent; 
  transition: all 0.2s; 
  color: #606266;
}

.mode-btn:hover {
  background: #eef1f6;
  color: #333;
}

.mode-btn.active { 
  background: #ecf5ff; 
  border-color: var(--ie-primary-color); 
  color: var(--ie-primary-color); 
  font-weight: 500;
}

.mode-label {
  font-size: 12px;
  margin-top: 4px;
}

.control-section {
  margin-bottom: 24px;
  min-height: 50px; 
}

.label-row { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; /* ç¡®ä¿å‚ç›´å¯¹é½ */
  font-size: 12px; 
  color: #606266; 
  margin-bottom: 8px; 
}

.tips-box {
  display: flex;
  align-items: flex-start;
  padding: 10px;
  background-color: #f4f4f5;
  border: 1px solid #e9e9eb;
  border-radius: 4px;
  font-size: 12px;
  color: #909399;
  line-height: 1.4;
}

.auto-tip {
  margin-top: 8px;
  font-size: 12px;
  color: var(--ie-primary-color); 
  text-align: center;
  background: #ecf5ff;
  padding: 4px;
  border-radius: 4px;
}

.action-buttons { 
  display: flex; 
  margin-top: auto;
}

.full { 
  flex: 1; 
  height: 36px;
}

.tool-content {
  padding: 16px;
}

/* === å¼ºåˆ¶ä¿®æ­£æ»‘å—ä¸»é¢˜è‰² === */
.ie-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--ie-primary-color);
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  margin-top: -6px;
}

.ie-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border: 2px solid white;
  border-radius: 50%;
  background: var(--ie-primary-color);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ie-slider::-webkit-slider-runnable-track {
  height: 4px;
  background: #e4e7ed;
  border-radius: 2px;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustRembg.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" @click="handleRembg">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
          <circle cx="6" cy="6" r="3" />
          <path d="M8.12 8.12 12 12" />
          <path d="M20 4 8.12 15.88" />
          <circle cx="6" cy="18" r="3" />
          <path d="M14.8 14.8 20 20" />
        </svg>
        <span>ä¸€é”®æŠ å›¾</span>
      </div>

      <div class="right-icon">
        <svg v-if="loading" class="loading-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 12a9 9 0 1 1-6.219-8.56" />
        </svg>
        <svg v-else class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, inject } from 'vue'; // ç¡®ä¿å¼•å…¥ inject
import { aiApi } from '@/api/ai';
import { toast } from '@/utils/toast';

const canvasAPI = inject('canvasAPI');
const config = inject('editorConfig'); // 1. è·å–å…¨å±€é…ç½®
const loading = ref(false);

const handleRembg = async () => {
  const activeObj = canvasAPI?.canvas.value?.getActiveObject();
  if (!activeObj || activeObj.type !== 'image') return toast.warning('è¯·å…ˆé€‰ä¸­å›¾ç‰‡');

  loading.value = true;
  try {
    const src = activeObj.getSrc();
    const blob = await (await fetch(src)).blob();

    // 2. è°ƒç”¨ API æ—¶ä¼ å…¥é…ç½®ä¸­çš„ baseUrl
    // å¦‚æœ config ä¸ºç©ºï¼ˆå•ç‹¬ä½¿ç”¨ç»„ä»¶æ—¶ï¼‰ï¼Œapi å†…éƒ¨ä¼šä½¿ç”¨é»˜è®¤å€¼
    const newUrl = await aiApi.removeBackground(
      new File([blob], "img.png"),
      config?.aiBaseUrl
    );

    canvasAPI.replaceActiveImage(newUrl);
    toast.success('æŠ å›¾å®Œæˆ');
  } catch (e) {
    console.error(e);
    toast.error('æŠ å›¾å¤±è´¥');
  } finally {
    loading.value = false;
  }
};
</script>

<style scoped>
/* Loading æ—‹è½¬åŠ¨ç”» */
.loading-icon {
  animation: rotating 1s linear infinite;
  color: var(--ie-primary-color);
}

@keyframes rotating {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}

/* ç®€å•çš„ hover åŠ¨ç”» */
.tool-item:hover .arrow {
  transform: translateX(2px);
  transition: transform 0.2s;
}
</style>
</file>

<file path="src/main.js">
import { createApp } from 'vue'
import './style.css' // ç¡®ä¿è¿™é‡Œå¼•å…¥äº†æˆ‘ä»¬æ–°å†™çš„é€šç”¨ CSS (åŒ…å« .ie-btn ç­‰æ ·å¼)
import App from './App.vue'
import { applyTheme } from './config/theme.js';
// 1. åˆ›å»º Vue å®ä¾‹
const app = createApp(App)

// 2. åº”ç”¨ä¸»é¢˜
applyTheme();


// 3. æŒ‚è½½
app.mount('#app')
</file>

<file path="package.json">
{
  "name": "image-editor-sdk",
  "version": "1.0.0",
  "type": "module",
  "types": "./dist/index.d.ts",
  "main": "./dist/image-editor.umd.cjs",
  "module": "./dist/image-editor.js",
  "files": ["dist"],
  "exports": {
    ".": {
      "import": "./dist/image-editor.js",
      "require": "./dist/image-editor.umd.cjs"
    },
    "./style.css": "./dist/index.css"
  },
  "scripts": {
    "dev": "vite --host 0.0.0.0",
    "build": "vite build",
    "preview": "vite preview",
    "npx": "npx repomix"
  },
  "dependencies": {
    "fabric": "^5.3.0",
    "file-saver": "^2.0.5"
  },
  "peerDependencies": {
    "vue": "^3.3.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.1",
    "vite": "^7.2.4",
    "vite-plugin-dts": "^4.5.4"
  }
}
</file>

<file path="src/components/modules/puzzle/useCanvasPuzzle.js">
// src/components/modules/puzzle/useCanvasPuzzle.js
import { unref, reactive, toRaw } from "vue";
import { fabric } from "fabric";
import { parseTemplateToCells, generateGridCells } from "./config";
import { constrainObjectToRect, animateRebound } from '@/composables/useConstraint';

// === å†…éƒ¨å˜é‡ ===
let canvasRef = null;
let saveHistoryFn = null;
let zoomToRectFn = null;
let uiCallbacks = { onCellClick: null, onImageSelect: null, onDeselect: null };
let prePuzzleSnapshot = null;

// Snapshot variables for the "Cancel" feature
let snapshotBeforeLayout = null;
let stateBackup = null;

// äº¤äº’çŠ¶æ€
let isDragging = false;
let dragOriginPoint = null;
let dragLastPoint = { x: 0, y: 0 };
let dragProxy = null;
let dragOriginCellIndex = -1;
let dragOffset = { x: 0, y: 0 };
let isCreatingProxy = false;

// é»˜è®¤é…ç½®
const DEFAULTS = {
  padding: 0,
  spacing: 10,
  radius: 0,
  width: 1000,
  height: 1000,
  bgColor: '#ffffff',
  rows: 1,
  cols: 1
};

const puzzleState = reactive({
  isActive: false,
  cells: [],
  padding: DEFAULTS.padding,
  spacing: DEFAULTS.spacing,
  radius: DEFAULTS.radius,
  width: DEFAULTS.width,
  height: DEFAULTS.height,
  bgColor: DEFAULTS.bgColor,
  startX: 0,
  startY: 0,
  originalBg: null,
  rawCells: [] // å­˜å‚¨åŸå§‹æ ¼å­å®šä¹‰
});

export const registerPuzzleModule = (canvas, saveHistory, callbacks = {}, zoomToRect = null) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
  uiCallbacks = { ...uiCallbacks, ...callbacks };
  zoomToRectFn = zoomToRect;
};

// === æ–°å¢ï¼šä¿å­˜é€‰æ‹©ç½‘æ ¼å‰çš„çŠ¶æ€ ===
export const saveSnapshotBeforeLayout = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;
  // 1. Save Canvas visual state (includes images, text, existing puzzle items)
  snapshotBeforeLayout = JSON.stringify(canvas.toJSON(["id", "selectable", "name", "isPuzzleItem", "cellIndex", "isPuzzleController", "isPuzzleBackground", "originalSrc"]));
  // 2. Save Reactive State (grid config, padding, spacing)
  stateBackup = JSON.parse(JSON.stringify(toRaw(puzzleState)));
};

// === æ–°å¢ï¼šæ¢å¤é€‰æ‹©ç½‘æ ¼å‰çš„çŠ¶æ€ ===
export const restoreSnapshotBeforeLayout = () => {
  const canvas = unref(canvasRef);
  if (!canvas || !snapshotBeforeLayout) return;

  // 1. Restore Canvas objects
  canvas.loadFromJSON(snapshotBeforeLayout, () => {
    // 2. Restore Reactive State
    if (stateBackup) {
      Object.assign(puzzleState, stateBackup);
    }
    
    // 3. Reset interactions
    unbindEvents(); // Prevent double binding
    bindEvents();
    
    canvas.requestRenderAll();
    if (saveHistoryFn) saveHistoryFn();
  });
};

export const zoomToPuzzleArea = () => {
  if (!zoomToRectFn) return;
  const rect = {
    left: puzzleState.startX,
    top: puzzleState.startY,
    width: puzzleState.width,
    height: puzzleState.height
  };
  zoomToRectFn(rect);
};

export const initPuzzleMode = (initialTemplate = null) => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  puzzleState.originalBg = canvas.backgroundColor;
  prePuzzleSnapshot = JSON.stringify(canvas.toJSON(["id", "selectable", "name"]));

  if (puzzleState.savedHistoryData && puzzleState.savedHistoryData.length > 0) {
    restorePuzzleData();
    bindEvents();
    return;
  }

  puzzleState.isActive = true;

  const activeImg = canvas.getObjects().find(o => o.type === 'image');
  if (activeImg) {
    const rect = activeImg.getBoundingRect();
    puzzleState.width = rect.width;
    puzzleState.height = rect.height;
    puzzleState.startX = rect.left;
    puzzleState.startY = rect.top;
  } else {
    const center = canvas.getCenter();
    puzzleState.width = 1000;
    puzzleState.height = 1000;
    puzzleState.startX = center.left - 500;
    puzzleState.startY = center.top - 500;
  }

  bindEvents();

  const cells = initialTemplate ? parseTemplateToCells(initialTemplate) : generateGridCells(DEFAULTS.rows, DEFAULTS.cols);
  updateLayout(cells);

  zoomToPuzzleArea();
};

export const completeExitPuzzle = (action = 'save') => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  const savedVpt = canvas.viewportTransform ? [...canvas.viewportTransform] : [1, 0, 0, 1, 0, 0];

  exitPuzzleMode();

  if (action === 'save') {
    const hiddenObjs = canvas.getObjects().filter(o =>
      o.isPuzzleController || o.isPlaceholder || o.isGhost || o.isPuzzleBackground
    );
    hiddenObjs.forEach(o => o.visible = false);

    canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
    canvas.renderAll();

    const dataURL = canvas.toDataURL({
      format: 'png', quality: 1, multiplier: 2,
      left: puzzleState.startX, top: puzzleState.startY,
      width: puzzleState.width, height: puzzleState.height
    });

    const allPuzzleObjs = canvas.getObjects().filter(o => o.isPuzzleItem);
    canvas.remove(...allPuzzleObjs);

    fabric.Image.fromURL(dataURL, (img) => {
      img.set({
        left: puzzleState.startX, top: puzzleState.startY,
        originX: 'left', originY: 'top',
        selectable: true
      });
      img.scaleToWidth(puzzleState.width);
      canvas.add(img);
      canvas.setViewportTransform(savedVpt);
      if (saveHistoryFn) saveHistoryFn();
      canvas.requestRenderAll();
    }, { crossOrigin: 'anonymous' });

  } else {
    if (prePuzzleSnapshot) {
      canvas.loadFromJSON(prePuzzleSnapshot, () => {
        canvas.setViewportTransform(savedVpt);
        if (puzzleState.originalBg !== null) {
          canvas.setBackgroundColor(puzzleState.originalBg, () => canvas.requestRenderAll());
        } else {
          canvas.requestRenderAll();
        }
      });
    }
  }
};

export const resetPuzzle = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  puzzleState.padding = DEFAULTS.padding;
  puzzleState.spacing = DEFAULTS.spacing;
  puzzleState.radius = DEFAULTS.radius;
  puzzleState.bgColor = DEFAULTS.bgColor;

  const defaultCells = generateGridCells(DEFAULTS.rows, DEFAULTS.cols);
  updateLayout(defaultCells);
  zoomToPuzzleArea();

  if (saveHistoryFn) saveHistoryFn();
};

export const exitPuzzleMode = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  puzzleState.isActive = false;

  if (puzzleState.originalBg !== null) {
    canvas.setBackgroundColor(puzzleState.originalBg, () => canvas.requestRenderAll());
  }

  unbindEvents();
};

export const restorePuzzleData = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  const historyData = puzzleState.savedHistoryData;
  const savedSettings = puzzleState.savedSettings;

  if (!historyData || historyData.length === 0) return;

  if (savedSettings) {
    puzzleState.width = savedSettings.width;
    puzzleState.height = savedSettings.height;
    puzzleState.padding = savedSettings.padding;
    puzzleState.spacing = savedSettings.spacing;
    puzzleState.radius = savedSettings.radius;
    if (savedSettings.bgColor) {
      puzzleState.bgColor = savedSettings.bgColor;
    }
  }

  let loadedCount = 0;

  historyData.forEach(item => {
    fabric.Image.fromURL(item.src, (img) => {
      loadedCount++;

      img.set({
        id: item.id,
        left: item.left,
        top: item.top,
        scaleX: item.scaleX,
        scaleY: item.scaleY,
        angle: item.angle,
        flipX: item.flipX,
        flipY: item.flipY,
        cropX: item.cropX,
        cropY: item.cropY,
        originX: item.originX || 'center',
        originY: item.originY || 'center',
        cellIndex: item.cellIndex,
        isPuzzleItem: true,
        isPuzzleImage: true,
        originalSrc: item.src,
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
      });

      canvas.add(img);

      if (loadedCount === historyData.length) {
        puzzleState.isActive = true;
        refreshPuzzleObjects(false);
        zoomToPuzzleArea();
        canvas.requestRenderAll();
      }
    }, { crossOrigin: 'anonymous' });
  });
};

export const getPuzzleImageCount = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return 0;
  return canvas.getObjects().filter(o => o.isPuzzleImage && !o.isGhost && !o.isPuzzleBackground).length;
};

export const updatePuzzleImageParams = (cellIndex, params = {}) => {
  const canvas = unref(canvasRef);
  if (!canvas) return;

  const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === cellIndex);
  const cell = puzzleState.cells.find(c => c.index === cellIndex);
  
  if (img && cell) {
    if (params.opacity !== undefined) {
      img.set('opacity', params.opacity);
    }

    if (params.scale !== undefined) {
      const minScale = Math.max(cell.width / img.width, cell.height / img.height);
      let newScale = Math.max(minScale, params.scale); 
      
      img.set({ scaleX: newScale, scaleY: newScale });
      
      const containerRect = {
        left: cell.left, top: cell.top, width: cell.width, height: cell.height
      };
      constrainObjectToRect(img, containerRect, canvas);
    }
    canvas.requestRenderAll();
  }
};

const calculateFitPosition = (img, cell) => {
  const iW = img.width || 1;
  const iH = img.height || 1;
  const cW = Math.max(1, cell.width);
  const cH = Math.max(1, cell.height);

  const minScaleX = cW / iW;
  const minScaleY = cH / iH;
  const minScale = Math.max(minScaleX, minScaleY) + 0.0001;
  return {
    scaleX: minScale,
    scaleY: minScale,
    left: cell.left + cW / 2,
    top: cell.top + cH / 2
  };
};

const bindEvents = () => {
  const canvas = unref(canvasRef);
  canvas.on('mouse:down', onMouseDown);
  canvas.on('mouse:move', onMouseMove);
  canvas.on('mouse:up', onMouseUp);
  canvas.on('mouse:wheel', onMouseWheel);
};

const unbindEvents = () => {
  const canvas = unref(canvasRef);
  canvas.off('mouse:down', onMouseDown);
  canvas.off('mouse:move', onMouseMove);
  canvas.off('mouse:up', onMouseUp);
  canvas.off('mouse:wheel', onMouseWheel);
};

const onMouseDown = (opt) => {
  if (!puzzleState.isActive) return;
  const canvas = unref(canvasRef);
  const target = opt.target;

  dragOriginPoint = opt.absolutePointer;
  const pointer = canvas.getPointer(opt.e);
  dragLastPoint = { x: pointer.x, y: pointer.y };

  if (target && target.isPuzzleController) {
    isDragging = true;
    dragOriginCellIndex = target.cellIndex;
    canvas.setActiveObject(target);

    const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === target.cellIndex);
    if (img) {
      dragOffset = {
        x: img.left - pointer.x,
        y: img.top - pointer.y
      };
    } else {
      dragOffset = { x: 0, y: 0 };
    }

  } else {
    isDragging = false;
    dragOriginCellIndex = -1;
  }
};

const onMouseMove = (opt) => {
  if (!puzzleState.isActive || !isDragging || dragOriginCellIndex === -1) return;
  const canvas = unref(canvasRef);
  const pointer = canvas.getPointer(opt.e);
  const distFromStart = Math.sqrt(
    Math.pow(pointer.x - (dragOriginPoint?.x || 0), 2) +
    Math.pow(pointer.y - (dragOriginPoint?.y || 0), 2)
  );

  if (distFromStart < 5) return;

  const cell = puzzleState.cells.find(c => c.index === dragOriginCellIndex);
  if (!cell) return;

  const isInsideCell =
    pointer.x >= cell.left && pointer.x <= cell.left + cell.width &&
    pointer.y >= cell.top && pointer.y <= cell.top + cell.height;

  if (isInsideCell) {
    if (dragProxy) {
      canvas.remove(dragProxy);
      dragProxy = null;
      isCreatingProxy = false;
      const originImg = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === dragOriginCellIndex);
      if (originImg) originImg.set('opacity', 1);
    }
    const deltaX = pointer.x - dragLastPoint.x;
    const deltaY = pointer.y - dragLastPoint.y;
    const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === dragOriginCellIndex);
    if (img) {
      img.set({ left: img.left + deltaX, top: img.top + deltaY });
      img.setCoords();
    }
  } else {
    if (!dragProxy && !isCreatingProxy) {
      isCreatingProxy = true;
      createDragProxy(dragOriginCellIndex, pointer);
    }

    if (dragProxy) {
      dragProxy.set({
        left: pointer.x + dragOffset.x,
        top: pointer.y + dragOffset.y
      });
      dragProxy.setCoords();
    }
  }
  dragLastPoint = { x: pointer.x, y: pointer.y };
  canvas.requestRenderAll();
};

const createDragProxy = (cellIndex, pointer) => {
  const canvas = unref(canvasRef);
  const cell = puzzleState.cells.find(c => c.index === cellIndex);
  const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === cellIndex);

  if (!cell || !img) {
    isCreatingProxy = false;
    return;
  }

  img.set('opacity', 0.4);

  img.clone((cloned) => {
    dragProxy = cloned;

    if (pointer) {
      dragOffset = {
        x: img.left - pointer.x,
        y: img.top - pointer.y
      };
    }

    dragProxy.set({
      opacity: 0.8, evented: false, selectable: false,
      originX: 'center', originY: 'center',
      left: pointer ? pointer.x + dragOffset.x : img.left,
      top: pointer ? pointer.y + dragOffset.y : img.top,
      hasControls: false, hasBorders: false,
      stroke: '#409eff', strokeWidth: 2,
      isPuzzleImage: true,
      isGhost: true
    });

    const cellCenterX = cell.left + cell.width / 2;
    const cellCenterY = cell.top + cell.height / 2;
    const offsetX = (cellCenterX - img.left) / img.scaleX;
    const offsetY = (cellCenterY - img.top) / img.scaleY;

    const clipRect = new fabric.Rect({
      left: offsetX, top: offsetY,
      width: cell.width / img.scaleX, height: cell.height / img.scaleY,
      originX: 'center', originY: 'center',
      absolutePositioned: false
    });
    dragProxy.clipPath = clipRect;

    canvas.add(dragProxy);
    canvas.bringToFront(dragProxy);
    isCreatingProxy = false;
  });
};

const onMouseUp = (opt) => {
  if (!puzzleState.isActive) return;
  const canvas = unref(canvasRef);
  const pointer = canvas.getPointer(opt.e);
  isDragging = false;
  isCreatingProxy = false;

  if (dragProxy) {
    const dropCell = getCellFromPoint(pointer.x, pointer.y);
    const originCellIndex = dragOriginCellIndex;
    canvas.remove(dragProxy);
    dragProxy = null;
    const originImg = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === originCellIndex);
    if (originImg) originImg.set('opacity', 1);

    if (dropCell && dropCell.index !== originCellIndex) {
      animateSwap(originCellIndex, dropCell.index);
    } else {
      animateSnapBack(originCellIndex);
    }
  } 
  // æ­£å¸¸ç‚¹å‡»é€»è¾‘
  else if (dragOriginPoint) {
    const dist = Math.sqrt(
      Math.pow(pointer.x - dragOriginPoint.x, 2) +
      Math.pow(pointer.y - dragOriginPoint.y, 2)
    );

    // åˆ¤æ–­ä¸ºç‚¹å‡»è€Œéæ‹–æ‹½
    if (dist < 5) {
      const clickedCell = getCellFromPoint(pointer.x, pointer.y);
      if (clickedCell) {
        // åˆ¤æ–­æ ¼å­å†…æ˜¯å¦æœ‰å›¾ç‰‡
        const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === clickedCell.index);
        
        if (!img) {
            // A. ç‚¹å‡»ç©ºæ ¼å­ï¼šä¸Šä¼ 
            if (uiCallbacks.onCellClick) {
                uiCallbacks.onCellClick(clickedCell.index);
                canvas.discardActiveObject();
            }
        } else {
            // B. ç‚¹å‡»æœ‰å›¾ç‰‡çš„æ ¼å­ï¼šé€‰ä¸­å¹¶è¿›å…¥é…ç½®
            const controller = canvas.getObjects().find(o => o.isPuzzleController && o.cellIndex === clickedCell.index);
            if (controller) canvas.setActiveObject(controller);
            
            if (uiCallbacks.onImageSelect) {
                uiCallbacks.onImageSelect(clickedCell.index, {
                    opacity: img.opacity,
                    scale: img.scaleX
                });
            }
        }
      } else {
        // ç‚¹å‡»ç©ºç™½å¤„ï¼ˆç½‘æ ¼å¤–çš„åŒºåŸŸï¼‰
        if (uiCallbacks.onDeselect) uiCallbacks.onDeselect();
      }
    } else {
      // æ‹–æ‹½äº†ä½†æ²¡äº§ç”Ÿäº¤æ¢ï¼ˆåŸåœ°å›å¼¹ï¼‰
      if (dragOriginCellIndex !== -1) animateSnapBack(dragOriginCellIndex);
    }
  }
  dragOriginCellIndex = -1;
  dragOriginPoint = null;
  canvas.requestRenderAll();
};

const animateSnapBack = (cellIndex) => {
  const canvas = unref(canvasRef);
  const cell = puzzleState.cells.find(c => c.index === cellIndex);
  const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === cellIndex);

  if (img && cell) {
    const containerRect = {
      left: cell.left,
      top: cell.top,
      width: cell.width,
      height: cell.height
    };
    if (typeof animateRebound === 'function') {
      animateRebound(img, containerRect, canvas);
    } else {
      img.set({
        left: cell.left + cell.width / 2,
        top: cell.top + cell.height / 2
      });
      canvas.requestRenderAll();
    }
  }
};

const animateSwap = (idxA, idxB) => {
  const canvas = unref(canvasRef);
  const imgA = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === idxA);
  const imgB = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === idxB);
  const cellA = puzzleState.cells.find(c => c.index === idxA);
  const cellB = puzzleState.cells.find(c => c.index === idxB);
  const animations = [];
  const duration = 300;
  const easing = fabric.util.ease.easeOutQuart;

  const createSyncAnimation = (img, targetCell) => {
    if (!img || !targetCell) return;
    const targetImgState = calculateFitPosition(img, targetCell);
    animations.push(new Promise(resolve => {
      img.animate({
        left: targetImgState.left,
        top: targetImgState.top,
        scaleX: targetImgState.scaleX,
        scaleY: targetImgState.scaleY
      }, {
        duration, easing,
        onChange: canvas.requestRenderAll.bind(canvas),
        onComplete: resolve
      });
    }));

    if (img.clipPath) {
      animations.push(new Promise(resolve => {
        img.clipPath.animate({
          left: targetCell.left,
          top: targetCell.top,
          width: targetCell.width,
          height: targetCell.height,
          rx: puzzleState.radius,
          ry: puzzleState.radius
        }, {
          duration, easing,
          onComplete: resolve
        });
      }));
    }
  };

  createSyncAnimation(imgA, cellB);
  createSyncAnimation(imgB, cellA);

  Promise.all(animations).then(() => {
    if (imgA) imgA.cellIndex = idxB;
    if (imgB) imgB.cellIndex = idxA;
    const ctrlA = canvas.getObjects().find(o => o.isPuzzleController && o.cellIndex === idxA);
    const ctrlB = canvas.getObjects().find(o => o.isPuzzleController && o.cellIndex === idxB);
    if (ctrlA) ctrlA.cellIndex = idxB;
    if (ctrlB) ctrlB.cellIndex = idxA;
    refreshPuzzleObjects();
    if (saveHistoryFn) saveHistoryFn();
  });
};

const onMouseWheel = (opt) => {
  const canvas = unref(canvasRef);
  const target = canvas.getActiveObject();
  if (!target || !target.isPuzzleController) return;
  opt.e.preventDefault(); opt.e.stopPropagation();
  const cell = puzzleState.cells.find(c => c.index === target.cellIndex);
  const img = canvas.getObjects().find(o => o.isPuzzleImage && o.cellIndex === target.cellIndex);
  if (!cell || !img) return;

  let zoom = img.scaleX;
  zoom *= 0.999 ** opt.e.deltaY;

  const minScale = Math.max(cell.width / img.width, cell.height / img.height);
  const maxScale = minScale * 5;
  if (zoom < minScale) zoom = minScale;
  if (zoom > maxScale) zoom = maxScale;

  img.set({ scaleX: zoom, scaleY: zoom });

  const containerRect = {
    left: cell.left, top: cell.top, width: cell.width, height: cell.height
  };
  constrainObjectToRect(img, containerRect, canvas);

  canvas.requestRenderAll();
};

export const updateLayout = (cellDefinitions = null, config = {}) => {
  const canvas = unref(canvasRef);
  if (!canvas) return;
  if (config.width !== undefined) puzzleState.width = config.width;
  if (config.height !== undefined) puzzleState.height = config.height;
  if (config.padding !== undefined) puzzleState.padding = config.padding;
  if (config.spacing !== undefined) puzzleState.spacing = config.spacing;
  if (config.radius !== undefined) puzzleState.radius = config.radius;

  if (config.bgColor) puzzleState.bgColor = config.bgColor;

  if (cellDefinitions) puzzleState.rawCells = cellDefinitions;

  const { width, height, padding, spacing, startX, startY } = puzzleState;
  const safeW = Math.max(0, width - (padding * 2));
  const safeH = Math.max(0, height - (padding * 2));

  puzzleState.cells = puzzleState.rawCells.map(cell => {
    const EPSILON = 0.01;
    const isLeftEdge = cell.x < EPSILON;
    const isTopEdge = cell.y < EPSILON;
    const isRightEdge = Math.abs((cell.x + cell.w) - 1.0) < EPSILON;
    const isBottomEdge = Math.abs((cell.y + cell.h) - 1.0) < EPSILON;

    let boxLeft = startX + Number(padding) + (cell.x * safeW);
    let boxTop = startY + Number(padding) + (cell.y * safeH);
    let boxWidth = cell.w * safeW;
    let boxHeight = cell.h * safeH;

    if (!isLeftEdge) {
      boxLeft += spacing / 2;
      boxWidth -= spacing / 2;
    }
    if (!isRightEdge) {
      boxWidth -= spacing / 2;
    }

    if (!isTopEdge) {
      boxTop += spacing / 2;
      boxHeight -= spacing / 2;
    }
    if (!isBottomEdge) {
      boxHeight -= spacing / 2;
    }

    return {
      index: cell.index,
      left: boxLeft,
      top: boxTop,
      width: Math.max(1, boxWidth),
      height: Math.max(1, boxHeight)
    };
  });

  refreshPuzzleObjects(!!cellDefinitions);
  if (saveHistoryFn) saveHistoryFn();
};

const refreshPuzzleObjects = (shouldResetImages = false) => {
  const canvas = unref(canvasRef);
  const { radius, startX, startY, width, height, bgColor } = puzzleState;

  const toRemove = canvas.getObjects().filter(o =>
    o.isPlaceholder || o.isPuzzleController || o.isPuzzleBackground
  );
  canvas.remove(...toRemove);

  const localBg = new fabric.Rect({
    left: startX,
    top: startY,
    width: width,
    height: height,
    fill: bgColor,
    rx: radius,
    ry: radius,
    selectable: false,
    evented: false,
    isPuzzleBackground: true,
    isPuzzleItem: true
  });
  canvas.add(localBg);
  canvas.sendToBack(localBg);

  const existingPuzzleImages = canvas.getObjects()
    .filter(o => o.isPuzzleImage && !o.isGhost && o !== dragProxy && !o.isPuzzleBackground)
    .sort((a, b) => a.cellIndex - b.cellIndex);

  if (shouldResetImages && existingPuzzleImages.length === 0) {
    const rawImages = canvas.getObjects().filter(o => o.type === 'image' && !o.isPuzzleItem);
    if (rawImages.length > 0) {
      const rawImg = rawImages[0];
      const src = rawImg.getSrc();
      canvas.remove(rawImg);
      addImageToCell(src, 0);
      puzzleState.cells.forEach(cell => drawPlaceholder(canvas, cell));
      canvas.requestRenderAll();
      return;
    }
  }

  puzzleState.cells.forEach((cell, index) => {
    let img = null;

    if (shouldResetImages) {
      if (index < existingPuzzleImages.length) {
        img = existingPuzzleImages[index];
        img.cellIndex = cell.index;
        img.set({ opacity: 1, visible: true });
        const fitState = calculateFitPosition(img, cell);
        img.set({
          scaleX: fitState.scaleX,
          scaleY: fitState.scaleY,
          left: fitState.left,
          top: fitState.top
        });
        img.setCoords();
      }
    } else {
      img = existingPuzzleImages.find(o => o.cellIndex === cell.index);
      if (img) {
        const newCellCenterX = cell.left + cell.width / 2;
        const newCellCenterY = cell.top + cell.height / 2;

        let targetLeft = newCellCenterX;
        let targetTop = newCellCenterY;

        if (img.clipPath && img.clipPath.absolutePositioned) {
          const oldCell = img.clipPath;
          const oldCellCenterX = oldCell.left + oldCell.width / 2;
          const oldCellCenterY = oldCell.top + oldCell.height / 2;

          const offsetX = img.left - oldCellCenterX;
          const offsetY = img.top - oldCellCenterY;

          if (!isNaN(offsetX) && Math.abs(offsetX) < 3000) {
            targetLeft = newCellCenterX + offsetX;
            targetTop = newCellCenterY + offsetY;
          }
        }

        img.set({ left: targetLeft, top: targetTop });

        const iW = img.width || 100;
        const iH = img.height || 100;
        const minScale = Math.max(cell.width / iW, cell.height / iH) + 0.0001;

        if (img.scaleX < minScale) {
          img.set({ scaleX: minScale, scaleY: minScale });
        }

        img.setCoords();

        const containerRect = {
          left: cell.left,
          top: cell.top,
          width: cell.width,
          height: cell.height
        };
        constrainObjectToRect(img, containerRect, canvas);

        if (!img.intersectsWithObject(new fabric.Rect(containerRect))) {
          img.set({ left: newCellCenterX, top: newCellCenterY });
          img.setCoords();
        }
      }
    }

    if (img) {
      const clipRect = new fabric.Rect({
        left: cell.left,
        top: cell.top,
        width: cell.width,
        height: cell.height,
        rx: radius,
        ry: radius,
        absolutePositioned: true
      });
      img.set({ clipPath: clipRect, opacity: img.opacity || 1 });
      img.dirty = true;
      img.setCoords();

      const controller = new fabric.Rect({
        left: cell.left,
        top: cell.top,
        width: cell.width,
        height: cell.height,
        fill: 'transparent',
        transparentCorners: false,
        selectable: true,
        evented: true,
        // ğŸ”¥ å…³é”®ä¿®æ”¹ï¼šç¦ç”¨æ§ä»¶å’Œè¾¹æ¡†æ˜¾ç¤º
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockRotation: true,
        lockScalingX: true,
        lockScalingY: true,
        isPuzzleItem: true,
        isPuzzleController: true,
        cellIndex: cell.index
      });
      canvas.add(controller);
      // ğŸ”¥ å·²ç§»é™¤ drawDeleteBtn è°ƒç”¨
    } else {
      drawPlaceholder(canvas, cell);
    }
  });

  if (shouldResetImages && existingPuzzleImages.length > puzzleState.cells.length) {
    const extras = existingPuzzleImages.slice(puzzleState.cells.length);
    canvas.remove(...extras);
  }

  if (localBg) canvas.sendToBack(localBg);

  canvas.requestRenderAll();
};

export const deleteImageFromCell = (cellIndex) => {
  const canvas = unref(canvasRef);
  const objs = canvas.getObjects().filter(o =>
    (o.isPuzzleImage || o.isPuzzleController) && o.cellIndex === cellIndex
  );
  canvas.remove(...objs);
  refreshPuzzleObjects();
  if (saveHistoryFn) saveHistoryFn();
};

const drawPlaceholder = (canvas, cell) => {
  const rect = new fabric.Rect({
    left: cell.left, top: cell.top, width: cell.width, height: cell.height,
    fill: '#f5f7fa', stroke: '#dcdfe6', strokeWidth: 1, strokeDashArray: [4, 4],
    rx: puzzleState.radius, ry: puzzleState.radius,
    selectable: false, evented: false, isPuzzleItem: true, isPlaceholder: true
  });
  const plus = new fabric.Text('+', {
    left: cell.left + cell.width / 2, top: cell.top + cell.height / 2,
    fontSize: 30, fill: '#909399', originX: 'center', originY: 'center',
    selectable: false, evented: false, isPuzzleItem: true, isPlaceholder: true
  });
  canvas.add(rect, plus);
};

const getCellFromPoint = (x, y) => {
  return puzzleState.cells.find(cell =>
    x >= cell.left && x <= cell.left + cell.width &&
    y >= cell.top && y <= cell.top + cell.height
  );
};

export const addImageToCell = (url, cellIndex, options = {}) => {
  const canvas = unref(canvasRef);
  const oldObjs = canvas.getObjects().filter(o => (o.isPuzzleImage || o.isPuzzleController) && o.cellIndex === cellIndex);
  canvas.remove(...oldObjs);

  fabric.Image.fromURL(url, (img) => {
    const cell = puzzleState.cells.find(c => c.index === cellIndex);
    if (!cell) return;

    let scale;
    if (options.targetScale) {
      scale = options.targetScale;
    } else {
      scale = Math.max(cell.width / img.width, cell.height / img.height) + 0.001;
    }

    img.set({
      left: cell.left + cell.width / 2,
      top: cell.top + cell.height / 2,
      originX: 'center',
      originY: 'center',
      scaleX: scale,
      scaleY: scale,
      selectable: false, evented: false, hasControls: false, hasBorders: false,
      isPuzzleItem: true, isPuzzleImage: true, cellIndex: cellIndex,
    });

    img.setCoords();

    const controller = new fabric.Rect({
      left: cell.left, top: cell.top, width: cell.width, height: cell.height,
      fill: 'transparent', noScaleCache: false,
      transparentCorners: false, cornerSize: 8, borderOpacityWhenMoving: 0.5,
      selectable: true, evented: true, 
      hasControls: false, // ç¦ç”¨
      hasBorders: false,  // ç¦ç”¨
      lockMovementX: true, lockMovementY: true,
      lockRotation: true, lockScalingX: true, lockScalingY: true,
      isPuzzleItem: true, isPuzzleController: true, cellIndex: cellIndex,
    });

    canvas.add(img);
    canvas.add(controller);
    canvas.setActiveObject(controller);

    refreshPuzzleObjects();
    if (saveHistoryFn) saveHistoryFn();
  }, { crossOrigin: 'anonymous' });
};
</file>

<file path="src/composables/useEditorState.js">
import { reactive, readonly } from 'vue';

/**
 * âœ¨ å…¨å±€è·¯ç”±é…ç½®è¡¨ (Single Source of Truth)
 * å®šä¹‰ Fabric å¯¹è±¡ç±»å‹ -> å·¥å…·é¢æ¿(Tool) + å­é€‰é¡¹å¡(Tab) çš„æ˜ å°„å…³ç³»
 */
export const OBJECT_TO_TOOL_MAP = {
    // === åŸºç¡€å½¢çŠ¶ ===
    'i-text': { tool: 'text', tab: 'style' },    // æ–‡æœ¬ -> æ–‡æœ¬é¢æ¿-æ ·å¼Tab
    'textbox': { tool: 'text', tab: 'style' },
    'image': { tool: 'adjust', tab: 'filter' }, // å›¾ç‰‡ -> è°ƒæ•´é¢æ¿-æ»¤é•œTab
    'group': { tool: 'adjust', tab: '' },       // ç»„ -> è°ƒæ•´é¢æ¿ (æ ¹æ®ä¸šåŠ¡éœ€æ±‚)

    // === ç»˜åˆ¶/çŸ¢é‡ ===
    'path': { tool: 'draw', tab: '' },         // è·¯å¾„ -> ç»˜åˆ¶é¢æ¿

    // === å‡ ä½•å›¾å½¢ (é€šå¸¸å½’ç±»ä¸ºç´ ææˆ–è¾¹æ¡†ï¼Œæ ¹æ®ä½ çš„ä¸šåŠ¡å®š) ===
    'rect': { tool: 'border', tab: 'style' },
    'circle': { tool: 'material', tab: 'basic' },
    'triangle': { tool: 'material', tab: 'basic' },

    // === è‡ªå®šä¹‰ä¸šåŠ¡ç±»å‹ ===
    'puzzle': { tool: 'puzzle', tab: 'template' }
};

// å•ä¾‹çŠ¶æ€
const state = reactive({
    activeTool: 'adjust', // ä¸€çº§èœå• ID
    activeTab: '',        // âœ¨ æ–°å¢: äºŒçº§èœå• ID (ä¾‹å¦‚ 'style', 'color', 'filter')

    isDrawing: false,     // æ˜¯å¦å¤„äºè‡ªç”±ç»˜åˆ¶æ¨¡å¼

    canUndo: false,       // å†å²è®°å½•çŠ¶æ€
    canRedo: false,

    isLoading: false,
    loadingText: 'å¤„ç†ä¸­...',

    isSidebarDisabled: false, // ä¾§è¾¹æ æ®‹å½±æ¨¡å¼
    isGlobalDragMode: false,  // å…¨å±€æ‹–åŠ¨æ¨¡å¼

    /**
     * âœ¨ å¯¼èˆªæ¥æºæ ‡è®°
     * 'system': åˆå§‹åŒ–æˆ–ç³»ç»Ÿé‡ç½®
     * 'manual': ç”¨æˆ·æ‰‹åŠ¨ç‚¹å‡»ä¾§è¾¹æ  (ä¼˜å…ˆçº§æœ€é«˜ï¼Œåº”æœ‰ç‚¹å‡»åé¦ˆ)
     * 'canvas': ç”»å¸ƒå¯¹è±¡é€‰ä¸­è§¦å‘è‡ªåŠ¨è·³è½¬ (åº”å¹³æ»‘è¿‡æ¸¡ï¼Œæ— å¹²æ‰°)
     */
    navigationSource: 'system',
    
    // æ–°å¢ï¼šæ˜¯å¦æ­£åœ¨è¿›è¡Œæ‹¼å›¾æ“ä½œ
    isPuzzleMode: false,
});

export function useEditorState() {

    /**
     * åˆ‡æ¢å½“å‰æ¿€æ´»çš„å·¥å…·å’Œé€‰é¡¹å¡
     * @param {string} tool - ä¸€çº§å·¥å…· ID
     * @param {string} tab - (å¯é€‰) äºŒçº§é€‰é¡¹å¡ ID
     * @param {string} source - è§¦å‘æ¥æº ('manual' | 'canvas' | 'system')
     */
    const setActiveTool = (tool, tab = '', source = 'manual') => {
        // çŠ¶æ€é˜²æŠ–ï¼šå¦‚æœ Tool å’Œ Tab éƒ½æ²¡å˜ï¼Œä¸”ä¾§è¾¹æ ä¹Ÿæ˜¯æ¿€æ´»çŠ¶æ€ï¼Œåˆ™ä¸æ‰§è¡Œ
        if (state.activeTool === tool && state.activeTab === tab && !state.isSidebarDisabled) {
            return;
        }

        state.activeTool = tool;
        state.activeTab = tab; // æ›´æ–°äºŒçº§è·¯ç”±
        state.navigationSource = source;

        // å‰¯ä½œç”¨å¤„ç†
        state.isDrawing = false; // åˆ‡æ¢å·¥å…·é»˜è®¤é€€å‡ºç»˜åˆ¶æ¨¡å¼
        state.isSidebarDisabled = false; // åªè¦åˆ‡æ¢å·¥å…·ï¼Œå¿…å®šæ¿€æ´»é¢æ¿
    };

    // âœ¨ æ–°å¢ï¼šè®¾ç½®æ‹–æ‹½æ¨¡å¼
    const setGlobalDragMode = (val) => {
        state.isGlobalDragMode = val;
        console.log(`[State] Global Drag Mode: ${val ? 'ON' : 'OFF'}`);
    };


    // âœ¨ [æ ¸å¿ƒè¡¥å…¨] åˆ‡æ¢äºŒçº§ Tab (ä¸“é—¨ç»™ UI ç»„ä»¶ç”¨æ¥æ¸…ç†çŠ¶æ€)
    const setActiveTab = (tab) => {
        state.activeTab = tab;
    };

    const toggleDrawing = (status) => {
        state.isDrawing = status;
    };

    const setHistoryState = (canUndo, canRedo) => {
        state.canUndo = canUndo;
        state.canRedo = canRedo;
    };

    const setLoading = (status, text = 'å¤„ç†ä¸­...') => {
        state.isLoading = status;
        state.loadingText = text;
    };

    const setSidebarDisabled = (status) => {
        state.isSidebarDisabled = status;
    };

    // æ–°å¢ï¼šè®¾ç½®æ˜¯å¦æ­£åœ¨è¿›è¡Œæ‹¼å›¾æ“ä½œ
    const setPuzzleMode = (status) => {
        state.isPuzzleMode = status;
    };

    // === âœ¨ æ ¸å¿ƒï¼šæ™ºèƒ½è·¯ç”±ç³»ç»Ÿ ===

    /**
     * æ ¹æ® Canvas é€‰ä¸­çš„å¯¹è±¡ï¼Œè‡ªåŠ¨è·¯ç”±åˆ°å¯¹åº”çš„å·¥å…·é¢æ¿
     * @param {Object} target - Fabric å¯¹è±¡å®ä¾‹
     * @returns {boolean} - æ˜¯å¦æˆåŠŸåŒ¹é…å¹¶è·³è½¬
     */
    const routeToObject = (target) => {
        if (!target) return false;

        // 1. ä¼˜å…ˆè¯»å–å¯¹è±¡ä¸Šçš„è‡ªå®šä¹‰è·¯ç”±é…ç½® (å¦‚æ ‡å°º)
        if (target.customTab) {
            console.log(`[Router] Custom routing: Tool[${target.customTool || 'adjust'}] Tab[${target.customTab}]`);

            // æ¿€æ´»å¯¹åº”çš„å·¥å…·æ 
            setActiveTool(target.customTool || 'adjust');

            // âœ¨ å¼ºåˆ¶åˆ·æ–°æœºåˆ¶ï¼š
            // è§£å†³â€œçŠ¶æ€æ­»é”â€ï¼šå¦‚æœå½“å‰ activeTab å·²ç»æ˜¯è¿™ä¸ª tab (æ¯”å¦‚ 'ruler')ï¼Œ
            // ç›´æ¥èµ‹å€¼ Vue ä¸ä¼šè®¤ä¸ºå‘ç”Ÿäº†å˜åŒ–ï¼Œå› æ­¤ watch ä¸ä¼šè§¦å‘ã€‚
            // æˆ‘ä»¬å…ˆæŠŠå®ƒç½®ç©ºï¼Œåˆ©ç”¨ setTimeout åœ¨ä¸‹ä¸€å¸§æ”¹å›æ¥ï¼Œå¼ºåˆ¶è§¦å‘ UI å±•å¼€ã€‚
            if (state.activeTab === target.customTab) {
                state.activeTab = '';
                setTimeout(() => {
                    state.activeTab = target.customTab;
                }, 0);
            } else {
                state.activeTab = target.customTab;
            }

            return true;
        }

        // 2. é»˜è®¤è·¯ç”±è§„åˆ™
        if (target.type === "i-text") {
            setActiveTool("text");
            return true;
        }

        // ... å…¶ä»–é»˜è®¤è§„åˆ™å¯åœ¨æ­¤è¡¥å…… ...

        return false;
    };

    return {
        state: readonly(state), // å¯¼å‡ºåªè¯»çŠ¶æ€
        setActiveTool,
        setActiveTab,       // âœ¨ ç¡®ä¿å¯¼å‡ºæ­¤å‡½æ•°
        toggleDrawing,
        setHistoryState,
        setLoading,
        setSidebarDisabled,
        setPuzzleMode,
        routeToObject, // å¯¼å‡ºè·¯ç”±åŠ¨ä½œä¾› useCanvas ä½¿ç”¨
        setGlobalDragMode // å¯¼å‡ºå…¨å±€æ‹–åŠ¨æ¨¡å¼è®¾ç½®
    };
}

// å…¨å±€èšç„¦ç³»æ•° (ä¿ç•™)
export const ZOOM_PADDING = 0.921;
</file>

<file path=".spec/active-context.md">
# Active Context & Development State

> **Version**: 3.0 (Hand Mode & Smart Sensing Integration)
> **Last Updated**: 2025-12-24
> **Current Focus**: å…¨å±€äº¤äº’çŠ¶æ€åˆ‡æ¢ã€æ ‡å°ºæ™ºèƒ½æ„ŸçŸ¥ä¸å…‰æ ‡ä¼˜å…ˆçº§ä½“ç³»

## 1. å½“å‰å¼€å‘çŠ¶æ€ (Current Status)

### âœ… å·²å®Œæˆæ¨¡å— (Completed Modules)

#### 1.1 æ ¸å¿ƒç¼–è¾‘ (Core Editing)
- **å‰ªè£ (Crop)**:
  - [x] **æ‰‹åŠ¨é€‰åŒº**: å®ç°äº† `startManualSelection`ï¼Œæ”¯æŒè‡ªå®šä¹‰æ¡†é€‰åŒºåŸŸã€‚
  - [x] **æ¯”ä¾‹é”å®š**: æ”¯æŒåŸå›¾æ¯”ä¾‹ã€è‡ªç”±æ¯”ä¾‹åŠå¸¸ç”¨é¢„è®¾ (1:1, 16:9 ç­‰)ã€‚
  - [x] **æ—‹è½¬ç¿»è½¬**: 90Â° æ­¥è¿›æ—‹è½¬ä¸ XY è½´ç¿»è½¬ã€‚
- **å°ºå¯¸è°ƒæ•´ (Resize)**:
  - [x] **é«˜æ¸…é‡åˆ¶**: å¼•å…¥ `useOffscreenHelper`ï¼Œå®ç°äº†åŸºäºåŸå›¾åˆ†è¾¨ç‡çš„é«˜æ¸…ç¼©æ”¾ã€‚
  - [x] **ä¿çœŸæ¨¡å¼**: æ”¯æŒé”å®šé•¿å®½æ¯”è®¡ç®—ã€‚
  - [x] **é€šç”¨é”é›†æˆ**: æˆåŠŸæ¥å…¥ `useCanvasLock`ï¼Œé”å®šé™¤ä¸»å›¾å¤–çš„ä¸€åˆ‡å¯¹è±¡ã€‚
- **è¡¥ç™½ (White/Padding)**:
  - [x] **æ¶æ„å¯¹é½**: ç»Ÿä¸€ä½¿ç”¨ `useCanvasLock` ç®¡ç†äº¤äº’é”ã€‚
  - [x] **æ¯å¸¦é‡åˆ¶**: å®ç°äº†åŸºäºåŸå§‹åˆ†è¾¨ç‡çš„é«˜æ¸…è¡¥ç™½ä¸è§†å›¾æ¯”ä¾‹ä¿®æ­£ã€‚

#### 1.2 æ‹¼å›¾ç³»ç»Ÿ (Puzzle System)
- **ç½‘æ ¼å¸ƒå±€**:
  - [x] **åŠ¨æ€æ¨¡æ¿**: åŸºäº `config.js` å®ç°äº† 1-16 å¼ å›¾ç‰‡çš„ç½‘æ ¼å¸ƒå±€è§£æã€‚
  - [x] **è‡ªåŠ¨å¸ƒå±€**: å›¾ç‰‡æ‹–å…¥è‡ªåŠ¨è®¡ç®— Cover è£å‰ªï¼Œä¿è¯å¡«æ»¡æ ¼å­ä¸ç•™ç™½ã€‚
- **äº¤äº’é€»è¾‘**:
  - [x] **æ‹–æ‹½äº¤æ¢**: å®ç°äº†å¹³æ»‘çš„äº¤æ¢åŠ¨ç”» (`animateSwap`) å’Œå¤±è´¥å›å¼¹ã€‚
  - [x] **ç‰©ç†çº¦æŸ**: åº”ç”¨ `useConstraint` é˜²æ­¢å›¾ç‰‡è„±ç¦»æ ¼å­å¯è§†åŒºã€‚
- **æ ·å¼è°ƒæ•´**:
  - [x] **å…¨å±€å‚æ•°**: æ”¯æŒåŠ¨æ€è°ƒæ•´é—´è·ã€è¾¹è·å’Œåœ†è§’ã€‚

#### 1.3 æ™ºèƒ½ä¸ç‰¹æ•ˆ (AI & Effects)
- **æ™ºèƒ½æ¶ˆé™¤ (Inpaint)**:
  - [x] **ç¦»å±é®ç½©**: è§£å†³é—ªçƒé—®é¢˜ï¼Œé€šè¿‡ç¦»å± Canvas ç”Ÿæˆ Maskã€‚
  - [x] **åŒæ¨¡äº¤äº’**: æ”¯æŒç”»ç¬” (Brush) å’Œ çŸ©å½¢æ¡†é€‰ (Rect)ã€‚
- **ä¸€é”®æŠ å›¾ (Rembg)**:
  - [x] **API é›†æˆ**: å°è£… `src/api/ai.js` æ”¯æŒä¸€é”®ç§»é™¤èƒŒæ™¯ã€‚
- **æ»¤é•œä¸è°ƒè‰²**:
  - [x] **ColorMatrix**: å®ç°äº®åº¦ã€å¯¹æ¯”åº¦ç­‰ 6 ç»´è°ƒèŠ‚ã€‚
  - [x] **LUT æ¨¡æ‹Ÿ**: å†…ç½®â€œå¤å¤â€ã€â€œç”µå½±â€ç­‰æ»¤é•œé¢„è®¾ã€‚

#### 1.4 å…¨å±€äº¤äº’ä¸æ ‡å°ºæ™ºèƒ½ `NEW`
- **å…¨å±€æ‰‹å½¢æ¨¡å¼ (Hand/Drag Mode)**:
  - [x] **çŠ¶æ€ç®¡ç†**: åœ¨ `useEditorState.js` ä¸­æ–°å¢å…¨å±€ `isGlobalDragMode` çŠ¶æ€ã€‚
  - [x] **UI éƒ¨ç½²**: åœ¨ `Workspace.vue` å³ä¸‹è§’éƒ¨ç½²æ‰‹å½¢æŒ‰é’®ï¼Œå®ç°æ¨¡å¼å®æ—¶åˆ‡æ¢ã€‚
  - [x] **æ—¶åºä¿®å¤**: é€šè¿‡ç›‘å¬ `image:updated` è§£å†³äº†å¼‚æ­¥åŠ è½½å¯¼è‡´çš„ç‰©ç†é”å¤±æ•ˆé—®é¢˜ã€‚
- **æµ‹é‡æ ‡å°º (AdjustRuler)**:
  - [x] **æ™ºèƒ½æ„ŸçŸ¥ç»˜åˆ¶**: å®ç°äº†â€œæŒ‰ä¸‹å³ç»˜åˆ¶â€é€»è¾‘ã€‚ç‚¹å‡»ç©ºç™½å¤„ï¼ˆç©¿é€ä¸»å›¾ï¼‰å¯åŠ¨ç»˜åˆ¶ï¼Œç‚¹å‡»å·²æœ‰æ ‡å°ºåˆ™é€‰ä¸­ã€‚
  - [x] **å…‰æ ‡ä¼˜å…ˆçº§**: ç¡®ç«‹äº† `grab` (æ‰‹å½¢) > `crosshair` (æ ‡å°º) > `default` (é»˜è®¤) çš„ä¼˜å…ˆçº§ä½“ç³»ã€‚
  - [x] **å¯¹è±¡åé¦ˆ**: é”å®šçŠ¶æ€ä¸‹çš„æ ‡å°ºå¯¹è±¡å¼ºåˆ¶æ˜¾ç¤º `hoverCursor: 'move'`ï¼Œä»¥æ˜ç¡®å…¶å¯ç¼–è¾‘æ€§ã€‚

---

## 2. ç³»ç»Ÿæ¶æ„å¤‡å¿˜ (Architecture Memo)

### 2.1 é«˜æ¸…ç¦»å±æ¸²æŸ“ç®¡çº¿ (High-Res Offscreen Pipeline)
- **é€»è¾‘**: è·å–åŸå›¾åŸå§‹åˆ†è¾¨ç‡ -> åˆ›å»ºä¸´æ—¶ StaticCanvas -> æ˜ å°„æ•ˆæœ -> å¯¼å‡ºé«˜æ¸…å›¾ã€‚

### 2.2 ç‰©ç†çº¦æŸç³»ç»Ÿ (Constraint System)
- **é€»è¾‘**: è®¡ç®—å¯¹è±¡ç›¸å¯¹äºå®¹å™¨çš„æº¢å‡ºå€¼ï¼ŒResizing æ—¶å®æ—¶ä¿®æ­£ï¼ŒPuzzle æ‹–æ‹½æ—¶è§¦å‘å›å¼¹ã€‚

### 2.3 èº«ä»½è¯†åˆ«æ ‡å‡† (Identity Standards) `NEW`
- **ä¸»å›¾ (Main Image)**: å¿…é¡»å…·å¤‡ `isMainImage: true` æ ‡è¯†ã€‚
- **æ ‡å°º (Ruler)**: å…·å¤‡ `isRuler: true` æ ‡è¯†ï¼Œç”¨äºè±å…ç‰©ç†é”å¹¶åˆ‡æ¢ `hoverCursor`ã€‚

### 2.4 å¯¹è±¡é©±åŠ¨è·¯ç”±æ¶æ„ (Object-Driven Routing)
- **æ ¸å¿ƒç†å¿µ**: Canvas æ˜¯è·¯ç”±è§¦å‘å™¨ï¼ŒState æ˜¯æ§åˆ¶å™¨ï¼ŒSidebar æ˜¯è§†å›¾ã€‚
- **äºŒçº§å¯¼èˆª**: æ”¯æŒé€šè¿‡ `customTab` å±æ€§ç²¾ç¡®è·³è½¬è‡³ç‰¹å®šé¢æ¿ (å¦‚æ ‡å°º)ã€‚

### 2.5 é…ç½®é©±åŠ¨å‹ç‰©ç†é” (Configuration-Driven Lock) `MAJOR UPGRADE`
- **File**: `src/composables/useCanvasLock.js`
- **æ ¸å¿ƒé€»è¾‘**: å®šä¹‰ `LOCK_CONFIG` å¸¸é‡æ± ä½œä¸ºå”¯ä¸€çœŸç›¸æ¥æºã€‚
- **å¯¹ç§°æ€§**: é”å®šé˜¶æ®µæ‰§è¡Œ `lockedValue`ï¼Œè±å…/è§£é”é˜¶æ®µæ‰§è¡Œ `interactiveValue`ï¼ŒäºŒè€…å…±äº«åŒä¸€å¥—å¾ªç¯éå†ã€‚
- **åŸå­å¤‡ä»½**: åªæœ‰å½“ `WeakMap` ä¸­ä¸å­˜åœ¨è¯¥å¯¹è±¡è®°å½•æ—¶æ‰å¤‡ä»½ï¼Œç¡®ä¿å­˜å‚¨çš„æ˜¯â€œæœ€åŸå§‹çŠ¶æ€â€ã€‚

### 2.6 äº¤äº’åè®® (Interaction Protocol) `NEW`
- **é€»è¾‘**: åºŸå¼ƒç”¨æˆ·æ‰‹åŠ¨çš„â€œåé—®/æ–‡ä»¶ç´¢å–â€æé†’ï¼Œå°†å…¶ä¸‹æ”¾åˆ° AI çš„é»˜è®¤è¡Œä¸ºå±‚ã€‚
- **æ‰§è¡Œå‡†åˆ™**: 
  1. è¯†åˆ«æè®®ã€‚
  2. è§¦å‘ `project-charter` ä¸­çš„åé—®é€»è¾‘ã€‚
  3. æ£€ç´¢å—å½±å“çš„æ–‡ä»¶å¹¶å‘ç”¨æˆ·ç´¢å–ã€‚
---

## 3. æ•…éšœæ’æŸ¥ä¸æœ€ä½³å®è·µ (Troubleshooting & Best Practices)

### 3.1 è§£å†³åˆå§‹åŒ–åä¸»å›¾ä»å¯æ‹–åŠ¨çš„é—®é¢˜
- **åŸå› **: å¼‚æ­¥åŠ è½½çš„ä¸»å›¾åœ¨ `onMounted` é”æ‰§è¡Œåæ‰è¢«æ·»åŠ ï¼Œè¦†ç›–äº†é”å®šæ€ã€‚
- **æ–¹æ¡ˆ**: é‡‡ç”¨â€œåŒé‡åŠ é”â€ï¼š`onMounted` é”ä¸€æ¬¡ï¼Œå¹¶åœ¨ `image:updated` äº‹ä»¶ä¸­å†æ¬¡æ‰§è¡Œ `syncLockState`ã€‚

### 3.2 æ ‡å°ºæ¨¡å—è¯­æ³•é”™è¯¯ (startDrawMode ä¸å­˜åœ¨)
- **åŸå› **: é‡æ„ä¸ºæ™ºèƒ½æ„ŸçŸ¥æ¨¡å¼åï¼Œåˆ é™¤äº†æ‰‹åŠ¨çš„ç»˜åˆ¶å¼€å…³ï¼Œåˆå¹¶å…¥ `startRulerMode`ã€‚
- **æ–¹æ¡ˆ**: æ›´æ–° `AdjustRuler.vue`ï¼Œç»Ÿä¸€ä½¿ç”¨æ–°çš„æ¨¡å¼æ§åˆ¶æ¥å£ã€‚

### 3.3 ç‰©ç†é” (useCanvasLock) å¤±æ•ˆé¢„é˜²
- **è§„èŒƒ**: æ¨¡å—åˆå§‹åŒ–æ—¶å¿…é¡»æ˜¾å¼è®¾ç½® `mainImg.isMainImage = true`ï¼Œå¦åˆ™ä¸»å›¾ä¼šè¢«è¯¯é”ã€‚

### 3.4 ä¸ºä»€ä¹ˆåˆ‡å›æ¨¡å—ååŠŸèƒ½â€œæ®‹ç¼ºâ€ (å¦‚èƒ½é€‰ä½†ä¸èƒ½åŠ¨)ï¼Ÿ
- **ç°è±¡**: æ ‡å°ºç»„ä»¶åˆ‡å›åå‡ºç°è“æ¡†ï¼Œä½†æ— æ³•ç§»åŠ¨ã€‚
- **åŸå› **: ä¹‹å‰çš„ç‰©ç†é”åœ¨è±å…é€»è¾‘ä¸­é‡‡ç”¨äº†â€œç¡¬ç¼–ç æ¢å¤â€ï¼Œåªæ¢å¤äº† `selectable`ï¼Œå´é—æ¼äº† `lockMovementX/Y` ç­‰å±æ€§ã€‚
- **ç»ˆæè§£å†³æ–¹æ¡ˆ**: åºŸå¼ƒç¡¬ç¼–ç ï¼Œæ”¹ç”¨**é…ç½®é©±åŠ¨æ¨¡å¼**ã€‚é€šè¿‡éå†å±æ€§æ± ï¼Œç¡®ä¿æ¯ä¸€é¡¹è¢«é”å®šçš„å±æ€§åœ¨è±å…æ—¶éƒ½èƒ½è¢«ç²¾å‡†è§£é”ã€‚
- **æ•™è®­**: â€œå¯ä»¥ç”¨é…ç½®é©±åŠ¨çš„éƒ½ä¸è¦ç”¨ç¡¬ç¼–ç â€ï¼Œä¿æŒé€»è¾‘çš„é«˜åº¦å¯¹ç§°æ€§ã€‚
</file>

<file path="src/components/modules/adjust/useCanvasResize.js">
// src/components/modules/adjust/useCanvasResize.js
import { ref, unref, shallowRef, toRaw } from "vue";
import { fabric } from "fabric";

// 1. å¼•å…¥é€šç”¨ç‰©ç†çº¦æŸä¸ç¦»å±æ¸²æŸ“å·¥å…·
import { constrainObjectToRect, animateRebound } from '@/composables/useConstraint';
import { renderHighResSnapshot } from '@/composables/useOffscreenHelper';

let canvasRef = null;
let saveHistoryFn = null;

const previewRect = shallowRef(null);
let isDraggingImage = false;
let dragLastX = 0;
let dragLastY = 0;

let originalSelectable = true;
let originalEvented = true;
let originalTransform = null;

export const registerResizeModule = (canvas, saveHistory) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
};

export const getCurrentSize = () => {
  const canvas = unref(canvasRef);
  if (!canvas) return { width: 0, height: 0 };
  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (bgImage) {
    return {
      width: Math.round(bgImage.getScaledWidth()),
      height: Math.round(bgImage.getScaledHeight())
    };
  }
  return { width: canvas.width, height: canvas.height };
};

// --- äº¤äº’äº‹ä»¶å¤„ç† ---

const onPreviewMouseDown = (opt) => {
  if (!canvasRef?.value || !previewRect.value) return;
  // æ‹‰ä¼¸æ¨¡å¼ä¸‹ç¦æ­¢æ‹–æ‹½
  if (previewRect.value.data?.isStretch) return;

  const canvas = canvasRef.value;
  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  isDraggingImage = true;
  const pointer = canvas.getPointer(opt.e);
  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvas.defaultCursor = 'move';
};

const onPreviewMouseMove = (opt) => {
  if (!isDraggingImage || !canvasRef?.value) return;
  const canvas = canvasRef.value;
  const pointer = canvas.getPointer(opt.e);
  const deltaX = pointer.x - dragLastX;
  const deltaY = pointer.y - dragLastY;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (bgImage) {
    // è‡ªç”±æ‹–æ‹½ï¼Œæš‚ä¸çº¦æŸï¼Œä¾é  mouseUp æ—¶çš„å›å¼¹
    bgImage.left += deltaX;
    bgImage.top += deltaY;
    bgImage.setCoords();
  }
  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvas.requestRenderAll();
};

const onPreviewMouseUp = () => {
  if (isDraggingImage) {
    if (canvasRef?.value && previewRect.value) {
      const bgImage = canvasRef.value.getObjects().find(o => o.type === 'image');
      if (bgImage) {
        // ã€æ ¸å¿ƒå‡çº§ã€‘ä½¿ç”¨å¸¦åŠ¨ç”»çš„å¼¹æ€§å›å¼¹
        animateRebound(bgImage, previewRect.value, canvasRef.value);
      }
    }
    isDraggingImage = false;
    if (canvasRef?.value) canvasRef.value.defaultCursor = 'default';
  }
};

// --- è¾…åŠ©å‡½æ•° ---

const restoreImageState = (bgImage) => {
  if (originalTransform && bgImage) {
    bgImage.set({
      scaleX: originalTransform.scaleX,
      scaleY: originalTransform.scaleY,
      left: originalTransform.left,
      top: originalTransform.top,
      width: originalTransform.width,
      height: originalTransform.height,
      angle: originalTransform.angle,
      originX: originalTransform.originX,
      originY: originalTransform.originY
    });
    bgImage.setCoords();
  }
};

// --- é¢„è§ˆé€»è¾‘ ---

export const startPreview = (targetW, targetH, isStretch = false) => {
  const canvas = unref(canvasRef);
  if (!canvas || !targetW || !targetH) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  const currentImgCenter = bgImage.getCenterPoint();

  // ç¬¬ä¸€æ¬¡è¿›å…¥æ—¶å¤‡ä»½çŠ¶æ€
  if (!originalTransform) {
    originalSelectable = bgImage.selectable;
    originalEvented = bgImage.evented;
    originalTransform = {
      scaleX: bgImage.scaleX,
      scaleY: bgImage.scaleY,
      left: bgImage.left,
      top: bgImage.top,
      width: bgImage.width,
      height: bgImage.height,
      angle: bgImage.angle,
      originX: bgImage.originX,
      originY: bgImage.originY,
      centerX: currentImgCenter.x,
      centerY: currentImgCenter.y
    };
  }

  // æ¸…é™¤æ—§çš„é¢„è§ˆæ¡†
  if (previewRect.value) {
    canvas.remove(toRaw(previewRect.value));
    previewRect.value = null;
  }

  const targetCenter = { x: originalTransform.centerX, y: originalTransform.centerY };

  if (!isStretch) {
    restoreImageState(bgImage);
  } else {
    // æ‹‰ä¼¸æ¨¡å¼ä¸‹ç¦ç”¨å›¾ç‰‡äº¤äº’
    bgImage.selectable = false;
    bgImage.evented = false;
  }

  // è®¡ç®—é¢„è§ˆæ¡†å°ºå¯¸ï¼ˆä¿æŒå®½é«˜æ¯”ï¼‰
  const imgW = originalTransform.width * originalTransform.scaleX;
  const imgH = originalTransform.height * originalTransform.scaleY;
  const targetRatio = targetW / targetH;
  const imgRatio = imgW / imgH;

  let previewW, previewH;
  // é€»è¾‘ï¼šé¢„è§ˆæ¡†æ˜¯â€œé€‰åŒºâ€ï¼Œé€šå¸¸æœ€å¤§ä¸è¶…è¿‡å›¾ç‰‡åŸå°ºå¯¸ï¼Œæˆ–è€…æ ¹æ®æ¯”ä¾‹é€‚é…
  if (targetRatio > imgRatio) {
    previewW = imgW;
    previewH = imgW / targetRatio;
  } else {
    previewH = imgH;
    previewW = imgH * targetRatio;
  }

  // åˆ›å»ºé¢„è§ˆæ¡†
  const rect = new fabric.Rect({
    width: previewW,
    height: previewH,
    left: targetCenter.x,
    top: targetCenter.y,
    originX: 'center',
    originY: 'center',
    fill: 'transparent',
    stroke: '#409eff',
    strokeWidth: 2,
    strokeDashArray: [6, 6],
    selectable: false,
    evented: false,
    excludeFromExport: true,
    data: { isStretch }
  });

  previewRect.value = rect;
  canvas.add(rect);
  canvas.bringToFront(rect);

  if (!isStretch) {
    // ã€æ ¸å¿ƒå‡çº§ã€‘åˆå§‹çº¦æŸï¼šç¡®ä¿å›¾ç‰‡ä¸ç•™ç™½ï¼ˆä½¿ç”¨é€šç”¨ç¡¬çº¦æŸï¼‰
    constrainObjectToRect(bgImage, rect, canvas);

    // ç»‘å®šæ‹–æ‹½äº‹ä»¶
    canvas.on('mouse:down', onPreviewMouseDown);
    canvas.on('mouse:move', onPreviewMouseMove);
    canvas.on('mouse:up', onPreviewMouseUp);
  } else {
    // æ‹‰ä¼¸æ¨¡å¼ï¼šç›´æ¥è®©å›¾ç‰‡å¡«æ»¡é¢„è§ˆæ¡†ï¼ˆè§†è§‰é¢„è§ˆï¼‰
    bgImage.set({
      scaleX: previewW / originalTransform.width,
      scaleY: previewH / originalTransform.height,
      left: targetCenter.x,
      top: targetCenter.y,
      originX: 'center',
      originY: 'center'
    });
    // è§£ç»‘äº‹ä»¶
    canvas.off('mouse:down', onPreviewMouseDown);
    canvas.off('mouse:move', onPreviewMouseMove);
    canvas.off('mouse:up', onPreviewMouseUp);
  }

  bgImage.setCoords();
  canvas.requestRenderAll();
};

export const updatePreview = (targetW, targetH, isStretch = false) => {
  startPreview(targetW, targetH, isStretch);
};

export const stopPreview = () => {
  const canvas = unref(canvasRef);
  if (canvas) {
    canvas.off('mouse:down', onPreviewMouseDown);
    canvas.off('mouse:move', onPreviewMouseMove);
    canvas.off('mouse:up', onPreviewMouseUp);

    if (previewRect.value) {
      canvas.remove(toRaw(previewRect.value));
      previewRect.value = null;
    }

    const bgImage = canvas.getObjects().find(o => o.type === 'image');
    if (bgImage) {
      restoreImageState(bgImage);
      bgImage.selectable = originalSelectable;
      bgImage.evented = originalEvented;
    }

    canvas.discardActiveObject();
    originalTransform = null;
    canvas.requestRenderAll();
  }
};

// --- æ ¸å¿ƒåº”ç”¨é€»è¾‘ (é«˜æ¸…é‡åˆ¶) ---

export const applyResize = async (width, height, isStretch = false) => {
  const canvas = unref(canvasRef);
  if (!canvas || !previewRect.value) return;

  const targetW = Math.round(width);
  const targetH = Math.round(height);
  if (targetW <= 0 || targetH <= 0) return;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');
  if (!bgImage) return;

  // 1. é”å®šç°åœº
  const rect = previewRect.value;
  const prevVpt = [...canvas.viewportTransform];
  const prevZoom = canvas.getZoom();

  const rectCenterLogic = rect.getCenterPoint();
  // è®¡ç®—é¢„è§ˆæ¡†ä¸­å¿ƒåœ¨å½“å‰å±å¹•ä¸Šçš„ç»å¯¹ä½ç½®
  const rectCenterScreen = {
    x: rectCenterLogic.x * prevVpt[0] + prevVpt[4],
    y: rectCenterLogic.y * prevVpt[3] + prevVpt[5]
  };

  const finalPos = {
    logicalW: rect.width * rect.scaleX,
    logicalH: rect.height * rect.scaleY
  };

  originalTransform = null;

  // 2. ã€æ ¸å¿ƒå‡çº§ã€‘ä½¿ç”¨é€šç”¨ç¦»å±å·¥å…·ç”Ÿæˆé«˜æ¸…å›¾
  const dataURL = await renderHighResSnapshot(bgImage, targetW, targetH, (highResImg, tempCanvas) => {
    const multiplier = targetW / finalPos.logicalW;

    if (isStretch) {
      // æ‹‰ä¼¸æ¨¡å¼
      highResImg.set({
        originX: 'center', originY: 'center',
        left: targetW / 2, top: targetH / 2,
        scaleX: targetW / highResImg.width,
        scaleY: targetH / highResImg.height
      });
    } else {
      // ä¿æŒç›¸å¯¹ä½ç½®æ¨¡å¼
      const imgCenter = bgImage.getCenterPoint();
      const relCenterX = imgCenter.x - rectCenterLogic.x;
      const relCenterY = imgCenter.y - rectCenterLogic.y;

      highResImg.set({
        originX: 'center', originY: 'center',
        left: (targetW / 2) + (relCenterX * multiplier),
        top: (targetH / 2) + (relCenterY * multiplier),
        scaleX: bgImage.scaleX * multiplier,
        scaleY: bgImage.scaleY * multiplier,
        angle: bgImage.angle,
        flipX: bgImage.flipX,
        flipY: bgImage.flipY
      });
    }
  });

  // 3. åº”ç”¨å›ä¸»ç”»å¸ƒå¹¶ä¿®æ­£è§†å£
  bgImage.setSrc(dataURL, () => {
    // è®¡ç®—è§†å£ç¼©æ”¾è¡¥å¿
    const multiplier = targetW / finalPos.logicalW;
    const newZoom = prevZoom / multiplier;

    // ç‰©ç†é‡ç½®å›¾ç‰‡åˆ°ç”»å¸ƒä¸­å¿ƒ
    bgImage.set({
      originX: "center", originY: "center",
      angle: 0, flipX: false, flipY: false,
      scaleX: 1, scaleY: 1,
      left: canvas.width / 2,
      top: canvas.height / 2,
    });

    bgImage.setCoords();
    canvas.centerObject(bgImage);

    // è§†å£è¡¥å¿ï¼šå¯¹é½è§†è§‰ä¸­å¿ƒ
    const newCenterLogic = { x: canvas.width / 2, y: canvas.height / 2 };
    const newPanX = rectCenterScreen.x - newCenterLogic.x * newZoom;
    const newPanY = rectCenterScreen.y - newCenterLogic.y * newZoom;

    canvas.setViewportTransform([newZoom, 0, 0, newZoom, newPanX, newPanY]);

    stopPreview();
    canvas.requestRenderAll();
    canvas.fire('zoom:change', { from: 'resize-apply' });

    if (saveHistoryFn) saveHistoryFn();
  });
};
</file>

<file path="src/components/layout/NavBar.vue">
<template>
  <div class="navbar">
    <div class="logo">
      <slot name="logo">{{ textMap.title }}</slot>
    </div>
    <div class="ie-actions">
      <input type="file" ref="fileInput" @change="onFileSelected" style="display:none" accept="image/*" />

      <button class="ie-btn" @click="handleUpload">
        <svg width="14" height="14" viewBox="0 0 1024 1024" style="margin-right:4px;fill:currentColor">
          <path
            d="M544 253.696V704h-64V247.296L237.248 490.048 192 444.8 512 128l320 316.8-45.248 45.248L544 253.696zM160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64z" />
        </svg>
        {{ textMap.upload }}
      </button>

      <span class="ie-divider"></span>

      <button 
        class="ie-btn ie-btn-icon" 
        style="margin-right:8px; padding: 0 8px;" 
        title="æ’¤é”€" 
        @click="handleUndo" 
        :disabled="!state.canUndo"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 14 4 9l5-5"/>
          <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/>
        </svg>
      </button>
      
      <button 
        class="ie-btn ie-btn-icon" 
        style="margin-right:8px; padding: 0 8px;" 
        title="é‡åš" 
        @click="handleRedo" 
        :disabled="!state.canRedo"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M15 14l5-5-5-5"/>
          <path d="M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13"/>
        </svg>
      </button>
      <button class="ie-btn" style="margin-right:8px;" @click="handleReset">è¿˜åŸ</button>
      <button class="ie-btn ie-primary" @click="handleSave">{{ textMap.save }}</button>
    </div>
  </div>
</template>

<script setup>
import { inject, ref } from 'vue';
import { useEditorState } from '@/composables/useEditorState'; 
import { toast } from '@/utils/toast'; 
 

const { state } = useEditorState();

const canvasAPI = inject('canvasAPI');
const fileInput = ref(null);

const props = defineProps({
  textMap: {
    type: Object,
    default: () => ({}),
  },
});

const handleUpload = () => {
  fileInput.value.click();
};

const onFileSelected = (e) => {
  const file = e.target.files?.[0];
  if (file) {
    // æ£€æŸ¥ inject çš„ API æ˜¯å¦å­˜åœ¨
    if (!canvasAPI || !canvasAPI.initImage) { 
      toast.error('ç”»å¸ƒå°šæœªåˆå§‹åŒ–');
      return;
    }
    const url = URL.createObjectURL(file);
    
    // è°ƒç”¨ canvasAPI ä¸­çš„æ–¹æ³•
    canvasAPI.initImage(url); 
    
    e.target.value = '';
  }
};

const handleSave = () => {
  if (canvasAPI && canvasAPI.save) {
    canvasAPI.save(); 
  } else {
    toast.error('å¯¼å‡ºåŠŸèƒ½æœªå®ç°');
  }
};

const handleUndo = () => {
  // è°ƒç”¨ canvasAPI ä¸­çš„æ–¹æ³•
  if (canvasAPI && canvasAPI.undo) {
    canvasAPI.undo();
  }
};

const handleRedo = () => {
  // è°ƒç”¨ canvasAPI ä¸­çš„æ–¹æ³•
  if (canvasAPI && canvasAPI.redo) {
    canvasAPI.redo();
  }
};

const handleReset = () => {
  // è°ƒç”¨ canvasAPI ä¸­çš„æ–¹æ³•
  if (canvasAPI && canvasAPI.reset) {
    canvasAPI.reset();
  }
};
</script>

<style scoped>
.navbar {
  background: #fff;
  border-bottom: 1px solid #e4e7ed;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 20px;
}

.logo {
  font-weight: bold;
  font-size: 16px;
  color: #333;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustCrop.vue">
<template>
  <div class="tool-group">
    <div class="tool-item" :class="{ 'is-expanded': isExpanded }" @click="handleToggle">
      <div class="left">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
          <path d="M6 2v14a2 2 0 0 0 2 2h14" />
          <path d="M18 22V8a2 2 0 0 0-2-2H2" />
        </svg>
        <span>è£å‰ª/æ—‹è½¬</span>
      </div>
      <div class="right-icon">
        <svg class="arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">

      <div class="ratio-grid">
        <div class="ratio-item" @click="handleSetRatio(null, true)">
          <div class="icon-box">
            <svg width="16" height="16" viewBox="0 0 24 24" style="fill: currentColor">
              <path
                d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
            </svg>
          </div>
          <span>åˆå§‹åŒ–</span>
        </div>

        <div class="ratio-item" :class="{ active: currentRatio === 'original' }" @click="handleSetRatio('original')">
          <div class="shape-rect" style="width: 14px; height: 14px; border:1px solid #666"></div>
          <span>åŸæ¯”ä¾‹</span>
        </div>

        <div class="ratio-item" :class="{ active: currentRatio === 'free' }" @click="handleSetRatio(null)">
          <div class="shape-rect dashed"></div>
          <span>è‡ªç”±æ¯”ä¾‹</span>
        </div>

        <div class="ratio-item" :class="{ active: isManualActive }" @click="handleManualSelect">
          <div class="icon-box">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path stroke-dasharray="4 4" d="M4 4h16v16H4z" />
              <path fill="currentColor" stroke="none" d="M14 14l3.5 8 1.5-3.5 3.5-1.5-8-3.5z" />
            </svg>
          </div>
          <span>æ‰‹åŠ¨é€‰åŒº</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(1) }" @click="handleSetRatio(1)">
          <div class="shape-rect square"></div>
          <span>1:1</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(3 / 2) }" @click="handleSetRatio(3 / 2)">
          <div class="shape-rect" style="width: 12px; height: 8px;"></div>
          <span>3:2</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(2 / 3) }" @click="handleSetRatio(2 / 3)">
          <div class="shape-rect" style="width: 8px; height: 12px;"></div>
          <span>2:3</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(4 / 3) }" @click="handleSetRatio(4 / 3)">
          <div class="shape-rect" style="width: 16px; height: 12px;"></div>
          <span>4:3</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(3 / 4) }" @click="handleSetRatio(3 / 4)">
          <div class="shape-rect" style="width: 12px; height: 16px;"></div>
          <span>3:4</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(16 / 9) }" @click="handleSetRatio(16 / 9)">
          <div class="shape-rect" style="width: 16px; height: 9px;"></div>
          <span>16:9</span>
        </div>

        <div class="ratio-item" :class="{ active: isRatioMatch(9 / 16) }" @click="handleSetRatio(9 / 16)">
          <div class="shape-rect" style="width: 9px; height: 16px;"></div>
          <span>9:16</span>
        </div>
      </div>

      <div class="custom-input-box">
        <div class="input-header">
          <span>è‡ªå®šä¹‰</span>
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round" style="cursor: pointer">
            <circle cx="12" cy="12" r="3"></circle>
            <path
              d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
            </path>
          </svg>
        </div>

        <div class="input-controls">
          <div class="input-wrapper">
            <input type="number" v-model.number="cropW" class="ie-input" @change="onWidthChange">
            <span class="suffix">W</span>
          </div>

          <div class="link-icon" @click="toggleRatioLock">
            <svg v-if="isRatioLocked" width="16" height="16" viewBox="0 0 24 24" fill="none"
              stroke="var(--ie-primary-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
            </svg>
            <svg v-else width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#909399" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.6">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
              <line x1="4" y1="4" x2="20" y2="20" stroke="#909399" />
            </svg>
          </div>

          <div class="input-wrapper">
            <input type="number" v-model.number="cropH" class="ie-input" @change="onHeightChange">
            <span class="suffix">H</span>
          </div>
        </div>
      </div>

      <div class="rotate-actions">
        <div class="action-btn" title="å‘å·¦æ—‹è½¬90Â°" @click="rotate(-90)">
          <svg width="20" height="20" viewBox="-1 -1 26 26" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
            <path d="M3 3v5h5" />
          </svg>
        </div>
        <div class="action-btn" title="å‘å³æ—‹è½¬90Â°" @click="rotate(90)">
          <svg width="20" height="20" viewBox="-1 -1 26 26" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12a9 9 0 1 1-9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
            <path d="M21 3v5h-5" />
          </svg>
        </div>
        <div class="divider"></div>
        <div class="action-btn" title="æ°´å¹³ç¿»è½¬" @click="flip('X')">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 5v14" />
            <path d="M8 9l-3 3 3 3" />
            <path d="M16 9l3 3-3 3" />
          </svg>
        </div>
        <div class="action-btn" title="å‚ç›´ç¿»è½¬" @click="flip('Y')">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M5 12h14" />
            <path d="M9 8l3-3 3 3" />
            <path d="M9 16l3 3 3-3" />
          </svg>
        </div>
      </div>

      <div class="confirm-row">
        <button class="ie-btn ie-primary full-btn" @click="handleApply">åº”ç”¨</button>
        <button class="ie-btn full-btn" @click="handleCancel">å–æ¶ˆ</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, onMounted, onUnmounted, computed, nextTick } from 'vue';
import { fabric } from 'fabric';

import {
  startCrop,
  confirmCrop,
  setCropRatio,
  currentSelectionDims,
  isRatioLocked,
  currentAspectRatio, // ç¡®ä¿å¼•å…¥äº†æ­¤å˜é‡
  setCropBoxSize,
  rotateActive,
  flipActive,
  startManualSelection,
  isManualCropping,
  cropObject,
  openCropPanel,
  closeCropPanel,
} from './useCanvasCrop';

const props = defineProps({
  isExpanded: {
    type: Boolean,
    default: false
  }
});
const emit = defineEmits(['toggle']);

const currentRatio = ref('free');
const cropW = ref(0);
const cropH = ref(0);

// ç›‘å¬æ¥è‡ªé€»è¾‘å±‚çš„å°ºå¯¸å˜åŒ–
watch(currentSelectionDims, (newVal) => {
  if (newVal && (newVal.width !== 0 || newVal.height !== 0)) {
    cropW.value = newVal.width;
    cropH.value = newVal.height;
  }
});

watch(() => props.isExpanded, (val) => {
  if (val) {
    nextTick(() => {
      startCrop(null);
      updateInputFromCanvas();
    });
  } else {
    closeCropPanel();
  }
});

const handleToggle = () => {
  emit('toggle');
};

const handleCancel = () => {
  emit('toggle');
};

const handleApply = () => {
  confirmCrop();
  emit('toggle');
};

const isRatioMatch = (r) => {
  if (currentRatio.value === 'original') return false;
  if (!currentAspectRatio.value) return false;
  return Math.abs(currentAspectRatio.value - r) < 0.01;
};

const handleSetRatio = (ratio, isReset = false) => {
  if (isReset) {
    currentRatio.value = 'free';
    startCrop(null);
  } else if (ratio === 'original') {
    currentRatio.value = 'original';
    const activeObj = cropObject.value?.canvas?.getObjects().find(o => o.type === 'image');
    if (activeObj) {
      setCropRatio(activeObj.width / activeObj.height);
    }
  } else if (ratio === null) {
    currentRatio.value = 'free';
    setCropRatio(null);
  } else {
    currentRatio.value = ratio;
    setCropRatio(ratio);
  }
  nextTick(() => {
    updateInputFromCanvas();
  });
};

// ============================================
// æ–°å¢/ä¿®æ”¹ï¼šè¾“å…¥æ¡†è”åŠ¨è®¡ç®—é€»è¾‘
// ============================================

// è·å–å½“å‰æœ‰æ•ˆçš„è®¡ç®—æ¯”ä¾‹
const getActiveRatio = () => {
  // 1. å¦‚æœå½“å‰é€‰ä¸­çš„æ˜¯æ•°å­—æ¯”ä¾‹ (å¦‚ 1.5, 0.75 ç­‰)ï¼Œç›´æ¥è¿”å›
  if (typeof currentRatio.value === 'number') {
    return currentRatio.value;
  }
  // 2. å¦‚æœå½“å‰é€‰ä¸­çš„æ˜¯ 'original'ï¼Œåˆ™ä½¿ç”¨é€»è¾‘å±‚è®¡ç®—å‡ºçš„çœŸå®æ¯”ä¾‹
  if (currentRatio.value === 'original' && currentAspectRatio.value) {
    return currentAspectRatio.value;
  }
  // 3. è‡ªç”±æ¯”ä¾‹è¿”å› null
  return null;
};

// å®½åº¦å˜åŒ–æ—¶
const onWidthChange = () => {
  const ratio = getActiveRatio();
  // å¦‚æœæœ‰é”å®šæ¯”ä¾‹ï¼Œä¸”å®½åº¦æœ‰æ•ˆ
  if (ratio && cropW.value > 0) {
    // å®½ = é«˜ * æ¯”ä¾‹  =>  é«˜ = å®½ / æ¯”ä¾‹
    cropH.value = Math.round(cropW.value / ratio);
  }
  // åº”ç”¨åˆ°ç”»å¸ƒ
  applyInputSize();
};

// é«˜åº¦å˜åŒ–æ—¶
const onHeightChange = () => {
  const ratio = getActiveRatio();
  // å¦‚æœæœ‰é”å®šæ¯”ä¾‹ï¼Œä¸”é«˜åº¦æœ‰æ•ˆ
  if (ratio && cropH.value > 0) {
    // å®½ = é«˜ * æ¯”ä¾‹
    cropW.value = Math.round(cropH.value * ratio);
  }
  // åº”ç”¨åˆ°ç”»å¸ƒ
  applyInputSize();
};

// å°†è¾“å…¥æ¡†çš„å€¼åº”ç”¨åˆ° Canvas é€‰åŒº
const applyInputSize = () => {
  if (cropW.value > 0 && cropH.value > 0) {
    setCropBoxSize(cropW.value, cropH.value);
  }
};

const toggleRatioLock = () => {
  if (isRatioLocked.value) {
    handleSetRatio(null);
  } else {
    // å¦‚æœæ˜¯ä»è‡ªç”±æ¯”ä¾‹ç‚¹å‡»é”å®šï¼Œåˆ™é”å®šå½“å‰è¾“å…¥çš„æ¯”ä¾‹
    if (cropW.value && cropH.value) {
      const currentR = cropW.value / cropH.value;
      currentRatio.value = currentR;
      setCropRatio(currentR);
    }
  }
};

// ============================================

const isManualActive = computed(() => isManualCropping.value);

const updateInputFromCanvas = () => {
  if (cropObject.value) {
    const w = Math.round(cropObject.value.getScaledWidth());
    const h = Math.round(cropObject.value.getScaledHeight());

    cropW.value = w;
    cropH.value = h;
    if (currentRatio.value !== 'free' && currentRatio.value !== 'original' && typeof currentRatio.value === 'number') {
      const currentRealRatio = w / h;
      const targetRatio = currentRatio.value;
      if (Math.abs(currentRealRatio - targetRatio) > 0.02) {
        currentRatio.value = 'free';
        setCropRatio(null);
      }
    }
  }
};

const handleManualSelect = () => {
  currentRatio.value = 'manual'; // 1. å°† UI çŠ¶æ€è®¾ä¸º manualï¼Œæ¸…é™¤â€œåŸæ¯”ä¾‹â€å’Œâ€œè‡ªç”±æ¯”ä¾‹â€çš„é«˜äº®
  setCropRatio(null);            // 2. æ ¸å¿ƒä¿®å¤ï¼šè°ƒç”¨é€»è¾‘å±‚æ–¹æ³•ï¼Œå°†æ¯”ä¾‹é”å®šè®¾ä¸º nullï¼Œä»è€Œæ¸…é™¤ 1:1ã€3:2 ç­‰é¡¹çš„é«˜äº®
  startManualSelection()
};

const rotate = (angle) => {
  rotateActive(angle);
  setTimeout(updateInputFromCanvas, 50);
};
const flip = (axis) => flipActive(axis);

onMounted(() => {
  if (props.isExpanded) {
    openCropPanel();
    nextTick(() => {
      startCrop(null);
      updateInputFromCanvas();
    });
  }

  const checkCanvas = setInterval(() => {
    const canvasInstance = cropObject.value?.canvas;
    if (canvasInstance) {
      canvasInstance.on('object:scaling', updateInputFromCanvas);
      canvasInstance.on('object:modified', updateInputFromCanvas);
      canvasInstance.on('object:moving', updateInputFromCanvas);
      clearInterval(checkCanvas);
    }
  }, 100);
});

onUnmounted(() => {
  const canvasInstance = cropObject.value?.canvas;
  if (canvasInstance) {
    canvasInstance.off('object:scaling', updateInputFromCanvas);
    canvasInstance.off('object:modified', updateInputFromCanvas);
    canvasInstance.off('object:moving', updateInputFromCanvas);
  }

  if (props.isExpanded) {
    closeCropPanel();
  }
});
</script>

<style scoped>
/* ä¿æŒæ‰€æœ‰æ ·å¼ä¸å˜ */
.ratio-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin-bottom: 16px;
}

.ratio-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 10px 4px;
  border: 1px solid #f2f2f2;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  color: #666;
  background: #fff;
  transition: all 0.2s;
  height: 60px;
}

.ratio-item:hover {
  background-color: #f9f9f9;
  border-color: #dcdfe6;
}

.ratio-item.active {
  border-color: var(--ie-primary-color);
  color: var(--ie-primary-color);
  background-color: #ecf5ff;
}

.icon-box {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 6px;
}

.shape-rect {
  border: 1px solid currentColor;
  margin-bottom: 6px;
  box-sizing: border-box;
}

.shape-rect.dashed {
  border-style: dashed;
  width: 14px;
  height: 14px;
}

.shape-rect.square {
  width: 14px;
  height: 14px;
}

.custom-input-box {
  background-color: #f8f9fa;
  border: none;
  border-radius: 6px;
  padding: 10px;
  margin-bottom: 12px;
}

.input-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;
  color: #333;
  margin-bottom: 8px;
}

.input-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.input-wrapper {
  position: relative;
  width: 38%;
}

.ie-input {
  text-align: center;
  padding-right: 20px;
  font-weight: 500;
  color: #333;
}

.suffix {
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  color: #c0c4cc;
  font-size: 12px;
  pointer-events: none;
}

.link-icon {
  width: 24px;
  display: flex;
  justify-content: center;
  cursor: pointer;
}

.rotate-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 0 10px;
}

.action-btn {
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  cursor: pointer;
  color: #606266;
  font-size: 18px;
  background-color: #f5f7fa;
  transition: all 0.2s;
}

.action-btn:hover {
  background-color: #e6e8eb;
  color: #333;
}

.divider {
  width: 1px;
  height: 20px;
  background-color: #eee;
}

.confirm-row {
  display: flex;
  gap: 10px;
}

.full-btn {
  flex: 1;
}
</style>
</file>

<file path="src/components/modules/adjust/index.vue">
<template>
  <div class="panel-adjust">
    <div class="tool-list">
      <AdjustCrop
        :is-expanded="activeCollapse === 'crop'"
        @toggle="toggle('crop')"
      />
      <AdjustResize
        :is-expanded="activeCollapse === 'resize'"
        @toggle="toggle('resize')"
      />
      <AdjustInpaint
        :is-expanded="activeCollapse === 'inpaint'"
        @toggle="toggle('inpaint')"
      />
      <AdjustRembg
        :is-expanded="activeCollapse === 'rembg'"
        @toggle="toggle('rembg')"
      />

      <AdjustRuler
        :is-expanded="activeCollapse === 'ruler'"
        @toggle="toggle('ruler')"
      />

      <AdjustWhite
        :is-expanded="activeCollapse === 'white'"
        @toggle="toggle('white')"
      />
      <AdjustColor
        :is-expanded="activeCollapse === 'color'"
        @toggle="toggle('color')"
      />
      <AdjustColorOverlay
        :is-expanded="activeCollapse === 'overlay'"
        @toggle="toggle('overlay')"
      />
      <AdjustFilters
        :is-expanded="activeCollapse === 'filters'"
        @toggle="toggle('filters')"
      />
      <AdjustMosaic
        :is-expanded="activeCollapse === 'mosaic'"
        @toggle="toggle('mosaic')"
      />
    </div>
  </div>
</template>

<script setup>
import { ref, defineAsyncComponent, watch } from "vue";
import { useEditorState } from "@/composables/useEditorState";

// å¼‚æ­¥ç»„ä»¶åŠ è½½
const AdjustCrop = defineAsyncComponent(() => import("./AdjustCrop.vue"));
const AdjustResize = defineAsyncComponent(() => import("./AdjustResize.vue"));
const AdjustInpaint = defineAsyncComponent(() => import("./AdjustInpaint.vue"));
const AdjustRembg = defineAsyncComponent(() => import("./AdjustRembg.vue"));
const AdjustWhite = defineAsyncComponent(() => import("./AdjustWhite.vue"));
const AdjustColor = defineAsyncComponent(() => import("./AdjustColor.vue"));
const AdjustFilters = defineAsyncComponent(() => import("./AdjustFilters.vue"));
const AdjustColorOverlay = defineAsyncComponent(() =>
  import("./AdjustColorOverlay.vue")
);
const AdjustMosaic = defineAsyncComponent(() => import("./AdjustMosaic.vue"));
const AdjustRuler = defineAsyncComponent(() => import("./AdjustRuler.vue"));

const activeCollapse = ref("");
// âœ¨ è·å– setActiveTab æ–¹æ³•
const { state, setActiveTab } = useEditorState();

// ç›‘å¬è·¯ç”±å˜åŒ–ï¼Œè‡ªåŠ¨å±•å¼€å¯¹åº”é¢æ¿
watch(
  () => state.activeTab,
  (newTab) => {
    const validTabs = [
      "crop",
      "resize",
      "inpaint",
      "rembg",
      "ruler",
      "white",
      "color",
      "overlay",
      "filters",
      "mosaic",
    ];

    // åªæœ‰å½“ newTab æœ‰æ•ˆæ—¶æ‰å±•å¼€
    // å¦‚æœ newTab è¢«ç½®ç©ºï¼Œè¿™é‡Œä¸å¤„ç†ï¼Œç”± toggle é€»è¾‘æ¥ç®¡
    if (newTab && validTabs.includes(newTab)) {
      console.log("[AdjustPanel] Auto expanding:", newTab);
      activeCollapse.value = newTab;
    }
  },
  { immediate: true }
);

// æ‰‹åŠ¨åˆ‡æ¢æŠ˜å çŠ¶æ€
const toggle = (id) => {
  if (activeCollapse.value === id) {
    // åŠ¨ä½œï¼šæ‰‹åŠ¨å…³é—­
    activeCollapse.value = "";

    // âœ¨âœ¨âœ¨ ä¿®å¤ç‚¹ï¼šä½¿ç”¨å®˜æ–¹æ–¹æ³•æ¸…ç†çŠ¶æ€ âœ¨âœ¨âœ¨
    // å¦‚æœå½“å‰å…¨å±€çŠ¶æ€æ­£æŒ‡ç€è¿™ä¸ªé¢æ¿ï¼Œå¿…é¡»æŠŠå®ƒæ¸…ç†æ‰
    // å¦åˆ™ä¸‹æ¬¡ç‚¹å‡»åŒä¸€ä¸ªç‰©ä½“æ—¶ï¼ŒçŠ¶æ€ä» 'ruler' å˜ 'ruler'ï¼Œwatch ä¸ä¼šè§¦å‘
    if (state.activeTab === id) {
      setActiveTab(""); // âœ… åˆæ³•ä¿®æ”¹ï¼Œä¸ä¼šè¢« readonly æ‹¦æˆª
    }
  } else {
    // åŠ¨ä½œï¼šæ‰‹åŠ¨å±•å¼€
    activeCollapse.value = id;
    // ä¿æŒåŒæ­¥
    setActiveTab(id);
  }
};
</script>
</file>

<file path="src/components/modules/adjust/useCanvasCrop.js">
// src/components/modules/adjust/useCanvasCrop.js
import { ref, shallowRef, toRaw } from "vue";
import { fabric } from "fabric";

// 1. å¼•å…¥é€šç”¨è§„èŒƒå·¥å…·
import { getLogicRect, animateRebound, constrainObjectToRect } from '@/composables/useConstraint';
import { renderHighResSnapshot } from '@/composables/useOffscreenHelper';

// === çŠ¶æ€å˜é‡ ===
const cropObject = shallowRef(null);
const isManualCropping = ref(false);
const isCropping = ref(false);
const isRatioLocked = ref(false);
const currentAspectRatio = ref(null);

// ç”¨äºå®æ—¶å‘ UI ä¼ é€’å½“å‰é€‰åŒº/è£å‰ªæ¡†çš„å®½é«˜
const currentSelectionDims = ref({ width: 0, height: 0 });

// å†…éƒ¨å¼•ç”¨
let canvasRef = null;
let saveHistoryFn = null;
let zoomToRectFn = null;

// å†…éƒ¨å˜é‡
let selectionRect = null;
let maskRect = null;
let selectionStartX = 0;
let selectionStartY = 0;
let aspectRatioValue = null;
let savedWheelListeners = [];

// æ‹–æ‹½å›¾ç‰‡ç›¸å…³å˜é‡
let isDraggingImage = false;
let dragLastX = 0;
let dragLastY = 0;

// æ ‡å¿—ä½ï¼šæ˜¯å¦æ­£åœ¨åº”ç”¨è£å‰ª
let isApplyingCrop = false;

export const registerCropModule = (canvas, saveHistory, zoomToRect) => {
  canvasRef = canvas;
  saveHistoryFn = saveHistory;
  zoomToRectFn = zoomToRect;
};

// =========================================================
// è¾…åŠ©å·¥å…·
// =========================================================

const updateCurrentDims = (obj) => {
  if (!obj || !canvasRef?.value) return;
  const rect = getLogicRect(obj, canvasRef.value);
  currentSelectionDims.value = {
    width: Math.round(rect.width),
    height: Math.round(rect.height)
  };
};

const preventZoomWheel = (opt) => {
  if (!opt || !opt.e) return;
  opt.e.preventDefault();
  opt.e.stopPropagation();
  if (opt.e.stopImmediatePropagation) opt.e.stopImmediatePropagation();
};

// =========================================================
// æ‹–åŠ¨å›¾ç‰‡çš„æ ¸å¿ƒé€»è¾‘ (é›†æˆé€šç”¨å›å¼¹)
// =========================================================
const onCropMouseDown = (opt) => {
  if (!canvasRef?.value || !cropObject.value) return;
  const target = opt.target;
  // å¿…é¡»ç‚¹å‡»åœ¨å‰ªè£æ¡†ä¸Šï¼ˆä½œä¸ºå®¹å™¨ï¼‰
  if (target !== cropObject.value) return;

  const activeObj = canvasRef.value.getActiveObject();
  if (activeObj && activeObj.__corner) return;

  // å¼€å§‹æ‹–åŠ¨å›¾ç‰‡
  isDraggingImage = true;
  const pointer = canvasRef.value.getPointer(opt.e);
  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvasRef.value.defaultCursor = 'move';
};

const onCropMouseMove = (opt) => {
  if (!isDraggingImage || !canvasRef?.value) return;
  const canvas = canvasRef.value;
  const pointer = canvas.getPointer(opt.e);
  const deltaX = pointer.x - dragLastX;
  const deltaY = pointer.y - dragLastY;

  const bgImage = canvas.getObjects().find(o => o.type === 'image');

  if (bgImage) {
    // è‡ªç”±æ‹–æ‹½ï¼Œæš‚ä¸çº¦æŸï¼Œä¾é  mouseUp æ—¶çš„å›å¼¹
    bgImage.left += deltaX;
    bgImage.top += deltaY;
    bgImage.setCoords();
  }

  dragLastX = pointer.x;
  dragLastY = pointer.y;
  canvas.requestRenderAll();
};

const onCropMouseUp = () => {
  if (isDraggingImage) {
    if (canvasRef?.value && cropObject.value) {
      const bgImage = canvasRef.value.getObjects().find(o => o.type === 'image');
      if (bgImage) {
        // ã€æ ¸å¿ƒå‡çº§ã€‘ä½¿ç”¨é€šç”¨åŠ¨ç”»å›å¼¹ï¼Œç¡®ä¿å›¾ç‰‡å§‹ç»ˆå¡«æ»¡è£å‰ªæ¡†
        animateRebound(bgImage, cropObject.value, canvasRef.value);
      }
    }

    isDraggingImage = false;
    if (canvasRef?.value) canvasRef.value.defaultCursor = 'default';
  }
};

// =========================================================
// é¢æ¿å¼€å…³
// =========================================================
export const openCropPanel = () => {
  if (!canvasRef?.value) return;
  if (isCropping.value) return;

  isApplyingCrop = false;

  const canvas = canvasRef.value;
  canvas.fire('zoom:change', { from: 'crop-module' });

  if (canvas.__eventListeners && canvas.__eventListeners['mouse:wheel']) {
    savedWheelListeners = [...canvas.__eventListeners['mouse:wheel']];
    canvas.off('mouse:wheel');
  }
  canvas.on('mouse:wheel', preventZoomWheel);

  isCropping.value = true;
};

export const closeCropPanel = () => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;

  if (isApplyingCrop) {
    if (isManualCropping.value) endManualSelectionMode();
    isCropping.value = false;
    return;
  }

  if (isManualCropping.value) {
    endManualSelectionMode();
  }

  cancelCrop();
  isCropping.value = false;

  canvas.discardActiveObject();
  canvas.requestRenderAll();
  canvas.fire('zoom:change');
};

// =========================================================
// çº¦æŸè£å‰ªæ¡† (ä¿æŒåœ¨å›¾ç‰‡èŒƒå›´å†…)
// æ³¨æ„ï¼šè£å‰ªæ¡†çš„çº¦æŸé€»è¾‘ç‰¹æ®Šï¼ˆBox inside Imageï¼‰ï¼Œä¸ Resizeï¼ˆImage inside Boxï¼‰ç›¸å
// å› æ­¤ä¿ç•™äº†éƒ¨åˆ†ç‰¹å®šçš„å°ºå¯¸æ£€æŸ¥é€»è¾‘ï¼Œä½†ä½ç½®ä¿®æ­£å¯å¤ç”¨é€»è¾‘
// =========================================================
export const constrainCrop = (activeObj) => {
  if (!canvasRef?.value || !activeObj) return;
  const canvas = canvasRef.value;

  const bgImage = canvas.getObjects().find((o) => o.type === "image");
  if (!bgImage) return;

  const bgRect = getLogicRect(bgImage, canvas);
  const bgWidth = bgRect.width;
  const bgHeight = bgRect.height;
  const bgLeft = bgRect.left;
  const bgTop = bgRect.top;

  let currentScaleX = activeObj.scaleX;
  let currentScaleY = activeObj.scaleY;

  // 1. å°ºå¯¸çº¦æŸï¼šè£å‰ªæ¡†ä¸èƒ½æ¯”å›¾ç‰‡å¤§
  let cropCurrentWidth = activeObj.width * currentScaleX;
  let cropCurrentHeight = activeObj.height * currentScaleY;
  let sizeChanged = false;

  if (cropCurrentWidth > bgWidth + 0.5) {
    currentScaleX = bgWidth / activeObj.width;
    sizeChanged = true;
  }
  if (cropCurrentHeight > bgHeight + 0.5) {
    currentScaleY = bgHeight / activeObj.height;
    sizeChanged = true;
  }
  if (sizeChanged) {
    activeObj.set({ scaleX: currentScaleX, scaleY: currentScaleY });
    activeObj.setCoords();
  }

  // 2. ä½ç½®çº¦æŸï¼šè£å‰ªæ¡†å¿…é¡»åœ¨å›¾ç‰‡å†…éƒ¨
  // è®¡ç®—è¾¹ç•Œ
  const finalCropWidth = activeObj.getScaledWidth();
  const finalCropHeight = activeObj.getScaledHeight();

  // é™åˆ¶å·¦ä¸Šè§’åæ ‡
  const minLeft = bgLeft;
  const maxLeft = bgLeft + bgWidth - finalCropWidth;
  const minTop = bgTop;
  const maxTop = bgTop + bgHeight - finalCropHeight;

  let newLeft = Math.max(minLeft, Math.min(activeObj.left, maxLeft));
  let newTop = Math.max(minTop, Math.min(activeObj.top, maxTop));

  activeObj.set({ left: newLeft, top: newTop });
  activeObj.setCoords();

  updateCurrentDims(activeObj);
  canvas.requestRenderAll();
};

// =========================================================
// å–æ¶ˆè£å‰ª (æ¸…ç†)
// =========================================================
export const cancelCrop = (shouldRender = true) => {
  if (canvasRef?.value && cropObject.value) {
    const rawObj = toRaw(cropObject.value);

    // è§£ç»‘æ‹–æ‹½å›¾ç‰‡äº‹ä»¶
    canvasRef.value.off('mouse:down', onCropMouseDown);
    canvasRef.value.off('mouse:move', onCropMouseMove);
    canvasRef.value.off('mouse:up', onCropMouseUp);

    canvasRef.value.remove(rawObj);
    cropObject.value = null;
    isDraggingImage = false;

    if (shouldRender) {
      canvasRef.value.renderAll();
    }
  }
};

// ... (æ‰‹åŠ¨é€‰åŒºé€»è¾‘ä¿æŒä¸å˜) ...
export const endManualSelectionMode = () => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;
  canvas.defaultCursor = 'default';
  canvas.hoverCursor = 'move';
  canvas.selection = true;
  canvas.getObjects().forEach(o => {
    if (o !== maskRect && o !== selectionRect) {
      o.selectable = true;
      o.evented = true;
    }
  });
  canvas.off('mouse:down', onSelectionDown);
  canvas.off('mouse:move', onSelectionMove);
  canvas.off('mouse:up', onSelectionUp);
  if (selectionRect) { canvas.remove(selectionRect); selectionRect = null; }
  if (maskRect) { canvas.remove(maskRect); maskRect = null; }
  isManualCropping.value = false;
  canvas.requestRenderAll();
};

const onSelectionDown = (opt) => {
  const canvas = canvasRef.value;
  if (!canvas) return;
  const pointer = canvas.getPointer(opt.e);
  selectionStartX = pointer.x;
  selectionStartY = pointer.y;
  selectionRect = new fabric.Rect({
    left: selectionStartX, top: selectionStartY, width: 0, height: 0,
    fill: 'transparent', stroke: '#fff', strokeWidth: 2, strokeDashArray: [6, 6],
    selectable: false, evented: false
  });
  canvas.add(selectionRect);
  canvas.bringToFront(selectionRect);
};

const onSelectionMove = (opt) => {
  if (!selectionRect || !canvasRef.value) return;
  const pointer = canvasRef.value.getPointer(opt.e);
  let w = Math.abs(pointer.x - selectionStartX);
  let h = Math.abs(pointer.y - selectionStartY);
  let left = selectionStartX;
  let top = selectionStartY;
  if (pointer.x < selectionStartX) left = pointer.x;
  if (pointer.y < selectionStartY) top = pointer.y;
  selectionRect.set({ left, top, width: w, height: h });
  currentSelectionDims.value = { width: Math.round(w), height: Math.round(h) };
  canvasRef.value.requestRenderAll();
};

const onSelectionUp = () => {
  if (!selectionRect) {
    endManualSelectionMode();
    if (cropObject.value) cancelCrop();
    return;
  }
  const box = {
    left: selectionRect.left, top: selectionRect.top,
    width: selectionRect.width, height: selectionRect.height
  };
  endManualSelectionMode();
  if (box.width < 10 || box.height < 10) return;
  startCrop(null, box);
  if (zoomToRectFn) zoomToRectFn(box);
};

export const startManualSelection = () => {
  if (!canvasRef?.value) return;
  if (isManualCropping.value) endManualSelectionMode();
  const canvas = canvasRef.value;
  cancelCrop();
  canvas.getObjects().forEach(o => { o.selectable = false; o.evented = false; });
  maskRect = new fabric.Rect({
    left: -5000, top: -5000, width: 20000, height: 20000,
    fill: 'rgba(0, 0, 0, 0.45)', selectable: false, evented: false, excludeFromExport: true
  });
  canvas.add(maskRect);
  canvas.defaultCursor = 'crosshair';
  canvas.hoverCursor = 'crosshair';
  canvas.selection = false;
  isManualCropping.value = true;
  canvas.on('mouse:down', onSelectionDown);
  canvas.on('mouse:move', onSelectionMove);
  canvas.on('mouse:up', onSelectionUp);
  canvas.requestRenderAll();
};

// ... (setCropRatio ä¿æŒä¸å˜) ...
export const setCropRatio = (ratio) => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;
  if (ratio === null) {
    isRatioLocked.value = false;
    currentAspectRatio.value = null;
    if (cropObject.value) {
      cropObject.value.set({ lockUniScaling: false });
      canvas.requestRenderAll();
    }
    return;
  }
  isRatioLocked.value = true;
  currentAspectRatio.value = ratio;
  let baseW, baseH, left, top;
  const activeObj = canvas.getObjects().find((obj) => obj.type === "image");
  if (!activeObj) return;

  // ä½¿ç”¨ getLogicRect è·å–å‡†ç¡®çš„åŒ…å›´ç›’
  const rect = getLogicRect(activeObj, canvas);
  baseW = rect.width; baseH = rect.height; left = rect.left; top = rect.top;

  const currentRatio = baseW / baseH;
  let newW, newH;
  if (currentRatio > ratio) {
    newH = baseH; newW = newH * ratio; left += (baseW - newW) / 2;
  } else {
    newW = baseW; newH = newW / ratio; top += (baseH - newH) / 2;
  }
  if (cropObject.value) {
    cropObject.value.set({
      width: newW, height: newH, left: left, top: top,
      scaleX: 1, scaleY: 1, lockUniScaling: false
    });
    cropObject.value.setCoords();
    constrainCrop(cropObject.value);
    canvas.requestRenderAll();
  } else {
    startCrop(ratio, { left, top, width: newW, height: newH });
  }
};

// =========================================================
// startCrop
// =========================================================
export const startCrop = (aspectRatio = null, customBox = null) => {
  if (!canvasRef?.value) return;
  const canvas = canvasRef.value;
  if (isManualCropping.value) endManualSelectionMode();

  aspectRatioValue = aspectRatio || null;
  let activeObj = canvas.getObjects().find((obj) => obj.type === "image");
  if (!activeObj) return;

  cancelCrop();

  const rect = getLogicRect(activeObj, canvas);
  let width, height, left, top;

  if (customBox) {
    width = customBox.width; height = customBox.height; left = customBox.left; top = customBox.top;
  } else {
    const imgWidth = rect.width; const imgHeight = rect.height;
    width = imgWidth * 1; height = imgHeight * 1;
    if (aspectRatio) {
      height = width / aspectRatio;
      if (height > imgHeight) {
        height = imgHeight; width = height * aspectRatio;
      }
      isRatioLocked.value = true; currentAspectRatio.value = aspectRatio;
    } else {
      isRatioLocked.value = false; currentAspectRatio.value = null;
    }
    left = rect.left + (imgWidth - width) / 2;
    top = rect.top + (imgHeight - height) / 2;
  }

  const cropZone = new fabric.Rect({
    left: left, top: top, width: width, height: height,
    fill: "transparent", stroke: "#409eff", strokeWidth: 2,
    cornerColor: "white", cornerStrokeColor: "#409eff", cornerSize: 12,
    transparentCorners: false, lockRotation: true, hasRotatingPoint: false,
    lockUniScaling: false,
    lockMovementX: true,
    lockMovementY: true,
    customTool: 'adjust', customTab: 'crop' // âœ¨ æ·»åŠ è‡ªå®šä¹‰è·¯ç”±å±æ€§ï¼Œç¡®ä¿è£å‰ªæ¡†è¢«è¯†åˆ«ä¸ºè°ƒæ•´å·¥å…·
  });
  if (aspectRatio) cropZone.set("height", width / aspectRatio);

  canvas.add(cropZone);
  canvas.setActiveObject(cropZone);
  cropObject.value = cropZone;
  canvas.renderAll();
  updateCurrentDims(cropZone);
  constrainCrop(cropZone);

  // ç»‘å®šæ‹–å›¾äº‹ä»¶
  canvas.on('mouse:down', onCropMouseDown);
  canvas.on('mouse:move', onCropMouseMove);
  canvas.on('mouse:up', onCropMouseUp);
};

// =========================================================
// ç¡®è®¤è£å‰ª (é«˜æ¸…é‡åˆ¶ç‰ˆ)
// =========================================================
export const confirmCrop = async () => {
  if (!canvasRef?.value || !cropObject.value) return Promise.resolve();
  const canvas = canvasRef.value;
  const cropRect = cropObject.value;
  const bgImage = canvas.getObjects().find((o) => o.type === "image");
  if (!bgImage) { cancelCrop(); return Promise.resolve(); }

  isApplyingCrop = true;

  // 1. è·å–è£å‰ªåŒºåŸŸçš„é€»è¾‘ä¿¡æ¯
  const cropLogicRect = getLogicRect(cropRect, canvas);
  const bgLogicRect = getLogicRect(bgImage, canvas);

  // 2. è®¡ç®—ç›®æ ‡å¯¼å‡ºå°ºå¯¸ (åŸºäºåŸå›¾åˆ†è¾¨ç‡)
  // å¦‚æœå›¾ç‰‡è¢«ç¼©æ”¾äº†(scale=0.5), æˆ‘ä»¬å¸Œæœ›è£å‰ªå‡ºæ¥çš„å›¾æ˜¯åŸºäºåŸå›¾å¤§å°çš„ï¼Œæ‰€ä»¥ç›®æ ‡å°ºå¯¸è¦é™¤ä»¥ scale
  const scaleFactor = bgImage.scaleX; // å‡è®¾å‡åŒ€ç¼©æ”¾
  const targetW = Math.round(cropLogicRect.width / scaleFactor);
  const targetH = Math.round(cropLogicRect.height / scaleFactor);

  if (targetW <= 0 || targetH <= 0) {
    cancelCrop();
    return Promise.resolve();
  }

  // ä¸´æ—¶éšè—è£å‰ªæ¡†ï¼Œé¿å…å¹²æ‰°
  cropRect.visible = false;

  // 3. ä½¿ç”¨ç¦»å±æ¸²æŸ“ç”Ÿæˆé«˜æ¸…è£å‰ªå›¾
  const croppedDataUrl = await renderHighResSnapshot(bgImage, targetW, targetH, (highResImg) => {
    // 3.1 è®¡ç®—ç›¸å¯¹ä½ç½®åç§» (ä½¿ç”¨ä¸­å¿ƒç‚¹å·®å€¼æ³•ï¼ŒæŠ—æ—‹è½¬å¹²æ‰°)
    const cropCenter = cropRect.getCenterPoint();
    const imgCenter = bgImage.getCenterPoint();

    // è®¡ç®—ä¸­å¿ƒç‚¹å·®è·ï¼ˆé€»è¾‘åƒç´ ï¼‰
    const diffX = imgCenter.x - cropCenter.x;
    const diffY = imgCenter.y - cropCenter.y;

    // æ˜ å°„åˆ°åŸå›¾å°ºåº¦
    const finalDiffX = diffX / scaleFactor;
    const finalDiffY = diffY / scaleFactor;

    // 3.2 è®¾ç½®é«˜åˆ†å›¾å±æ€§
    highResImg.set({
      originX: 'center', originY: 'center',
      left: targetW / 2 + finalDiffX,
      top: targetH / 2 + finalDiffY,
      scaleX: 1, // æ¢å¤åˆ°åŸå›¾æ¯”ä¾‹
      scaleY: 1,
      angle: bgImage.angle,
      flipX: bgImage.flipX,
      flipY: bgImage.flipY
    });
  });

  cropRect.visible = true;

  return new Promise((resolve) => {
    // 4. åº”ç”¨å›ä¸»ç”»å¸ƒ
    bgImage.setSrc(croppedDataUrl, () => {
      cancelCrop(false);

      // 5. ç‰©ç†é‡ç½®ï¼šå°†æ–°å›¾ç‰‡æ”¾å›ç”»å¸ƒä¸­å¿ƒ
      bgImage.set({
        originX: "center", originY: "center",
        left: canvas.width / 2, top: canvas.height / 2,
        scaleX: 1, scaleY: 1, // è£å‰ªåå°±æ˜¯ 1:1
        angle: 0, flipX: false, flipY: false,
      });
      bgImage.setCoords();
      canvas.centerObject(bgImage);

      // 6. è§†å£è‡ªé€‚åº” (Zoom to fit)
      // è®©è£å‰ªåçš„å›¾ç‰‡åœ¨å±å¹•ä¸Šæ˜¾ç¤ºå¤§å°åˆé€‚
      const paddingFactor = 0.85;
      const zoomToFit = Math.min(
        (canvas.width * paddingFactor) / targetW, // æ³¨æ„è¿™é‡Œç”¨ targetW å¯èƒ½ä¼šå¾ˆå¤§
        (canvas.height * paddingFactor) / targetH
      );

      // å› ä¸º targetW æ˜¯åŸå›¾å°ºå¯¸ï¼Œå¯èƒ½å‡ åƒåƒç´ ï¼Œæˆ‘ä»¬è¿™é‡Œè®¡ç®—çš„æ˜¯ Zoom Level
      // å®é™…ä¸Šå±•ç¤ºæ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒå æ®å±å¹•å¤§éƒ¨åˆ†
      // é‡æ–°è®¡ç®—ï¼šå›¾ç‰‡ç°åœ¨å°ºå¯¸æ˜¯ targetW * 1 * zoomToFit
      // æ‰€ä»¥ Zoom åº”è¯¥æ˜¯ canvasSize / targetSize

      // è®¾ç½®æ–°çš„è§†å£
      canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); // å…ˆé‡ç½®
      const newZoom = zoomToFit;
      const center = canvas.getCenter();
      canvas.zoomToPoint({ x: center.left, y: center.top }, newZoom);

      isApplyingCrop = false;
      isCropping.value = false;
      canvas.fire('zoom:change', { from: 'crop-confirm' });
      canvas.requestRenderAll();
      if (saveHistoryFn) saveHistoryFn();
      resolve();
    });
  });
};

export const setCropBoxSize = (width, height) => {
  if (!cropObject.value || !canvasRef?.value) return;
  const obj = cropObject.value;
  const oldRealWidth = obj.getScaledWidth();
  const oldRealHeight = obj.getScaledHeight();
  const centerX = obj.left + oldRealWidth / 2;
  const centerY = obj.top + oldRealHeight / 2;
  obj.set({ width: width, height: height, scaleX: 1, scaleY: 1 });
  const newLeft = centerX - width / 2;
  const newTop = centerY - height / 2;
  obj.set({ left: newLeft, top: newTop });
  obj.setCoords();
  constrainCrop(obj);
  canvasRef.value.requestRenderAll();
};

export const rotateActive = (angle) => {
  if (cropObject.value && canvasRef?.value) {
    const canvas = canvasRef.value;
    const bgImage = canvas.getObjects().find((o) => o.type === "image");
    if (bgImage) {
      bgImage.rotate((bgImage.angle || 0) + angle);
      canvas.centerObject(bgImage);
      bgImage.setCoords();
      canvas.renderAll();
      startCrop(aspectRatioValue);
    }
    return true;
  }
  return false;
};

export const flipActive = (axis) => {
  if (cropObject.value && canvasRef?.value) {
    const canvas = canvasRef.value;
    const bgImage = canvas.getObjects().find((o) => o.type === "image");
    if (bgImage) {
      if (axis === "X") bgImage.set("flipX", !bgImage.flipX);
      if (axis === "Y") bgImage.set("flipY", !bgImage.flipY);
      canvas.requestRenderAll();
    }
    return true;
  }
  return false;
};

export {
  cropObject,
  isManualCropping,
  isRatioLocked,
  currentAspectRatio,
  isCropping,
  currentSelectionDims
};
</file>

<file path="src/components/Workspace.vue">
<template>
  <div class="workspace-container">
    <div class="canvas-center" ref="canvasContainer" @contextmenu.prevent="handleRightClick">
      <canvas id="c"></canvas>
    </div>

    <FloatingObjectMenu />

    <CanvasContextMenu :visible="showContextMenu" :position="contextMenuPos" @close="closeContextMenu"
      @paste="handleMenuPaste" />

    <ShortcutsPanel :visible="showShortcuts" @close="showShortcuts = false" />

    <div class="zoom-controls">
      <button 
        class="ie-btn ie-btn-circle control-btn" 
        :class="{ 'is-active': state.isGlobalDragMode }"
        @click="toggleDragMode"
        :title="state.isGlobalDragMode ? 'é€€å‡ºæ‹–æ‹½æ¨¡å¼' : 'è¿›å…¥æ‹–æ‹½æ¨¡å¼ (ç©ºæ ¼é”®)'"
      >
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v5" />
           <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v10" />
           <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" />
           <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" />
        </svg>
      </button>

      <button class="ie-btn ie-btn-circle" title="å¿«æ·é”®åˆ—è¡¨" @click="showShortcuts = true">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <rect x="2" y="4" width="20" height="16" rx="2" ry="2"></rect>
          <path d="M6 8h.01"></path>
          <path d="M10 8h.01"></path>
          <path d="M14 8h.01"></path>
          <path d="M18 8h.01"></path>
          <path d="M6 12h.01"></path>
          <path d="M18 12h.01"></path>
          <path d="M7 16h10"></path>
          <path d="M12 12v-1"></path>
        </svg>
      </button>

      <div class="divider"></div>

      <button class="ie-btn ie-btn-circle" title="ç¼©å°" @click="handleZoomOut">
        <svg viewBox="0 0 1024 1024" width="16" height="16">
          <path d="M128 544h768a32 32 0 1 0 0-64H128a32 32 0 1 0 0 64z" fill="currentColor" />
        </svg>
      </button>

      <span class="zoom-text" @click="handleReset" title="ç‚¹å‡»é‡ç½®ä¸º100%">
        {{ zoomPercentage }}%
      </span>

      <button class="ie-btn ie-btn-circle" title="æ”¾å¤§" @click="handleZoomIn">
        <svg viewBox="0 0 1024 1024" width="16" height="16">
          <path
            d="M480 480H160a32 32 0 0 0 0 64h320v320a32 32 0 0 0 64 0V544h320a32 32 0 0 0 0-64H544V160a32 32 0 0 0-64 0v320z"
            fill="currentColor" />
        </svg>
      </button>
    </div>
  </div>
</template>

<script setup>
import { onMounted, inject, ref, watch, computed, onUnmounted, unref } from 'vue';
import FloatingObjectMenu from "./common/FloatingObjectMenu.vue";
import CanvasContextMenu from "./common/CanvasContextMenu.vue";
import { useObjectActions } from "@/composables/useObjectActions";
import { useKeyboardShortcuts } from "@/composables/useKeyboardShortcuts";
import ShortcutsPanel from "@/components/common/ShortcutsPanel.vue";
import { useEditorState } from '@/composables/useEditorState';
import { useCanvasLock } from '@/composables/useCanvasLock';

const { state, setGlobalDragMode } = useEditorState();
const { setBackgroundLock } = useCanvasLock();

const props = defineProps({
  imageUrl: {
    type: String,
    default: ''
  },
});

const canvasAPI = inject('canvasAPI');
const canvasContainer = ref(null);
const pastePosition = ref(null);
const showShortcuts = ref(false);

// è®¡ç®—å±æ€§
const zoomPercentage = computed(() => {
  return canvasAPI?.zoom?.value ? Math.round(canvasAPI.zoom.value * 100) : 100;
});

// æ“ä½œå¤„ç†
const handleZoomIn = () => canvasAPI?.zoomIn && canvasAPI.zoomIn();
const handleZoomOut = () => canvasAPI?.zoomOut && canvasAPI.zoomOut();
const handleReset = () => canvasAPI?.zoomReset && canvasAPI.zoomReset();

const updateZoomState = () => {
  const fabricCanvas = canvasAPI?.canvas?.value;
  if (fabricCanvas && canvasAPI.zoom) {
    canvasAPI.zoom.value = fabricCanvas.getZoom();
  }
};

/**
 * âœ¨ åŒæ­¥ç‰©ç†é”çŠ¶æ€
 * å¢åŠ  isRulerMode æ ‡è®°ä¼ é€’
 */
const syncLockState = () => {
  const canvas = unref(canvasAPI.canvas);
  if (!canvas) return;

  const isRulerModule = state.activeTab === 'ruler';
  
  setBackgroundLock(canvas, true, { 
      excludeRulers: isRulerModule, 
      dragMode: state.isGlobalDragMode,
      isRulerMode: isRulerModule // âœ¨ æ˜ç¡®å‘ŠçŸ¥ç‰©ç†é”å½“å‰æ˜¯å¦åœ¨æ ‡å°ºæ¨¡å¼
  });
};

const toggleDragMode = () => {
    const newMode = !state.isGlobalDragMode;
    setGlobalDragMode(newMode);
    syncLockState();
};

// === å³é”®èœå•é€»è¾‘ ===
const actions = useObjectActions();
useKeyboardShortcuts(actions);
const showContextMenu = ref(false);
const contextMenuPos = ref({ x: 0, y: 0 });

const closeContextMenu = () => {
  showContextMenu.value = false;
};

const onGlobalClick = () => {
  if (showContextMenu.value) closeContextMenu();
};

const handleRightClick = (e) => {
  if (e.target.closest('.floating-wrapper')) return;

  contextMenuPos.value = { x: e.clientX, y: e.clientY };

  const canvas = unref(canvasAPI.canvas);
  if (canvas) {
    const pointer = canvas.getPointer(e);
    pastePosition.value = pointer;
  }

  showContextMenu.value = true;
};

const handleMenuPaste = () => {
  actions.pasteActive(pastePosition.value);
};

onMounted(() => {
  window.addEventListener('click', onGlobalClick);
  if (canvasAPI && canvasAPI.init) {
    const width = canvasContainer.value.clientWidth || 1900;
    const height = canvasContainer.value.clientHeight || 1000;
    canvasAPI.init('c', width, height);

    const fabricCanvas = canvasAPI.canvas.value;
    if (fabricCanvas) {
      fabricCanvas.on('zoom:change', updateZoomState);
      fabricCanvas.on('mouse:wheel', updateZoomState);
      fabricCanvas.on('image:updated', syncLockState);
      window.canvas = fabricCanvas; // âœ¨ ä¸´æ—¶æš´éœ²ç»™å…¨å±€ï¼Œæ–¹ä¾¿è°ƒè¯•
    }
  }

  syncLockState();
});

watch(() => state.activeTab, () => {
  syncLockState();
});


onUnmounted(() => {
  const fabricCanvas = canvasAPI?.canvas?.value;
  if (fabricCanvas) {
    fabricCanvas.off('zoom:change', updateZoomState);
    fabricCanvas.off('mouse:wheel', updateZoomState);
    fabricCanvas.off('image:updated', syncLockState);
  }
  window.removeEventListener('click', onGlobalClick);
  
  const canvas = unref(canvasAPI.canvas);
  if (canvas) {
    setBackgroundLock(canvas, true, { dragMode: false });
  }
});
</script>

<style scoped>
.workspace-container {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  background-color: #f0f2f5;
  overflow: hidden;
}

.canvas-center {
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
  width: 95%;
  height: 95%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.zoom-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background: white;
  padding: 8px 12px;
  border-radius: 24px;
  display: flex;
  align-items: center;
  gap: 8px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
  z-index: 100;
}

.zoom-text {
  font-size: 13px;
  color: #606266;
  min-width: 45px;
  text-align: center;
  user-select: none;
  font-variant-numeric: tabular-nums;
  cursor: pointer;
  transition: color 0.2s;
}

.zoom-text:hover {
  color: var(--ie-primary-color);
}

.ie-btn {
  border: none;
  background: transparent;
  cursor: pointer;
  color: #606266;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
}

.ie-btn:hover {
  color: var(--ie-primary-color);
  background-color: #ecf5ff;
}

.ie-btn-circle {
  width: 32px;
  height: 32px;
  border-radius: 50%;
}

.control-btn.is-active {
  background: var(--ie-primary-color);
  color: white;
  border-color: var(--ie-primary-color);
}

.zoom-controls .divider {
  width: 1px;
  height: 16px;
  background: #ebeef5;
  margin: 0 4px;
}
</style>
</file>

<file path="src/components/modules/adjust/AdjustResize.vue">
<template>
  <div class="tool-group">
    <div
      class="tool-item"
      :class="{ 'is-expanded': isExpanded }"
      @click="handleToggle"
    >
      <div class="left">
        <svg
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          style="margin-right: 8px"
        >
          <path d="M15 3h6v6" />
          <path d="M9 21H3v-6" />
          <path d="M21 3l-7 7" />
          <path d="M3 21l7-7" />
        </svg>
        <span>è°ƒæ•´å°ºå¯¸</span>
      </div>
      <div class="right-icon">
        <svg
          class="arrow"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <path d="m9 18 6-6-6-6" />
        </svg>
      </div>
    </div>

    <div v-if="isExpanded" class="tool-content">
      <div class="preset-grid">
        <div
          class="preset-item custom-item"
          :class="{ active: isCustomMode }"
          @click="selectCustomMode"
        >
          <span>è‡ªå®šä¹‰</span>
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="12" y1="8" x2="12" y2="16"></line>
            <line x1="8" y1="12" x2="16" y2="12"></line>
          </svg>
        </div>

        <div
          v-for="(preset, index) in presets"
          :key="index"
          class="preset-item"
          :class="{ active: activePresetIndex === index }"
          @click="selectPreset(preset, index)"
        >
          <span class="preset-name">{{ preset.label }}</span>
          <span class="preset-dim">{{ preset.w }}Ã—{{ preset.h }}</span>
        </div>
      </div>

      <div class="resize-input-box">
        <div class="input-controls">
          <div class="input-wrapper">
            <input
              type="number"
              v-model.number="width"
              class="ie-input"
              @input="onInputChanged"
            />
            <span class="suffix">W</span>
          </div>

          <div
            class="link-icon-btn"
            @click="toggleAdaptive"
            :title="isAdaptive ? 'é”å®šæ¯”ä¾‹' : 'è‡ªç”±æ¯”ä¾‹'"
          >
            <svg
              v-if="isAdaptive"
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="var(--ie-primary-color)"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"
              ></path>
              <path
                d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"
              ></path>
            </svg>
            <svg
              v-else
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="#999"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              style="opacity: 0.6"
            >
              <path
                d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"
              ></path>
              <path
                d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"
              ></path>
              <line x1="4" y1="4" x2="20" y2="20" stroke="#999"></line>
            </svg>
          </div>

          <div class="input-wrapper">
            <input
              type="number"
              v-model.number="height"
              class="ie-input"
              @input="onInputChanged"
            />
            <span class="suffix">H</span>
          </div>
        </div>

        <div class="switch-row">
          <div
            class="ie-switch"
            :class="{ 'is-checked': isAdaptive }"
            @click="toggleAdaptive"
          >
            <span class="ie-switch-core"></span>
          </div>
          <span class="switch-label">é”å®šé•¿å®½æ¯” (ä¿çœŸæ¨¡å¼)</span>
        </div>
      </div>

      <div class="action-buttons">
        <button class="ie-btn ie-primary full" @click="handleApply">
          åº”ç”¨ä¿®æ”¹
        </button>
        <button class="ie-btn full" @click="handleCancel">å–æ¶ˆ</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import {
  ref,
  inject,
  watch,
  onMounted,
  onUnmounted,
  nextTick,
  computed,
  unref,
} from "vue";
import {
  registerResizeModule,
  getCurrentSize,
  applyResize,
  startPreview,
  updatePreview,
  stopPreview,
} from "./useCanvasResize";
// âœ¨ 1. å¼•å…¥ç‰©ç†é”
import { useCanvasLock } from "@/composables/useCanvasLock";

const props = defineProps({
  isExpanded: { type: Boolean, default: false },
});

const emit = defineEmits(["toggle"]);
const canvasAPI = inject("canvasAPI");

// âœ¨ 2. è·å–é”æ–¹æ³•
const { setBackgroundLock } = useCanvasLock();

// === çŠ¶æ€å®šä¹‰ ===
const width = ref(0);
const height = ref(0);
const isAdaptive = ref(true);
const originalRatio = ref(1);
const activePresetIndex = ref(-1);
const isInternalUpdate = ref(false); // é˜²æ­¢å¾ªç¯æ›´æ–°

// é¢„è®¾æ•°æ® (ä¿ç•™åŸæ ·)
const presets = [
  { label: "æ–¹å½¢ä¸»å›¾", w: 800, h: 800 },
  { label: "Temuæœè£…å›¾", w: 1340, h: 1785 },
  { label: "æ–¹å½¢ä¸»å›¾", w: 1000, h: 1000 },
  { label: "ç«–å›¾ä¸»å›¾", w: 750, h: 1000 },
  { label: "æ–¹å½¢ä¸»å›¾", w: 500, h: 500 },
  { label: "ç«–å›¾ä¸»å›¾", w: 1000, h: 1200 },
  { label: "Youtubeè§†é¢‘å°é¢", w: 1280, h: 720 },
  { label: "Pinterestå¸–å­", w: 750, h: 1120 },
  { label: "Facebookå°é¢", w: 851, h: 315 },
];

const isCustomMode = computed(() => activePresetIndex.value === -1);

// === æ ¸å¿ƒé€»è¾‘ï¼šè·å–å½“å‰åº”éµå¾ªçš„æ¯”ä¾‹ ===
const currentTargetRatio = computed(() => {
  if (activePresetIndex.value >= 0) {
    const p = presets[activePresetIndex.value];
    return p.h !== 0 ? p.w / p.h : 1;
  } else {
    return originalRatio.value;
  }
});

// === åˆå§‹åŒ– ===
const initSize = () => {
  if (canvasAPI && canvasAPI.canvas) {
    registerResizeModule(canvasAPI.canvas, canvasAPI.saveHistory);
    const canvas = unref(canvasAPI.canvas);
    
    if (canvas) {
      // ç¡®ä¿ä¸»å›¾è¢«æ ‡è®°ï¼Œä»¥ä¾¿è¢«é”é€»è¾‘è±å…
      const mainImg = canvas.getObjects().find((o) => o.isMainImage || o.type === 'image');
      if (mainImg) {
        if (!mainImg.isMainImage) mainImg.isMainImage = true; // åŠ¨æ€è¡¥å…¨æ ‡è¯†
        canvas.setActiveObject(mainImg);
      }
      canvas.requestRenderAll();
    }

    const size = getCurrentSize();

    if (size.height > 0) {
      originalRatio.value = size.width / size.height;
    }

    width.value = size.width;
    height.value = size.height;
    activePresetIndex.value = -1; // é»˜è®¤é€‰ä¸­è‡ªå®šä¹‰
    isAdaptive.value = true; // é»˜è®¤å¼€å¯ä¿çœŸ

    // ç«‹å³å¯åŠ¨é¢„è§ˆ (æ˜¾ç¤ºè“è‰²è™šçº¿æ¡†)
    nextTick(() => {
      startPreview(width.value, height.value, !isAdaptive.value);
      if (canvas) setBackgroundLock(canvas, true);
    });
  }
};

// === æ¸…ç†é€»è¾‘ (å°è£…) ===
const cleanup = () => {
  stopPreview();

  // âœ¨âœ¨âœ¨ 4. æ³¨å…¥è§£é”é€»è¾‘ï¼šæ¢å¤äº¤äº’ âœ¨âœ¨âœ¨
  const canvas = unref(canvasAPI.canvas);
  if (canvas) {
    setBackgroundLock(canvas, false);
    canvas.discardActiveObject();
    canvas.requestRenderAll();
  }
};

// === äº¤äº’é€»è¾‘ (ä¿ç•™åŸæ ·) ===

const selectCustomMode = () => {
  activePresetIndex.value = -1;
  resetToOriginal();
};

const selectPreset = (preset, index) => {
  activePresetIndex.value = index;
  isInternalUpdate.value = true;
  width.value = preset.w;
  height.value = preset.h;
  isAdaptive.value = true;
  nextTick(() => {
    isInternalUpdate.value = false;
    updatePreviewBox();
  });
};

const toggleAdaptive = () => {
  isAdaptive.value = !isAdaptive.value;
  if (isAdaptive.value && width.value > 0) {
    isInternalUpdate.value = true;
    height.value = Math.round(width.value / currentTargetRatio.value);
    nextTick(() => {
      isInternalUpdate.value = false;
      updatePreviewBox();
    });
  } else {
    updatePreviewBox();
  }
};

const resetToOriginal = () => {
  const size = getCurrentSize();
  width.value = size.width;
  height.value = size.height;
  updatePreviewBox();
};

// === ç›‘å¬è¾“å…¥ ===

watch(width, (newW) => {
  if (isInternalUpdate.value) return;
  if (isAdaptive.value && newW > 0) {
    isInternalUpdate.value = true;
    height.value = Math.round(newW / currentTargetRatio.value);
    nextTick(() => {
      isInternalUpdate.value = false;
    });
  }
});

watch(height, (newH) => {
  if (isInternalUpdate.value) return;
  if (isAdaptive.value && newH > 0) {
    isInternalUpdate.value = true;
    width.value = Math.round(newH * currentTargetRatio.value);
    nextTick(() => {
      isInternalUpdate.value = false;
    });
  }
});

const onInputChanged = () => {
  updatePreviewBox();
};

const updatePreviewBox = () => {
  if (width.value > 0 && height.value > 0) {
    updatePreview(width.value, height.value, !isAdaptive.value);
  } else {
    stopPreview();
  }
};

// ç›‘å¬å±•å¼€çŠ¶æ€
watch(
  () => props.isExpanded,
  (val) => {
    if (val) initSize();
    else cleanup(); // ä½¿ç”¨ cleanup æ›¿ä»£åŸæ¥çš„ stopPreview
  }
);

// === åº”ç”¨ä¸å–æ¶ˆ ===
const handleApply = () => {
  applyResize(width.value, height.value, !isAdaptive.value);
  emit("toggle"); // å…³é—­ä¼šè‡ªåŠ¨è§¦å‘ watch -> cleanup -> è§£é”
};

const handleCancel = () => {
  cleanup(); // æ˜¾å¼è°ƒç”¨æ¸…ç†
  emit("toggle");
};

const handleToggle = () => {
  emit("toggle");
};

onMounted(() => {
  if (props.isExpanded) initSize();
});

onUnmounted(() => cleanup());
</script>

<style scoped>
/* Grid å¸ƒå±€å®ç°çŸ©é˜µæ•ˆæœ */
.preset-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  /* ä¸¤åˆ— */
  gap: 8px;
  margin-bottom: 16px;
  max-height: 280px;
  overflow-y: auto;
}

.preset-item {
  background-color: #f5f7fa;
  padding: 10px;
  border-radius: 6px;
  font-size: 13px;
  color: #606266;
  cursor: pointer;
  border: 1px solid transparent;
  display: flex;
  flex-direction: column;
  /* å‚ç›´æ’åˆ—æ–‡å­— */
  align-items: center;
  justify-content: space-between;
  text-align: center;
  transition: all 0.2s;
}

.preset-item:hover {
  background-color: #e6f7ff;
  border-color: #c0c4cc;
}

.preset-item.active {
  background-color: #ecf5ff;
  color: var(--ie-primary-color);
  border-color: var(--ie-primary-color);
  font-weight: 500;
}

/* è‡ªå®šä¹‰é¡¹ç‰¹æ®Šæ ·å¼ */
.custom-item {
  flex-direction: row;
  /* æ¨ªå‘ */
  grid-column: span 2;
  /* å æ»¡ä¸€è¡Œ */
  background-color: #fff;
  border: 1px dashed #dcdfe6;
}

.custom-item.active {
  border-style: solid;
}

.preset-name {
  font-weight: 500;
  margin-bottom: 2px;
}

.preset-dim {
  font-size: 11px;
  color: #909399;
}

/* è¾“å…¥æ¡†åŒºåŸŸæ ·å¼ä¼˜åŒ– */
.resize-input-box {
  background-color: #fff;
  padding: 4px 0;
}

.input-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.input-wrapper {
  position: relative;
  width: 40%;
}

.ie-input {
  text-align: center;
  padding-right: 20px;
  font-weight: bold;
  color: #333;
  width: 100%;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  height: 32px;
  font-size: 13px;
}

.ie-input:focus {
  border-color: var(--ie-primary-color);
  outline: none;
}

.suffix {
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  color: #c0c4cc;
  font-size: 11px;
  pointer-events: none;
}

.link-icon-btn {
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
}

.link-icon-btn:hover {
  background-color: #f0f0f0;
}

.switch-row {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 12px;
}

.switch-label {
  font-size: 12px;
  color: #606266;
  margin-left: 8px;
  cursor: pointer;
}

.ie-switch {
  position: relative;
  display: inline-flex;
  align-items: center;
  width: 32px;
  height: 16px;
  border-radius: 10px;
  background-color: #dcdfe6;
  cursor: pointer;
  transition: background-color 0.3s;
}

.ie-switch.is-checked {
  background-color: var(--ie-primary-color);
}

.ie-switch-core {
  position: absolute;
  top: 2px;
  left: 2px;
  border-radius: 100%;
  width: 12px;
  height: 12px;
  background-color: #fff;
  transition: all 0.3s;
}

.ie-switch.is-checked .ie-switch-core {
  left: 100%;
  margin-left: -14px;
}

.reset-row {
  text-align: center;
  margin-bottom: 10px;
}

.reset-link {
  font-size: 12px;
  color: #909399;
  cursor: pointer;
  text-decoration: underline;
}

.reset-link:hover {
  color: var(--ie-primary-color);
}

.action-buttons {
  display: flex;
  gap: 10px;
}

.full {
  flex: 1;
}

.tool-item:hover .arrow {
  transform: translateX(2px);
  transition: transform 0.2s;
}

.tool-content {
  padding: 16px;
  border: 1px solid #eee;
  border-top: none;
}
</style>
</file>

<file path="src/components/modules/puzzle/index.vue">
<template>
  <div class="puzzle-module">
    <div
      v-if="sub === 1"
      class="puzzle-main"
    >
      <div class="puzzle-tabs">
        <div
          class="tab-item"
          :class="{ active: activeTab === 'grid' }"
          @click="activeTab = 'grid'"
        >
          ç½‘æ ¼
        </div>
        <div
          class="tab-item"
          :class="{ active: activeTab === 'join' }"
          @click="activeTab = 'join'"
        >
          æ‹¼æ¥
        </div>
      </div>

      <div>
        <div v-if="activeTab === 'grid'">
          <button
            class="select-btn"
            @click="sub = 2"
          >
            <div class="icon-wrap">
              <div
                v-if="showControlPanel"
                :style="curTemp.wrapStyle"
                class="small-grid-template"
              >
                <div
                  v-for="(gridArea, i) in curTemp.gridAreas"
                  :key="i"
                  class="grid-cell"
                  :style="`grid-area: ${gridArea};`"
                ></div>
              </div>
              <span
                v-else
                class="plus-icon"
              >+</span>
            </div>
            <span>é€‰æ‹©ç½‘æ ¼</span>
            <span
              v-if="showControlPanel"
              class="cancel-btn"
              @click.stop="cancel"
            >å–æ¶ˆ</span>
          </button>

          <div
            v-if="showControlPanel"
            class="control-panel"
          >
            <div class="control-group">
              <label>æ‹¼å›¾å°ºå¯¸</label>
              <div class="size-controls">
                <div class="input-wrapper">
                  <input
                    type="number"
                    v-model.number="puzzleSettings.width"
                    :min="min"
                    :max="max"
                    class="ie-input"
                    @change="updateSize('width')"
                  >
                  <span class="suffix">W</span>
                </div>

                <div
                  class="link-icon"
                  title="é”å®šå®½é«˜æ¯”"
                  @click="toggleRatioLock"
                >
                  <svg
                    v-if="puzzleSettings.lockRatio"
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="#409eff"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
                  </svg>
                  <svg
                    v-else
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="#909399"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    style="opacity: 0.6"
                  >
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
                    <line
                      x1="4"
                      y1="4"
                      x2="20"
                      y2="20"
                      stroke="#909399"
                    />
                  </svg>
                </div>

                <div class="input-wrapper">
                  <input
                    type="number"
                    v-model.number="puzzleSettings.height"
                    :min="min"
                    :max="max"
                    class="ie-input"
                    @change="updateSize('height')"
                  >
                  <span class="suffix">H</span>
                </div>
              </div>
            </div>

            <div class="control-group">
              <label>è¾¹æ¡†</label>
              <input
                v-model.number="puzzleSettings.padding"
                type="range"
                min="0"
                max="100"
                step="1"
                @change="updateStyle"
              />
              <span class="value-display">{{ puzzleSettings.padding }} px</span>
            </div>

            <div class="control-group">
              <label>é—´è·</label>
              <input
                type="range"
                v-model.number="puzzleSettings.spacing"
                min="0"
                max="100"
                step="1"
                @change="updateStyle"
              />
              <span class="value-display">{{ puzzleSettings.spacing }} px</span>
            </div>

            <div class="control-group">
              <label>æ‹¼å›¾èƒŒæ™¯é¢œè‰²</label>
              <input
                type="color"
                class="color"
                v-model="puzzleSettings.bgColor"
                @input="updateStyle"
              />
            </div>

            <button
              class="save-btn"
              @click="save"
            >
              ä¿å­˜
            </button>
          </div>
        </div>

        <div v-else>
          <button class="select-btn">
            <div class="icon-wrap">
              <div
                v-if="showControlPanel"
                :style="curTemp.wrapStyle"
                class="small-grid-template"
              >
                <div
                  v-for="(gridArea, i) in curTemp.gridAreas"
                  :key="i"
                  class="grid-cell"
                  :style="`grid-area: ${gridArea};`"
                ></div>
              </div>
              <span
                v-else
                class="plus-icon"
              >+</span>
            </div>
            <span>é€‰æ‹©æ‹¼æ¥</span>
            <span
              v-if="showControlPanel"
              class="cancel-btn"
              @click.stop="cancel"
            >å–æ¶ˆ</span>
          </button>
        </div>
      </div>
    </div>

    <div
      v-if="sub === 2"
      class="grid-templates"
    >
      <div
        class="back-header"
        @click="backToMain"
      >
        <span class="back-icon">â€¹</span> ç½‘æ ¼
      </div>

      <div class="image-count-selector">
        <label>å›¾ç‰‡æ•°é‡</label>
        <select v-model="selectedImageCount">
          <option
            v-for="item in countOptions"
            :key="item.value"
            :value="item.value"
          >{{ item.label }}</option>
        </select>
      </div>

      <div class="grid-list">
        <div
          v-for="(group, count) in filteredTemplates"
          :key="count"
          class="grid-group"
        >
          <div class="grid-group-title">{{ count }}</div>

          <div class="grid-templates-row">
            <div
              v-for="template in group"
              :key="template.id"
              :style="template.wrapStyle"
              class="grid-template"
              @click="selectTemplate(template)"
            >
              <div
                v-for="(gridArea, i) in template.gridAreas"
                :key="i"
                class="grid-cell"
                :style="`grid-area: ${gridArea};`"
              ></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div
      v-if="sub === 3"
      class="p-20"
    >
      <div class="operate-buttons">
         <button class="ie-btn full" @click="triggerReplace">æ›¿æ¢å›¾ç‰‡</button>
         <button 
            v-if="currentImgCount > 1" 
            class="ie-btn btn-danger" 
            style="margin-left: 8px;"
            @click="handleDelete"
         >åˆ é™¤</button>
      </div>

      <div class="divider-line"></div>

      <div class="control-group">
        <div class="label-row">
            <label>é€æ˜åº¦</label>
            <span class="val">{{ transparent }}%</span>
        </div>
        <input
          v-model.number="transparent"
          type="range"
          min="0"
          max="100"
          step="1"
          @input="onParamsChange"
        />
      </div>

      <div class="control-group">
        <div class="label-row">
            <label>æ”¾å¤§ (Zoom)</label>
            <span class="val">{{ Math.round(zoomScale * 100) }}%</span>
        </div>
        <input
          type="range"
          v-model.number="zoomScale"
          min="0.1"
          max="3"
          step="0.01"
          @input="onParamsChange"
        />
      </div>
    </div>

    <input
      type="file"
      ref="fileInput"
      accept="image/png, image/jpeg, image/jpg"
      style="display:none"
      @change="onFileSelected"
    >

    <Modal
      v-model="showSaveModal"
      @confirm="handleConfirmSave"
      @cancel="showSaveModal = false"
      @discard="showSaveModal = false"
    />
  </div>
</template>

<script setup>
  import { ref, reactive, computed, inject, onMounted, onUnmounted } from 'vue';
  import { toast } from '@/utils/toast';
  import Modal from '@/components/common/Modal.vue'; // å¼•å…¥ Modal ç»„ä»¶
  import { gridTemplates, parseTemplateToCells, countOptions } from './config.js';
  import {
    registerPuzzleModule,
    initPuzzleMode,
    exitPuzzleMode,
    updateLayout,
    addImageToCell,
    deleteImageFromCell,
    updatePuzzleImageParams,
    getPuzzleImageCount,
    zoomToPuzzleArea,
    saveSnapshotBeforeLayout,
    restoreSnapshotBeforeLayout,
    completeExitPuzzle // å¼•å…¥å®Œæˆæ‹¼å›¾çš„æ–¹æ³•
  } from './useCanvasPuzzle.js';
  import { useEditorState } from '@/composables/useEditorState';

  const canvasAPI = inject('canvasAPI');
  const fileInput = ref(null);
  const { setPuzzleMode } = useEditorState();
  
  let pendingCellIndex = -1;
  const selectedCellIndex = ref(-1);

  // å›¾ç‰‡å‚æ•°çŠ¶æ€
  const transparent = ref(100);
  const zoomScale = ref(1);
  const currentImgCount = ref(1);

  // å¼¹çª—æ§åˆ¶çŠ¶æ€
  const showSaveModal = ref(false);

  onMounted(() => {
    if (canvasAPI) {
      registerPuzzleModule(canvasAPI.canvas, canvasAPI.saveHistory, {
        onCellClick: (index) => {
          pendingCellIndex = index;
          if (fileInput.value) {
            fileInput.value.value = '';
            fileInput.value.click();
          }
        },
        onImageSelect: (index, params) => {
           selectedCellIndex.value = index;
           pendingCellIndex = index;
           
           transparent.value = Math.round((params.opacity || 1) * 100);
           zoomScale.value = params.scale || 1;
           
           currentImgCount.value = getPuzzleImageCount();
           sub.value = 3;
        },
        onDeselect: () => {
           sub.value = 1;
           selectedCellIndex.value = -1;
        }
      },
        canvasAPI.zoomToRect
      );
      initPuzzleMode();
    }
  });

  onUnmounted(() => {
    // ç¦»å¼€ç»„ä»¶æ—¶å¦‚æœä¸ä¿å­˜ï¼Œä¹Ÿåº”è¯¥æ‰§è¡Œé€€å‡ºæ¸…ç†é€»è¾‘
    exitPuzzleMode();
  });

  const onFileSelected = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
      toast.error('ä»…æ”¯æŒ JPG/PNG å›¾ç‰‡æ ¼å¼');
      return;
    }
    if (pendingCellIndex >= 0) {
      const url = URL.createObjectURL(file);
      addImageToCell(url, pendingCellIndex);
      if (sub.value === 3) {
        transparent.value = 100;
      } else {
        pendingCellIndex = -1;
      }
    }
  };

  const sub = ref(1);
  const showControlPanel = ref(false);
  const selectedImageCount = ref('all');
  const activeTab = ref('grid');

  const filteredTemplates = computed(() => {
    if (selectedImageCount.value === 'all') {
      return gridTemplates;
    } else {
      const curCount = parseInt(selectedImageCount.value);
      const result = {};
      for (const count in gridTemplates) {
        if (parseInt(count) === curCount) {
          result[count] = gridTemplates[count];
        }
      }
      return result;
    }
  });

  const backToMain = () => {
    sub.value = 1;
    selectedImageCount.value = 'all';
  };

  const curTemp = ref({});
  const selectTemplate = (template) => {
    // Only capture snapshot if we are starting a new selection (curTemp is empty)
    if (!curTemp.value.id) {
      saveSnapshotBeforeLayout();
    }
    
    curTemp.value = template;
    showControlPanel.value = true;
    setPuzzleMode(true); // åˆ‡æ¢åˆ°æ‹¼å›¾æ¨¡å¼
    sub.value = 1;
    applyTemplate(template);
    zoomToPuzzleArea();
  };

  const applyTemplate = (templ) => {
    const cells = parseTemplateToCells(templ);
    updateLayout(cells, puzzleSettings);
  };

  const cancel = () => {
    restoreSnapshotBeforeLayout();
    showControlPanel.value = false;
    setPuzzleMode(false); // é€€å‡ºæ‹¼å›¾æ¨¡å¼
    curTemp.value = {};
  };

  const puzzleSettings = reactive({
    width: 1000,
    height: 1000,
    lockRatio: false,
    padding: 15,
    spacing: 15,
    bgColor: '#ffffff'
  });
  const min = 400;
  const max = 3840;
  let ratio = 1;

  const toggleRatioLock = () => {
    puzzleSettings.lockRatio = !puzzleSettings.lockRatio;
    if (puzzleSettings.lockRatio) {
      ratio = puzzleSettings.width / puzzleSettings.height;
    }
  };

  const updateSize = (dimension) => {
    if (puzzleSettings[dimension] < min) {
      puzzleSettings[dimension] = min;
    } else if (puzzleSettings[dimension] > max) {
      puzzleSettings[dimension] = max;
    }

    if (puzzleSettings.lockRatio) {
      if (dimension === 'width') {
        puzzleSettings.height = Math.round(puzzleSettings.width / ratio);
      } else {
        puzzleSettings.width = Math.round(puzzleSettings.height * ratio);
      }
    }

    updateStyle();
  };

  const updateStyle = () => {
    updateLayout(null, puzzleSettings);
  };

  // === ä¿å­˜é€»è¾‘ ===
  const save = () => { 
    showSaveModal.value = true;
  };

  const handleConfirmSave = () => {
    // 1. è°ƒç”¨æ ¸å¿ƒé€»è¾‘ï¼šç”Ÿæˆå›¾ç‰‡å¹¶æ›¿æ¢ç”»å¸ƒå†…å®¹
    completeExitPuzzle('save');
    
    // 2. å…³é—­å¼¹çª—
    showSaveModal.value = false;
    
    // 3. è¿”å›
    showControlPanel.value = false;
    setPuzzleMode(false); // é€€å‡ºæ‹¼å›¾æ¨¡å¼
  };

  // === Sub 3 é€»è¾‘ ===

  const deselectImage = () => {
      sub.value = 1;
      selectedCellIndex.value = -1;
      if (canvasAPI && canvasAPI.canvas) {
          canvasAPI.canvas.value.discardActiveObject();
          canvasAPI.canvas.value.requestRenderAll();
      }
  };

  const triggerReplace = () => {
      if (fileInput.value) {
          fileInput.value.value = '';
          fileInput.value.click();
      }
  };

  const handleDelete = () => {
      if (selectedCellIndex.value === -1) return;
      deleteImageFromCell(selectedCellIndex.value);
      toast.success('å›¾ç‰‡å·²åˆ é™¤');
      deselectImage();
  };

  const onParamsChange = () => {
      if (selectedCellIndex.value === -1) return;
      updatePuzzleImageParams(selectedCellIndex.value, {
          opacity: transparent.value / 100,
          scale: zoomScale.value
      });
  };
</script>

<style scoped>
  .puzzle-module {
    width: 100%;
    height: 100%;
    background-color: #fff;
  }

  .puzzle-main {
    padding: 20px;
  }

  .puzzle-tabs {
    display: flex;
  }

  .tab-item {
    flex: 1;
    text-align: center;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    color: #606266;
  }

  .tab-item.active {
    background-color: #409eff;
    color: #fff;
  }

  .select-btn {
    display: inline-flex;
    align-items: center;
    padding: 14px;
    border-radius: 4px;
    width: 100%;
    cursor: pointer;
    font-size: 14px;
    color: #606266;
    transition: all 0.3s;
  }

  .select-btn:hover {
    border-color: #409eff;
    color: #409eff;
  }

  .icon-wrap {
    width: 40px;
    height: 40px;
    border-radius: 4px;
    background-color: #fff;
    font-size: 24px;
    line-height: 40px;
    text-align: center;
    margin-right: 16px;
  }

  .small-grid-template {
    height: 100%;
    display: grid;
    overflow: hidden;
  }

  .plus-icon {
    font-weight: bold;
  }

  .cancel-btn {
    color: #409eff;
    margin-left: 76px;
    cursor: pointer;
  }

  .grid-templates {
    padding: 20px 12px 20px;
  }

  .back-header {
    display: flex;
    align-items: center;
    font-size: 16px;
    font-weight: 500;
    margin-bottom: 20px;
    cursor: pointer;
  }

  .back-icon {
    font-size: 20px;
    margin-right: 8px;
    color: #606266;
  }

  .image-count-selector {
    margin-bottom: 20px;
  }

  .image-count-selector label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    color: #606266;
  }

  .image-count-selector select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #dcdfe6;
    border-radius: 4px;
    font-size: 14px;
  }

  .grid-list {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .grid-group {
    border-radius: 4px;
    overflow: hidden;
  }

  .grid-group-title {
    padding: 10px 15px;
    background-color: #f5f7fa;
    font-size: 14px;
    font-weight: 500;
    color: #606266;
  }

  .grid-templates-row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 12px 4px;
  }

  .grid-template {
    width: 120px;
    height: 120px;
    display: grid;
    border-radius: 4px;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.3s;
  }

  .grid-template:hover {
    border-color: #409eff;
    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
  }

  .grid-cell {
    height: 100%;
    background-color: #f0f0f0;
    border: 1px solid #fff;
  }

  .control-panel {
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 15px 0;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .control-group label {
    font-size: 14px;
    color: #606266;
    font-weight: 500;
  }

  .color {
    width: 100%;
    cursor: pointer;
    border: none;
  }

  .size-controls {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .input-wrapper {
    position: relative;
    width: 38%;
  }

  .ie-input {
    text-align: center;
    padding-right: 20px;
    font-weight: 500;
    color: #333;
  }

  .suffix {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    color: #c0c4cc;
    font-size: 12px;
    pointer-events: none;
  }

  .link-icon {
    width: 24px;
    display: flex;
    justify-content: center;
    cursor: pointer;
  }

  .control-group input[type="range"] {
    width: 100%;
    height: 4px;
    border-radius: 2px;
    background: #dcdfe6;
    outline: none;
    -webkit-appearance: none;
  }

  .control-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #409eff;
    cursor: pointer;
  }

  .control-group input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #409eff;
    cursor: pointer;
    border: none;
  }

  .value-display {
    font-size: 14px;
    color: #909399;
    text-align: right;
  }

  .save-btn {
    padding: 12px 20px;
    margin-top: 20px;
    border: none;
    border-radius: 21px;
    background-color: #409eff;
    color: #fff;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s;
  }

  .save-btn:hover {
    background-color: #66b1ff;
  }

  .p-20 {
    padding: 20px;
  }

  .operate-buttons {
    display: flex;
    margin-top: 10px;
  }

  .full {
    flex: 1;
  }

  .btn-danger {
    background-color: #fef0f0;
    color: #f56c6c;
    border-color: #fbc4c4;
  }
  .btn-danger:hover {
    background-color: #f56c6c;
    color: #fff;
    border-color: #f56c6c;
  }

  .divider-line {
    height: 1px;
    background: #ebeef5;
    margin: 20px 0;
  }

  .label-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 13px;
    color: #606266;
  }

  .val {
    font-family: monospace;
  }

  .confirm-content {
    display: flex;
    align-items: center;
    color: #606266;
    font-size: 14px;
  }
</style>
</file>

<file path="src/style.css">
/* 1. ç§»é™¤å…¨å±€çš„ @import './reset.css'; é˜²æ­¢æ±¡æŸ“å®¿ä¸»ç¯å¢ƒ */
/* @import './reset.css'; */

/* 2. å°†åŸå…ˆ :root é‡Œçš„å˜é‡ç§»åˆ°å®¹å™¨å†…ï¼Œå˜æˆå±€éƒ¨å˜é‡ */
.image-editor-sdk-container {

  /* === 1. åŸºç¡€ç›’å­è®¾å®š === */
  position: relative;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  overflow: hidden;

  /* === 2. åº”ç”¨å˜é‡ === */
  font-family: var(--ie-font-family);
  background-color: var(--ie-bg-color);
  color: var(--ie-text-color);

  /* å­—ä½“ä¼˜åŒ– */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  /* è¦†ç›–å¯èƒ½å±…ä¸­çš„ body æ ·å¼ */

  /* ç¡®ä¿å®¹å™¨å†…çš„æ‰€æœ‰å…ƒç´ ç»§æ‰¿ box-sizing */
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    scrollbar-width: thin;
    scrollbar-color: rgba(144, 147, 153, 0.3) transparent;
  }

  /* === é“¾æ¥æ ·å¼ (Scope åŒ–) === */
  a {
    font-weight: 500;
    color: #646cff;
    text-decoration: inherit;
  }

  a:hover {
    color: #535bf2;
  }

  /* === æ ‡é¢˜æ ·å¼ === */
  h1 {
    font-size: 3.2em;
    line-height: 1.1;
    margin: 0;
    /* ç§»é™¤é»˜è®¤è¾¹è· */
  }

  /* === æŒ‰é’®æ ·å¼ (Scope åŒ–ï¼Œåªå½±å“ç¼–è¾‘å™¨å†…çš„ button) === */
  button {
    border-radius: 8px;
    border: 1px solid transparent;
    padding: 0.6em 1.2em;
    font-size: 1em;
    font-weight: 500;
    font-family: inherit;
    background-color: #1a1a1a;
    cursor: pointer;
    transition: border-color 0.25s;
    outline: none;
    margin: 0;
    /* ç§»é™¤é»˜è®¤è¾¹è· */
  }

  button:hover {
    border-color: #646cff;
  }

  /* é’ˆå¯¹äº®è‰²æ¨¡å¼çš„é€‚é… (å¦‚æœå®¿ä¸»æ˜¯äº®è‰²) */
  @media (prefers-color-scheme: light) {
    --ie-text-color: #213547;
    --ie-bg-color: #ffffff;

    a:hover {
      color: #747bff;
    }

    button {
      background-color: #f9f9f9;
    }
  }

  /* === IE UI Kit (ç»„ä»¶åº“æ ·å¼) === */
  .ie-actions {
    display: flex;

  }

  /* 1. æŒ‰é’®å¢å¼º */
  .ie-btn {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    height: 28px;
    padding: 0 12px;
    font-size: 13px;
    border-radius: 4px;
    border: 1px solid var(--ie-border-color);
    background-color: #fff;
    color: #606266;
    cursor: pointer;
    transition: .2s;
    outline: none;
  }

  .ie-btn:hover {
    color: var(--ie-primary-color);
    border-color: #c6e2ff;
    background-color: #ecf5ff;
  }

  .ie-btn:disabled {
    color: #c0c4cc;
    cursor: not-allowed;
    background-color: #fff;
    border-color: #ebeef5;
  }

  .ie-btn.ie-primary {
    color: #fff;
    background-color: var(--ie-primary-color);
    border-color: var(--ie-primary-color);
  }

  .ie-btn.ie-primary:hover {
    background-color: #66b1ff;
    border-color: #66b1ff;
  }

  .ie-btn-circle {
    width: 32px;
    padding: 0;
    border-radius: 50%;
  }

  /* 2. è¾“å…¥æ¡† */
  .ie-input {
    height: 32px;
    line-height: 32px;
    padding: 0 8px;
    border: 1px solid var(--ie-border-color);
    border-radius: 4px;
    color: #606266;
    background-color: #ffffff;
    width: 100%;
    box-sizing: border-box;
    appearance: textfield;
    font-size: 13px;
    /* ç»Ÿä¸€å­—ä½“ */
  }

  /* éšè—åŸç”Ÿæ—‹è½¬æŒ‰é’® */
  .ie-input::-webkit-outer-spin-button,
  .ie-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  /* Firefox */
  .ie-input[type=number] {
    -moz-appearance: textfield;
  }

  .ie-input:focus {
    border-color: var(--ie-primary-color);
    outline: none;
  }

  /* 3. åˆ†å‰²çº¿ */
  .ie-divider {
    width: 1px;
    height: 1em;
    margin: 6px 8px;
    background: var(--ie-border-color);
    display: inline-block;
    vertical-align: middle;
  }

  /* === å·¥å…·æ å¸ƒå±€æ ·å¼ === */
  .panel-adjust {
    height: 100%;
    overflow-y: auto;
    padding: 16px;
  }

  .tool-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .tool-group {
    display: flex;
    flex-direction: column;
  }

  .tool-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    height: 50px;
    background-color: #f5f7fa;
    border-radius: 8px;
    cursor: pointer;
    color: #333;
    font-size: 14px;
    transition: all 0.2s ease;
    user-select: none;
  }

  .tool-item:hover {
    background-color: #e6e8eb;
    transform: translateY(-1px);
  }

  .tool-item.is-expanded {
    background-color: #ecf5ff;
    color: var(--ie-primary-color);
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
  }

  .tool-item .left {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .tool-item .right-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 20px;
  }

  .tool-item .arrow {
    font-size: 14px;
    color: #909399;
    transition: transform 0.3s;
  }

  .tool-item.is-expanded .arrow {
    transform: rotate(90deg);
    color: var(--ie-primary-color);
  }

  .tool-content {
    background-color: #fff;
    padding: 16px;
    border: 1px solid #eee;
    border-top: none;
    border-bottom-left-radius: 8px;
    border-bottom-right-radius: 8px;
    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.05);
    animation: slideDown 0.2s ease-out;
    color: #333;
    /* ç¡®ä¿æ–‡å­—é¢œè‰²æ­£ç¡® */
  }

  /* åŠ¨ç”» */
  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-5px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .status-dot {
    width: 8px;
    height: 8px;
    background-color: var(--ie-primary-color);
    border-radius: 50%;
  }

  .is-loading {
    animation: rotating 2s linear infinite;
    color: var(--ie-primary-color);
  }

  @keyframes rotating {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }
}

/* === toast æç¤º (å®ƒé€šå¸¸æŒ‚è½½åœ¨ body ä¸Šï¼Œæ‰€ä»¥æ”¾åœ¨å®¹å™¨å¤–é¢) === */
/* å¦‚æœ toast é€»è¾‘æ”¹ä¸ºæŒ‚è½½åˆ°å®¹å™¨å†…ï¼Œä¹Ÿå¯ä»¥ç§»è¿›å» */
.ie-toast {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 14px;
  z-index: 9999;
  animation: ie-fade-in 0.3s;
  pointer-events: none;
  /* é˜²æ­¢é®æŒ¡ç‚¹å‡» */
}

@keyframes ie-fade-in {
  from {
    opacity: 0;
    transform: translate(-50%, -10px);
  }

  to {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}

/* === å…¨å±€æ»šåŠ¨æ¡æ ·å¼ (Global Scrollbar) === */

/* 1. è®¾ç½®æ»šåŠ¨æ¡æ•´ä½“å®½é«˜ */
::-webkit-scrollbar {
  width: 6px;
  /* çºµå‘æ»šåŠ¨æ¡å®½åº¦ */
  height: 6px;
  /* æ¨ªå‘æ»šåŠ¨æ¡é«˜åº¦ */
}

/* 2. æ»šåŠ¨æ¡è½¨é“ (å¯é€‰ï¼Œé€šå¸¸è®¾ä¸ºé€æ˜) */
::-webkit-scrollbar-track {
  background: transparent;
}

/* 3. æ»šåŠ¨æ¡æ»‘å— */
::-webkit-scrollbar-thumb {
  background: rgba(144, 147, 153, 0.3);
  /* é»˜è®¤é¢œè‰²ï¼ŒåŠé€æ˜ç°è‰² */
  border-radius: 4px;
  /* åœ†è§’ */
  transition: background 0.3s;
}

/* 4. æ»‘å—æ‚¬åœçŠ¶æ€ (äº¤äº’åé¦ˆ) */
::-webkit-scrollbar-thumb:hover {
  background: rgba(144, 147, 153, 0.5);
  /* æ‚¬åœæ—¶åŠ æ·± */
}

/* === å®šä¹‰ä¸€ä¸ªå·¥å…·ç±»ï¼šç”¨äºéšè—æ»šåŠ¨æ¡ä½†ä¿ç•™æ»šåŠ¨åŠŸèƒ½ === */
/* ä½¿ç”¨æ–¹æ³•ï¼šåœ¨æ ‡ç­¾ä¸ŠåŠ  class="hide-scrollbar" */
.hide-scrollbar {
  scrollbar-width: none;
  /* Firefox */
  -ms-overflow-style: none;
  /* IE 10+ */
}

.hide-scrollbar::-webkit-scrollbar {
  display: none;
  /* Chrome/Safari/Webkit */
}

.ie-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--ie-primary-color);
  /* å…³é”®ï¼šä½¿ç”¨ä¸»é¢˜è‰²å˜é‡ */
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  margin-top: -6px;
  /* è°ƒæ•´å‚ç›´å¯¹é½ */
}

/* Firefox æµè§ˆå™¨ */
.ie-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border: 2px solid white;
  border-radius: 50%;
  background: var(--ie-primary-color);
  /* å…³é”®ï¼šä½¿ç”¨ä¸»é¢˜è‰²å˜é‡ */
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

/* ä¿®æ­£æ»‘å—è½¨é“é¢œè‰² (å¯é€‰ï¼Œè§†å…¨å±€æ ·å¼è€Œå®š) */
.ie-slider::-webkit-slider-runnable-track {
  height: 4px;
  background: #e4e7ed;
  /* è½¨é“èƒŒæ™¯è‰² */
  border-radius: 2px;
}

/* ... åŸæœ‰å†…å®¹ä¿æŒä¸å˜ ... */

/* === é€šç”¨å°å·æ•°å­—è¾“å…¥æ¡† (ä¿®å¤èƒŒæ™¯è‰²ä¸éšè—ç®­å¤´) === */
.ie-small-input {
  background-color: #ffffff;
  /* 1. å¼ºåˆ¶ç™½è‰²èƒŒæ™¯ */
  color: #606266;
  /* 2. æ ‡å‡†æ–‡å­—é¢œè‰² */
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  text-align: center;
  outline: none;
  transition: border-color 0.2s;
  width: 50px;
  /* Firefox ç§»é™¤ç®­å¤´ */
  -moz-appearance: textfield;
}

.ie-small-input:focus {
  border-color: var(--ie-primary-color);
}

/* Chrome, Safari, Edge, Opera ç§»é™¤ç®­å¤´ */
.ie-small-input::-webkit-outer-spin-button,
.ie-small-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

/* === æ ‡å‡†åŒ–æ•°å€¼è¾“å…¥æ¡† (é…åˆ Slider ä½¿ç”¨) === */
/* å®ªæ³• 6.2 è§„å®šï¼šå›ºå®šå®½ 50pxï¼Œé«˜ 28px */
.ie-input-number {
  width: 50px;
  height: 28px;
  padding: 0;
  border: 1px solid var(--ie-border-color);
  border-radius: 4px;
  text-align: center;
  font-size: 12px;
  color: #606266;
  background-color: #ffffff;
  outline: none;
  transition: border-color 0.2s;
  appearance: textfield;
  /* æ ‡å‡†å±æ€§ */
  -moz-appearance: textfield;
  /* Firefox */
}

.ie-input-number:focus {
  border-color: var(--ie-primary-color);
}

/* ç§»é™¤ Webkit æµè§ˆå™¨çš„åŸç”Ÿç®­å¤´ */
.ie-input-number::-webkit-outer-spin-button,
.ie-input-number::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
</file>

<file path="src/components/layout/EditorLayout.vue">
<template>
  <div class="image-editor-sdk-container">
    <NavBar :textMap="textMap" class="layout-header" />

    <div class="layout-body">
      <LeftSidebar class="layout-sidebar" />

      <ToolPanel class="layout-panel" />

      <Workspace :imageUrl="imageUrl" class="layout-workspace" />
    </div>
    <LoadingOverlay />
  </div>
</template>

<script setup>
import { provide, ref, watch } from 'vue';
import { useCanvas } from '../../composables/useCanvas';
import NavBar from './NavBar.vue';
import LeftSidebar from './LeftSidebar.vue';
import ToolPanel from '../panels/ToolPanel.vue';
import Workspace from '../Workspace.vue';
import LoadingOverlay from '@/components/common/LoadingOverlay.vue';
const sdkContainer = ref(null);

// === 1. å®šä¹‰ç»„ä»¶æ¥å£ (Props & Emits) ===
const props = defineProps({
  // åˆå§‹å›¾ç‰‡é“¾æ¥
  imageUrl: {
    type: String,
    default: 'https://wallpaperm.cmcm.com/21f96d39cffd296c2dd2f0cf9cf65c9b.jpg'
  },
  // æ–‡æœ¬æ˜ å°„è¡¨
  textMap: {
    type: Object,
    default: () => ({
      upload: 'æ‰“å¼€å›¾ç‰‡',
      save: 'ä¿å­˜',
      title: 'å¤§ç§˜ç¾å›¾'
    })
  },
  // å…¨å±€é…ç½®ï¼ˆå¦‚ AI åç«¯åœ°å€ï¼‰
  config: {
    type: Object,
    default: () => ({
      aiBaseUrl: 'http://localhost:3000/ai', // é»˜è®¤å€¼
    })
  }
});

const emit = defineEmits(['save']); // å®šä¹‰ä¿å­˜äº‹ä»¶

// === 2. Provide é…ç½®ç»™å­ç»„ä»¶ ===
// è¿™æ · AdjustRembg.vue ç­‰ç»„ä»¶å¯ä»¥é€šè¿‡ inject('editorConfig') è·å–é…ç½®
provide('editorConfig', props.config);

// === 3. åˆå§‹åŒ– Canvas é€»è¾‘ ===
const {
  init,
  initImage,
  addImage,
  toggleDrawing,
  exportMask,
  replaceActiveImage,
  canvas,
  zoom,
  zoomIn,
  zoomOut,
  zoomReset,
  zoomToRect,
  addText,
  rotateActive,
  flipActive,
  undo,
  redo,
  saveHistory
} = useCanvas();

// === 4. ç›‘å¬å›¾ç‰‡å˜åŒ– ===
watch(() => props.imageUrl, (newUrl) => {
  if (newUrl && canvas.value) {
    initImage(newUrl);
  }
});

// å°è£…åˆå§‹åŒ–æ–¹æ³•ï¼Œä»¥ä¾¿åœ¨ Canvas å‡†å¤‡å¥½ååŠ è½½åˆå§‹å›¾ç‰‡
const handleInit = (id, width, height) => {
  init(id, width, height); // è°ƒç”¨åŸå§‹ init

  // å¦‚æœæœ‰ä¼ å…¥å›¾ç‰‡ï¼Œå»¶è¿ŸåŠ è½½
  if (props.imageUrl) {
    setTimeout(() => {
      initImage(props.imageUrl);
    }, 100);
  }
};

// ã€æ–°å¢ã€‘è¿˜åŸåˆ°åˆå§‹çŠ¶æ€çš„æ–¹æ³•
const handleReset = () => {
  // ç¡®ä¿æœ‰åˆå§‹å›¾ç‰‡ URL ä¸” initImage æ–¹æ³•å¯ç”¨
  if (props.imageUrl && initImage) {
    // è°ƒç”¨ useCanvas çš„ initImage æ–¹æ³•ï¼Œä¼ å…¥åˆå§‹ URL
    // è¿™ä¼šæ¸…ç©ºç”»å¸ƒã€é‡ç½®å†å²è®°å½•å¹¶åŠ è½½åˆå§‹å›¾ç‰‡
    initImage(props.imageUrl);
  }
};

// ä¿å­˜å›¾ç‰‡
const handleExport = () => {
  // 1. å–æ¶ˆé€‰ä¸­çŠ¶æ€
  canvas.value?.discardActiveObject();
  canvas.value?.renderAll();

  // 2. è·å– Base64
  const dataURL = canvas.value?.toDataURL({ format: 'png' });

  // 3. æŠ›å‡ºäº‹ä»¶ç»™çˆ¶ç»„ä»¶
  emit('save', dataURL);
};

// === 5. ç»„è£… API å¯¹è±¡ ===
const api = {
  canvas,
  init: handleInit,
  zoom,
  zoomIn,
  zoomOut,
  zoomReset,
  zoomToRect,
  initImage,
  addImage,
  toggleDrawing,
  exportMask,
  replaceActiveImage,
  rotateActive,
  flipActive,
  undo,
  redo,
  saveHistory,
  addText: (text) => addText(text),
  exportImg: () => canvas.value?.toDataURL({ format: 'png' }),
  getActiveImgSrc: () => canvas.value?.getActiveObject()?.getSrc(),
  clearPaths: () => {
    const paths = canvas.value?.getObjects().filter(o => o.type === 'path');
    canvas.value?.remove(...paths);
  },
  save: handleExport,
  reset: handleReset
};

// === å‘ä¸‹åˆ†å‘ ===
provide('canvasAPI', api);
defineExpose({
  save: handleExport,
  undo,
  redo,
  canvas: canvas
})
</script>

<style scoped>
/* ä¿®æ”¹ç±»åï¼Œé¿å…è¿‡äºé€šç”¨çš„ layout-container */
.image-editor-sdk-container {
  display: flex;
  flex-direction: column;
  /* æ”¹ä¸º 100% ä»¥é€‚åº”çˆ¶å®¹å™¨ï¼Œè€Œä¸æ˜¯å¼ºåˆ¶å…¨å± */
  height: 100%;
  width: 100%;
  overflow: hidden;
  background-color: #fff;
  position: relative;
}

.layout-header {
  height: 50px;
  flex-shrink: 0;
  z-index: 20;
  border-bottom: 1px solid #e4e7ed;
  /* ç¡®ä¿æœ‰è¾¹ç•Œ */
}

.layout-body {
  display: flex;
  flex: 1;
  overflow: hidden;
  position: relative;
}

.layout-sidebar {
  width: 72px;
  flex-shrink: 0;
  z-index: 10;
}

.layout-panel {
  width: 300px;
  flex-shrink: 0;
  z-index: 10;
}

.layout-workspace {
  flex: 1;
  background-color: #f0f2f5;
  position: relative;
  min-width: 0;
}
</style>
</file>

<file path="src/composables/useCanvas.js">
import { ref, shallowRef, markRaw, toRaw, unref, onMounted, onUnmounted } from "vue";
import { fabric } from "fabric";
// âœ¨ å¼•å…¥ state ä»¥ä¾¿è¯»å–å½“å‰çš„ activeTool/activeTab
import { useEditorState, ZOOM_PADDING } from "./useEditorState";

import {
  registerCropModule,
  constrainCrop,
  cropObject,
  cancelCrop,
  rotateActive as rotateCrop,
  flipActive as flipCrop
} from "@/components/modules/adjust/useCanvasCrop";

const ROUTING_ALLOWLIST = ['ruler'];

export function useCanvas() {
  const canvas = shallowRef(null);
  // âœ¨ è·å– state å¯¹è±¡
  const { state, setHistoryState, setActiveTool, setSidebarDisabled, routeToObject } = useEditorState();
  const zoom = ref(1);

  // äº¤äº’çŠ¶æ€å˜é‡
  let isPotentialClick = false;
  let dragStartPoint = null;

  // === å†å²è®°å½• ===
  const history = [];
  let historyIndex = -1;
  let historyProcessing = false;

  const saveHistory = () => {
    if (!canvas.value || historyProcessing) return;
    if (historyIndex < history.length - 1) {
      history.splice(historyIndex + 1);
    }
    const json = JSON.stringify(
      canvas.value.toJSON([
        "id", "selectable", "name", "isMainImage", "isPuzzleImage", 
        "cellIndex", "isMaskObject",
        "customTab", "customTool", "isRuler", "excludeFromExport"
      ])
    );
    history.push(json);
    historyIndex++;
    if (history.length > 50) {
      history.shift();
      historyIndex--;
    }
    updateStoreHistory();
  };

  const updateStoreHistory = () => {
    setHistoryState(historyIndex > 0, historyIndex < history.length - 1);
  };

  const undo = () => { /* ...ä¿æŒåŸæ ·... */ 
    if (!canvas.value || historyIndex <= 0 || historyProcessing) return;
    if (cropObject.value) cancelCrop();
    historyProcessing = true;
    historyIndex--;
    const content = history[historyIndex];
    canvas.value?.loadFromJSON(content, () => {
      canvas.value?.renderAll();
      historyProcessing = false;
      updateStoreHistory();
    });
  };

  const redo = () => { /* ...ä¿æŒåŸæ ·... */ 
    if (!canvas.value || historyIndex >= history.length - 1 || historyProcessing) return;
    if (cropObject.value) cancelCrop();
    historyProcessing = true;
    historyIndex++;
    const content = history[historyIndex];
    canvas.value?.loadFromJSON(content, () => {
      canvas.value?.renderAll();
      historyProcessing = false;
      updateStoreHistory();
    });
  };

  const zoomToRect = (rect, minZoomLimit = 0.1) => { /* ...ä¿æŒåŸæ ·... */ 
    if (!canvas.value) return;
    const width = canvas.value.width;
    const height = canvas.value.height;
    let targetZoom = Math.min(width / rect.width, height / rect.height) * ZOOM_PADDING;
    targetZoom = Math.max(minZoomLimit, Math.min(targetZoom, 50));
    const rectCenterX = rect.left + rect.width / 2;
    const rectCenterY = rect.top + rect.height / 2;
    const panX = (width / 2) - (rectCenterX * targetZoom);
    const panY = (height / 2) - (rectCenterY * targetZoom);
    canvas.value.setViewportTransform([targetZoom, 0, 0, targetZoom, panX, panY]);
    zoom.value = targetZoom;
    canvas.value.requestRenderAll();
  };

  // === ğŸ›¡ï¸ è·¯ç”±å®‰ä¿æ ¸å¿ƒ ===
  const handleSelection = (eventOrObject) => {
    let target = null;
    
    // 1. è§£æç›®æ ‡
    if (eventOrObject && eventOrObject.selected) {
        target = eventOrObject.selected.find(obj => 
            obj.customTab && ROUTING_ALLOWLIST.includes(obj.customTab)
        );
        if (!target) target = eventOrObject.selected[0];
    } else {
        target = eventOrObject;
    }

    if (!target) {
      if (state.activeTool === 'adjust' && state.activeTab) return; 
      setSidebarDisabled(true);
      return;
    }

    // âœ¨âœ¨âœ¨ ç‹¬å æ¨¡å¼æ‹¦æˆªå™¨ (Exclusive Mode Guard) ä¼˜åŒ– âœ¨âœ¨âœ¨
    if (state.activeTool === 'adjust' && state.activeTab) {
        // âœ¨ å¢åŠ å®¹é”™ï¼šå¦‚æœç‚¹å‡»çš„ç›®æ ‡å°±æ˜¯æ ‡å°ºï¼Œä¸”æˆ‘ä»¬æ­£åœ¨å¤„ç†æ ‡å°ºé€»è¾‘ï¼Œåˆ™ç›´æ¥æ”¾è¡Œ
        // é˜²æ­¢ state.activeTab è¿˜æ²¡æ¥å¾—åŠæ›´æ–°å¯¼è‡´çš„æ­»é”
        const isRulerEmergency = target.isRuler || target.customTab === 'ruler';
        
        if (!isRulerEmergency && target.customTab !== state.activeTab) {
            console.log(`[Router] Blocked by Exclusive Mode. Current: ${state.activeTab}`);
            return;
        }
    }

    if (target.isMaskObject || target.excludeFromExport) return;

    // ç™½åå•è·¯ç”±
    if (target.customTab && ROUTING_ALLOWLIST.includes(target.customTab)) {
        routeToObject(target);
    } else {
        setSidebarDisabled(false);
    }
  };

  const handleMouseDown = (opt) => {
      const target = opt.target;
      if (!target) return;

      // âœ¨ å”¤é†’é€»è¾‘ä¹Ÿå—ç‹¬å æ¨¡å¼çº¦æŸ
      if (state.activeTool === 'adjust' && state.activeTab && target.customTab !== state.activeTab) {
          return; // æ‹¦æˆªå”¤é†’
      }

      const activeObj = canvas.value?.getActiveObject();
      if (activeObj === target) {
          handleSelection({ selected: [target] });
      }
  };

  // ... åˆå§‹åŒ–ä¸è¾…åŠ©å‡½æ•° (init, addImage, setZoom, etc.) ä¿æŒåŸæ · ...
  // ä¸ºèŠ‚çœç¯‡å¹…ï¼Œåç»­å‡½æ•°æœªå˜åŠ¨ï¼Œè¯·ä¿æŒæ‚¨åŸæœ‰çš„ä»£ç 
  // ä»…éœ€ç¡®ä¿ handleSelection å’Œ handleMouseDown å·²æŒ‰ä¸Šè¿°é€»è¾‘æ›´æ–°

  const init = (id, width, height) => {
    // ... åŸæœ‰ init ä»£ç  ...
    console.log("init canvas", id, width, height);
    const c = new fabric.Canvas(id, {
      width: width,
      height: height,
      backgroundColor: "#f3f3f3",
      preserveObjectStacking: true,
      fireRightClick: true,
      stopContextMenu: false
    });
    canvas.value = markRaw(c);

    registerCropModule(canvas, saveHistory, zoomToRect);

    const checkConstraint = () => {
      if (cropObject.value) {
        constrainCrop(toRaw(cropObject.value));
      }
    };
    c.on("object:modified", (e) => {
      checkConstraint();
      if (e.target && e.target.type !== "rect") saveHistory();
    });
    c.on("object:added", (e) => {
      if (e.target && e.target.type !== "rect") saveHistory();
    });
    c.on("object:removed", (e) => {
      if (e.target && e.target.type !== "rect") saveHistory();
    });

    c.on("mouse:down", (opt) => {
      isPotentialClick = true;
      const pointer = c.getPointer(opt.e);
      dragStartPoint = { x: pointer.x, y: pointer.y };
      handleMouseDown(opt);
    });

    c.on("mouse:move", (opt) => {
      if (!isPotentialClick) return;
      const pointer = c.getPointer(opt.e);
      const dist = Math.sqrt(
        Math.pow(pointer.x - dragStartPoint.x, 2) +
        Math.pow(pointer.y - dragStartPoint.y, 2)
      );
      if (dist > 5) {
        isPotentialClick = false; 
      }
    });

    c.on("mouse:up", (opt) => {
      if (!isPotentialClick || c.isDrawingMode || cropObject.value) return;
      const target = c.getActiveObject();
      if (!target) {
          handleSelection(null);
      }
    });

    c.on("selection:created", (e) => {
      if (!isPotentialClick && (e.target || (e.selected && e.selected.length > 0))) {
        handleSelection(e); 
      }
    });

    c.on("selection:updated", (e) => {
      handleSelection(e); 
    });

    c.on("selection:cleared", () => {
      setSidebarDisabled(true);
    });
    
    // ... zoom event ...
    const canvasEl = c.upperCanvasEl;
      canvasEl.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          e.stopPropagation();
          const delta = e.deltaY;
          let newZoom = c.getZoom();
          newZoom *= 0.999 ** delta;
          if (newZoom > 50) newZoom = 50;
          if (newZoom < 0.1) newZoom = 0.1;
          c.zoomToPoint({ x: e.offsetX, y: e.offsetY }, newZoom);
          zoom.value = newZoom;
        },
        { passive: false }
      );

    saveHistory();
  };
  
  // ... helper functions ...
  const addImage = (url) => {
    fabric.Image.fromURL(url, (img) => {
        const canvasWidth = canvas.value.width;
        const canvasHeight = canvas.value.height;
        if (img.width > canvasWidth || img.height > canvasHeight) {
          const scale = Math.min(canvasWidth / img.width, canvasHeight / img.height) * ZOOM_PADDING;
          img.scale(scale);
        }
        img.set({ isMainImage: true, id: 'main-image' });
        zoom.value = canvas.value.getZoom();
        historyProcessing = true;
        canvas.value?.add(img);
        canvas.value?.centerObject(img);
        canvas.value?.setActiveObject(img);
        historyProcessing = false;
        saveHistory();
        canvas.value.fire('image:updated');
    }, { crossOrigin: "anonymous" });
  };

  const setZoom = (value) => {
    if (!canvas.value) return;
    let newZoom = value;
    if (newZoom > 50) newZoom = 50;
    if (newZoom < 0.1) newZoom = 0.1;
    const center = canvas.value.getCenter();
    canvas.value.zoomToPoint({ x: center.left, y: center.top }, newZoom);
    zoom.value = newZoom;
  };
  const zoomIn = () => setZoom(zoom.value + 0.1);
  const zoomOut = () => setZoom(zoom.value - 0.1);
  const zoomReset = () => setZoom(1);

  const initImage = (url) => {
    if (!canvas.value) return;
    historyProcessing = true;
    canvas.value.clear();
    canvas.value.setBackgroundColor("#f3f3f3", () => { canvas.value.renderAll(); });
    historyProcessing = false;
    history.length = 0;
    historyIndex = -1;
    updateStoreHistory();
    addImage(url);
  };

  const rotateActive = (angle) => {
    const handled = rotateCrop(angle);
    if (!handled) {
      const activeObj = canvas.value?.getActiveObject();
      if (activeObj) {
        activeObj.rotate((activeObj.angle || 0) + angle);
        canvas.value.requestRenderAll();
        saveHistory();
      }
    }
  };

  const flipActive = (axis) => {
    const handled = flipCrop(axis);
    if (!handled) {
      const activeObj = canvas.value?.getActiveObject();
      if (activeObj) {
        if (axis === "X") activeObj.set("flipX", !activeObj.flipX);
        if (axis === "Y") activeObj.set("flipY", !activeObj.flipY);
        canvas.value.requestRenderAll();
      }
    }
  };

  const toggleDrawing = (enable) => {
    if (!canvas.value) return;
    canvas.value.isDrawingMode = enable;
    if (enable) {
      const brush = new fabric.PencilBrush(canvas.value);
      brush.color = "rgba(255, 0, 0, 0.5)";
      brush.width = 30;
      canvas.value.freeDrawingBrush = brush;
    }
  };

  const exportMask = () => {
    if (!canvas.value) return null;
    const originalBg = canvas.value.backgroundColor;
    const objects = canvas.value.getObjects();
    objects.forEach((obj) => {
      if (obj.type === "path" || obj.isMaskObject) {
        obj._originalStroke = obj.stroke;
        obj._originalFill = obj.fill;
        obj.set({ stroke: "#ffffff", fill: "#ffffff" });
      } else {
        obj._originalOpacity = obj.opacity;
        obj.set({ opacity: 0 });
      }
    });
    canvas.value.setBackgroundColor("#000000", null);
    canvas.value.renderAll();
    const dataURL = canvas.value.toDataURL({ format: "png", multiplier: 1 });
    objects.forEach((obj) => {
      if (obj.type === "path" || obj.isMaskObject) {
        obj.set({ stroke: obj._originalStroke, fill: obj._originalFill });
      } else {
        obj.set({ opacity: obj._originalOpacity ?? 1 });
      }
    });
    canvas.value.setBackgroundColor(originalBg, null);
    canvas.value.renderAll();
    return dataURL;
  };

  const replaceActiveImage = (newUrl) => {
    const activeObj = canvas.value?.getActiveObject();
    if (!activeObj || activeObj.type !== "image") return;
    activeObj.setSrc(newUrl, () => {
        canvas.value.renderAll();
        saveHistory();
        canvas.value.fire('image:updated');
      }, { crossOrigin: "anonymous" }
    );
  };

  const addText = (textStr = "åŒå‡»ç¼–è¾‘") => {
    if (!canvas.value) return;
    const text = new fabric.IText(textStr, {
      left: 100, top: 100, fontSize: 40, fill: "#333",
      // customTab: 'text' 
    });
    canvas.value.add(text);
    canvas.value.setActiveObject(text);
    canvas.value.requestRenderAll(); 
    saveHistory();
  };

  return {
    canvas, zoom, init, initImage, addImage, zoomIn, zoomOut, zoomReset, zoomToRect, setZoom,
    undo, redo, saveHistory, toggleDrawing, exportMask, replaceActiveImage, addText, rotateActive, flipActive
  };
}
</file>

</files>
